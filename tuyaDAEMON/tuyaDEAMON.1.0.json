[{"id":"ee953c15.ada29","type":"subflow","name":"connected","info":"Handles tuya device status changes.\r\n\r\n\r\nProcesses the status of a real device , if the connection status changes:\r\n   - Creates a log msg (deviceId, \"_connected\", true/false) for standard processing\r\n \r\nIMPORTANT: set the ** deviceID ** parameter with the correct ID value.","category":"","in":[{"x":80,"y":80,"wires":[{"id":"6160136.f5f99ec"}]}],"out":[{"x":440,"y":80,"wires":[{"id":"6160136.f5f99ec","port":0}]}],"env":[{"name":"deviceId","type":"str","value":""}],"color":"#DDAA99","icon":"font-awesome/fa-rss-square"},{"id":"6160136.f5f99ec","type":"function","z":"ee953c15.ada29","name":"device connected message","func":"// set DIRECTLY global.tuyasyatus.xxxx._connected \n// send msg every change call only as trigger\n\nvar CONN = \"_connected\";  //  tuyadaemon internal define\n// see also tuyaDAEMON.\"connection check\" function\n\n// local function\nfunction _sendReal(idevice, name, value){\n// builds a fake OUT message \nvar newMsg = { \"payload\":{\n      \"deviceId\": idevice,\n      \"deviceName\": name,\n      \"data\": {\n          \"dps\":{\n              \"_connected\":value\n          }}}};\nreturn newMsg;  \n}\n\n// stuff to acces global.alldevices\n// using subflow parameter deviceId\nvar alldevices = global.get(\"alldevices\");\nif (alldevices === undefined) return null;\n// user set id\nvar deviceId = env.get(\"deviceId\");\n// only real devices are connected\nvar dev = alldevices.real.find(device => device.id === deviceId);\nif (dev === undefined) return null;\n// found...\n// logic process:\nvar nowconnected =  (msg.status.text == \"connected\");        // can change\nreturn(_sendReal(deviceId, dev.name, nowconnected) );\n \n\n\n\n\n","outputs":1,"noerr":0,"initialize":"// Code added here will be run once\n// set the default status _connected to true in tuyastatus\n// creates tuyastatus entry to null.\nvar alldevices = global.get(\"alldevices\");\nif (alldevices === undefined) return null;\nvar deviceId = env.get(\"deviceId\");\nvar d = alldevices.real.find(device => device.id === deviceId);\nif (d === undefined) return null;\n//\nvar tuyastatus = global.get(\"tuyastatus\");\n    if (tuyastatus == undefined)\n        tuyastatus = {};\n    if (tuyastatus[d.name] === undefined) {\n        tuyastatus[d.name] = {_connected:null};\n        global.set(\"tuyastatus\", tuyastatus);\n    }\n    ","finalize":"","x":260,"y":80,"wires":[[]]},{"id":"173260fb.d021ff","type":"tab","label":"TuyaDAEMON","disabled":false,"info":"The **tuyaDAEMON flow** handles all _tuya-nodered_ basic communications, giving you a (quasi) complete bidirectional integration with tuya cloud.\n\nThis project offers strong isolation from tuya communication details, the safe and controlled use of  _tuya-smart-device_ node capabilities,  protection from the device's firmware quirks (unluckily many devices accepts only a sub-set of standard tuya commands) and user-friendly device names.\n\n**Main features:**\n \n -  transforms the `id/cid` index to user-friendly `device-name` and vice-versa.\n -  transforms the `dps` index to user-friendly `attribute-name` and vice-versa.\n -  processes `i/o data` as required to/from user `standard units`.\n -  filters all user requests, sending only the  allowed ones, on a `device/dps` basis.\n -  easy handles a  `zigbee gateway` device, allowing complete control over zigbee battery-powered devices.\n -  allows the use of features present in your devices but not exploited by _smartlive_ app.\n -  define custom devices and attributes to handle system features (e.g. connection).\n\n\nUsing the addon **tuyaTRIGGER** flow you get:\n\n - the capability to echo to node-red all tuya events from `any device` (mirrowing). This is required to work with devices not caught by _tuya-smart-device_ node, like WiFi battery-powered devices  or like IR remote controls  (limit: node-red can't access the tuya numerical values).\n\n -  handles custom triggers `from smartLife` to start node_red flows.\n \n -  sends custom triggers `to cloud` to start ad hoc automation.\n \n**Globals:**\n \nFor every captured message, TuyaDAEMON:\n 1. updates the node-red `global.tuyastatus` object, accessible from all your custom flows.\n 2. saves the data to a `tuyathome.messages` table in a DB mySQL.\n 3. on selected messages can fire a custum flow\n\n**global.tuyastatus**: is a strucuture RT updated, with all data from devices and smartLife.\n Uses device-names and attribute-names. The values are in standard units.\nexamples: \n-  `tuyastatus.tuya_bridge.switch` = \"OFF\"\n-  `tuyastatus[\"Temperature 3\"].Temperatura` = 19  (in °C)\n-  `tuyastatus[\"Smart IR 2\"].connected`  = true\n-  `tuyastatus[\"Termosifone 2\"][\"HDay target Temperture\"]` =      \"[16,16,16,16,16,16,16,20,20,20,20,20,0,0,0,0,0,0,0,0,0,0,0,0]\"\n\n User custom automation, user devices, user interfaces, not available in smartlife app, can be developped on **node-red** in separate flows, using only:\n    - device-name and attribute-names.\n    - data standard values\n    - the `global.tuyastatus` object.\n \n\n**mySQL \"tuyathome.messages\" table**: it is used to log all messages (or only the filtered messages), using `id/cid` and device-name, `dps` and data-name, processed and unprocessed `values`.\n \n Debug of new devices, historical data statistics, user interfaces can be done in any language (e.g. php) using the data stored in mySQL.\n\n**Customization**\n\nThis flow **must** be customized to meet your environement and your available devices.\nMany options are defined inside `global.alldevice`: a data structure user defined in the `setup` node, but **tuyaDAEMON** flow require nevertheless some node customization: for your convenience _the nodes with an asterisk \"*\" on the nome MUST be updated, and detailed instructions are in the node help._\n\n**notes**\n- the use of index like `deviceId`, _cid_, and `dps` is restricted to tuyaDAEMON.\n- the `global.tuyastatus` structure and the DB records uses `device-name` and  `attribute-name`, as defined in `alldevice` structure. The device's names used by **smartlife app** (and _Google home_) can be different, to better fit **Google-nest** vocal exigences.\n\n\nTested using 20+ different Tuya devices.\n\n**TuyaDAEMON devices archive**\n\nA DB structure to store all the useful information of Tuya devices. It can be used:\n- as reference material for TuyaDAEMON users (produces a pdf page for device)\n- as a `global.alldevice` JSON generator to limit the analize effort only to new devices.\n\nClonable and open to all contributions.\n_Soon (work in progress)_.\n\n"},{"id":"1a711832.f93bb8","type":"mysql","z":"173260fb.d021ff","mydb":"7e3077c8.ff8e88","name":"append to DB","x":1120,"y":680,"wires":[[]]},{"id":"a878b58e.e4ea08","type":"function","z":"173260fb.d021ff","name":"*OUT data process","func":"// Data codification is function of the device and dps.\n// To new code data format:\n// 1)  Add a new required decoding function() in the array datadecode[], using a new type_name\n// 2)  Add the dual coding function to \"format command\" node.\n// 3)  now you can use the new type_name as typefield  in global.alldevices\n\n\nvar datadecode = {\n   // to format values from device messages to standard form\n   // add new functions to array as required\n    BYTESMALLFLOAT: function (value) {\n     // transform byte data on number, then divide 10.\n     // exanple: C3H = 195 => 19.5  (°C: units as from device setup)\n     // required by thermostat\n      return (Number(value) / 10.0);\n   },\n\n   BOOLEANONOFF: function (value) {\n      // transform (false, 0, \"\")/true, to 'OFF'/'ON'\n      // en: can be localized for internationalization\n      return (value == 0 ? \"OFF\" : (value == 1 ? \"ON\" : value));\n   },\n\n  \n   ENUMONOFFHOLD: function (value) {\n      // transform 0/1/2 to OFF/ON/HOLD\n      // en: can be localized for internationalization\n      return (value == 0 ? \"OFF\" : (value == 1 ? \"ON\" : (value == 2 ? \"HOLD\" : value)));\n   },\n\n   STRUCTARGETTEMP: function (value) {\n      // transform from base64(Uint8Array[17]) to object:\n      //   {\"count\":4,\n      //    \"changes\":[{\"time\":\"00:00\",\"temp\":15.5},\n      //              {\"time\":\"07:00\",\"temp\":20},\n      //              {\"time\":\"16:30\",\"temp\":21},\n      //              {\"time\":\"21:00\",\"temp\":16.5}]}\n      // required by thermostat\n      function minTohm(min) { // local function\n         h = (~~(min / 60));\n         m = min % 60;\n         return (h > 9 ? h : '0' + h) + \":\" + (m > 9 ? m : '0' + m);\n      }\n\n      b = Buffer.from(value, \"base64\");\n      var n = b.readUInt8(0);\n      var result = {\n         count: n,\n         changes: []\n      };\n      for (var i = 0; i < n; i++) {\n         result.changes[i] = {\n            time: minTohm(b.readUInt16BE(i * 4 + 1)),\n            temp: b.readUInt16BE(i * 4 + 3) / 10\n         };\n      }\n //     return (JSON.stringify(result));\n       return (result);\n  }, // ends function\n\n   ARRAY8INT: function (value) {\n      // transform  base64(Uint8Array[X]) to UInt8[]\n      // X=24 =>  [16,16,15,15,14,14,16,17,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\"\n      // required by thermostat \n      b = Buffer.from(value, \"base64\");\n      return (\"[\" + new Uint8Array(b).toString() + \"]\");\n   },\n\n   STRUCTTIMEHMS: function (value) {\n      // tentative, on work\n      // transform  base64(Uint16Array[3]) to \"HH:MM:SS\" ??\n      // required by thermostat ?\n      b = Buffer.from(value, \"base64\");\n      const uint16arr = new Uint16Array(\n            b.buffer,\n            b.byteOffset,\n            b.length / Uint16Array.BYTES_PER_ELEMENT);\n      return ((Uint16Array[0] > 9 ? Uint16Array[0] : \"0\" + Uint16Array[0]) + \":\" +\n         (Uint16Array[1] > 9 ? Uint16Array[1] : \"0\" + Uint16Array[1]) + \":\" +\n         (Uint16Array[2] > 9 ? Uint16Array[2] : \"0\" + Uint16Array[2]));\n   },\n   \n     STRUCTCOULOR: function (value) {\n     //  Transforms  RRGGBB0000FFFF to object\n     //       { \"hex\" : \"RRGGBB0000FFFF\",\n     //         \"red\": RR,\n     //         \"green\": GG,\n     //         \"blue\": BB }\n     // partial decode, some unknow\n     // required by humidifier led\n      b = Buffer.from(value, 'hex');\n      var result = {\n         hex: value,\n         red: 0,\n         green:0,\n         blue: 0 };\n      result.red = b.readUInt8(0) ;\n      result.green = b.readUInt8(1) ;\n      result.blue = b.readUInt8(2) ;\n      return (result);\n    }\n\n};\n// ----------------------------------------------------\n//device OUT msg (real)\n//  _msgid: \"1234f3fd.8477fc\"\n//  _event: \"node:1233963.a7d146\"\n//  payload: object\n//     deviceId: \"123455aa196ae5875cy6ii\"\n//     deviceName: \"*tuya_bridge\" (tuya name optional, not used)\n//     data: object\n//        t: 1609234903\n//        dps: object\n//           102: 1020\n//\n//device OUT msg (virtual)\n//   _msgid: \"d0b26a44.e81738\"\n//   payload: object\n//      deviceId: \"123473b1b786b5994cro7p\"\n//      deviceName: \"Zigbee Gateway\"\n//      data: object\n//        cid: \"12358d00086a1c45\"\n//        t: 1609235292\n//        dps: object\n//           103: 19\n\n\nvar _dataname = \"\";\n\n// returns data.t or now(), formatted for mySQL, never fails\nfunction _mySQLdatetime(mx) {\n   //datetime format for mySQL: '2020-12-18 20:45:02'\n   // using 'sv' for date format and local timezone\n   if (mx.payload.data.t === undefined)\n      return (new Date().toLocaleString('sv'));\n   return (new Date(Number(mx.payload.data.t) * 1000).toLocaleString('sv'));\n}\n\n// true if device is a real device (virtual := cid exists)\nfunction _isreal(mx) {\n   return (mx.payload.data.cid === undefined);\n}\n\n//true if device is a fake existing device\nfunction _isfake(dname) {\n   return (_getObjDevice(dname, \"fake\") !== undefined);\n}\n\n// returns deviceId (real) or cid (virtual), never fails\nfunction _getID(mx) {\n   if (_isreal(mx))\n      return (mx.payload.deviceId);\n    return (mx.payload.data.cid);\n}\n\n// find ObjDevicem, using o.name or o.id or o.cid, from a device[]\n// otherwise return undefined.\nfunction _checkobj(list, dx) {\n   var o;\n   if (list == undefined)\n      return o;\n   o = list.find(device => device.name === dx);\n   if (o === undefined)\n      o = list.find(device => device.id === dx);\n   if (o === undefined)\n      o = list.find(device => device.cid === dx);\n  return (o);\n}\n// get ObjDevice, from name|id|cid, no limits or only real|virtual|fake\n// otherwise return undefined.\nfunction _getObjDevice(key, limit = null) {\n   function okcheck(lim, branch) {\n      return ((lim === null) || (lim === branch))\n   }\n   var odev;\n   var alld = global.get(\"alldevices\");\n   if (key === undefined)\n      return (odev);\n   if (okcheck(limit, \"real\"))\n      odev = _checkobj(alld.real, key);\n   if ((odev === undefined) && okcheck(limit, \"virtual\"))\n      odev = _checkobj(alld.virtual, key);\n   if ((odev === undefined) && okcheck(limit, \"fake\"))\n      odev = _checkobj(alld.fake, key);\n   return (odev);\n}\n\n// get the device object in alldevices, if it don't exist return undefined + warn\nfunction _getodevice(mx) {\n   var o;\n   if (_isreal(mx)) {\n      o = _getObjDevice(mx.payload.deviceId, \"real\");\n      if (o === undefined) {\n         o = _getObjDevice(mx.payload.deviceId, \"fake\");\n      }\n      if (o === undefined) {\n         node.warn(\"ERROR: ADD to alldevices the real/fake deviceid: \" + mx.payload.deviceId + \" (\" + mx.payload.deviceName + \")\");\n      }\n   } else {\n      o = _getObjDevice(mx.payload.data.cid, \"virtual\");\n      if (o === undefined) {\n         node.warn(\"ERROR: ADD to alldevices the virtual device cid: \" + mx.payload.data.cid + \" [gateway: \" + mx.payload.deviceId + \"]\");\n      }\n   }\n   return (o);\n}\n\n// return name from id in alldevices (virtual), never fail\nfunction _getName(mx) {\n   var o = _getodevice(mx);\n   if (o !== undefined)\n      return (o.name === undefined ? o.id : o.name);\n   return (\"undefined\");\n}\n\n// returns val, processed by correct dpprocess[] function, if required.\n// and sets  _dataname\nfunction _processData(mx, dpx, val) {\n   _dataname = \"\";\n   // tuyadaeamon internal defined fields for all devices\n   if (dpx === \"_connected\") {\n      _dataname = dpx;\n      return (val);\n   }\n   var o = _getodevice(mx);\n   var p;\n   if (o === undefined)\n      return (val);\n   if (Array.isArray(o.dps))\n      p = o.dps.find(data => data.dp == dpx);\n   if (p === undefined) {\n      node.warn(\"In alldevices missed the '\" + o.name + \"':dps[\" + dpx + \"] definition.\");\n      return (val);\n   }\n   _dataname = p.name;\n   if (_dataname === undefined)\n      _dataname = dpx;\n   if (p.typefield === undefined)\n      return (val); // no process\n   if (datadecode[p.typefield] === undefined) {\n      node.warn(\"Not found \" + p.typefield + \" decode function() for '\" + _dataname + \"': data unchanged.\");\n      return (val);\n   }\n   return datadecode[p.typefield](val);\n}\n\nvar warmsg = null;\n\n// updates the global \"tuyastatus\"\nfunction _addToStatus(dnx, _datanx, dx, tx, real) {\n   var tuyastatus = global.get(\"tuyastatus\");\n   if (tuyastatus == undefined)\n      tuyastatus = {};\n   if (tuyastatus[dnx] == undefined)\n      tuyastatus[dnx] = {};\n   tuyastatus[dnx][_datanx] = dx;\n   tuyastatus[dnx]._t = tx;\n   global.set(\"tuyastatus\", tuyastatus);\n   // info message\n   warmsg = {\n //     payload: \"RX STATUS: '\" + dnx + \"'/'\" + _datanx + \"' = \" + dx\n     payload: [ \"RX: '\" + dnx + \"'/'\" + _datanx + \"' \", dx]\n   };\n}\n//  detects some fatal errors in message structure\n function _badMsg(mx){\n    if (( mx.payload.deviceId === undefined) && ( mx.payload.data.cid === undefined)) {\n       node.warn(\"ERROR: OUT message without payload.deviceID or payload.data.cid: mandatory\");\n       return true;\n    } \n    if ( mx.payload.data === undefined)  {\n       node.warn(\"ERROR: OUT message without payload.data  (deviceID:\"+mx.payload.deviceId+\")\");\n       return true;\n       }\n    if (typeof mx.payload.data === 'string') return false;\n    if (( mx.payload.data === undefined) || ( mx.payload.data.dps === undefined)) {\n       node.warn(\"ERROR: OUT message without payload.data.dps (deviceID:\"+mx.payload.deviceId+\")\");\n       return true;\n    } \n return false;\n }\n    \nfunction formatData(data){\n    var clean = JSON.stringify(data);\n    if (clean[0] ==='\"')\n       clean= clean.substring(1).slice(0,-1);\n    return clean;\n}\n\n\n\n// ---------------------  main\n// sends any message to DB (in msg.topic), updates tuyastatus\n\nmsg.topic = \"\";\nif ( _badMsg(msg))\n  return ([null, null]);  // abort\n  \nvar dname = _getName(msg);\nif (dname === undefined)\n   return ([null, null]);\nif (msg.payload.data.dps !== undefined) {\n   Object.entries(msg.payload.data.dps).forEach(([key, value]) => {\n      warmsg = null;\n      if ((value !== undefined) && (value !== null)) {\n         var pdata = _processData(msg, key, value);\n         msg.topic += \" INSERT INTO `messages` (`timestamp`, `device-id`, `device-name`, `dps`, `dp-name`, `data`, `value`)\";\n         msg.topic += \" VALUES ('\" + _mySQLdatetime(msg) + \"', '\" + _getID(msg) + \"', '\" + dname.replace(/'/g, \"\\\\'\") + \"','\" + key + \"', '\" + _dataname.replace(/'/g, \"\\\\'\") + \"', '\" + formatData(value) + \"', '\" + formatData(pdata) +\"') ;\";\n         if (_dataname !== undefined) {\n            var tx = msg.payload.data.dps.t;\n            if (tx === undefined)\n               tx = Math.floor(Date.now() / 1000);\n            _addToStatus(dname, _dataname, pdata, tx, _isreal(msg));\n            node.send([warmsg, null]);\n         }\n      }\n   });\n} else {\n   if (msg.payload.data == \"json obj data unvalid\") {\n      node.warn(\"ERROR from '\" + dname + \"': not JSON data but 'json obj data unvalid': operation not allowed?.\");\n   } else {\n// maybe here it is possible to dedube the value send: see       \n      var buff = Buffer.from(msg.payload.data);\n      node.warn(\"ERROR from '\" + dname + \"': not JSON data but HEX:\" + buff.toString('hex') + \"  ('\" + msg.payload.data + \"')\");\n   }\n}\n\nif (msg.topic !== \"\") // some processed\n   return [null, msg];\n","outputs":2,"noerr":0,"initialize":"","finalize":"","x":630,"y":660,"wires":[["2caa595d.2a0106"],["9550d41.fdbe628"]]},{"id":"dfd320c0.b4f74","type":"tuya-smart-device","z":"173260fb.d021ff","deviceName":"here your device#1","deviceId":"i233b1b78912394cro7p","deviceKey":"42f1234fec2ffe12","x":990,"y":80,"wires":[["2ec83963.a7d146"]],"info":"**tuya_ms_104**   \n\n_tuya bridge for \"WiFi Smart Switch Module MS-104\"_\n\nAfter any command, this device sends (and this node captures) a 'status' message carring only the changed values.\n\nA command can be send by node-red, SmartLife app, Google home, Google voice: in any case this node captures the status message.\n\n_note:_\n If node-red changes the switch state, SmartLife is updated correctly, but Google Home not.\n \n_Input:_\nTo send a command via node-red. the payload structure must be:\n` multiple: true\n  data: object\n    1: true\n    102: 5`\n\n_nb:_\nset **Device Virtual ID** and **Device Key** to a tuya connected and working switch, model M-104 ( see [https://it.aliexpress.com/wholesale?SearchText=smart+switch+ms+104](https://it.aliexpress.com/wholesale?SearchText=smart+switch+ms+104))."},{"id":"9550d41.fdbe628","type":"function","z":"173260fb.d021ff","name":"*RX DB query filter","func":"// kills unwanted DB queries\n// -----------------------------------------\n// use:\n// msg.payload.deviceId  (device|gateway)\n// msg.payload.data.cid  (for virtual devices)\n// msg.payload.data.dps[dp]   single dp\n\n// kills malformated messages\nif(msg.payload.data.dps === undefined)  return (null);\n//\n// filter example: \n// kills all TRIGGERS messages (see tuyaTRIGGER)\n if(msg.payload.deviceId  == \"bfa355aa196ae5975cy6ii\") { // from tuya_bridge (real)\n    if (msg.payload.data.dps[\"102\"] != undefined)    // select trigger (dp == 102)\n         return(null);\n    }\n    \n// if(msg.payload.deviceId === \"_system\"  ) return null;  \n//  more....\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":870,"y":680,"wires":[["1a711832.f93bb8"]],"info":"On installation and test:\n  Best don't filer any message.\nOn production:\n  Better to filter not useful events.\n  _________________________________\n  \n See the example filter:\n Test can be done on \n     ` msg.payload.deviceId         for real devices\n       msg.payload.data.dps[<dpx>]  for specific events`\n  \n   "},{"id":"9fe80f7e.f3f7e","type":"link in","z":"173260fb.d021ff","name":"to logging","links":["28d20fae.6061b","2ec83963.a7d146","2fb79388.82d8cc","68d21677.32a9c8","798c4138.06176","db455c46.e4ac7","edf84736.d76338","54d03d6e.945994"],"x":240,"y":700,"wires":[["fe1a20ab.104ce"]],"icon":"font-awesome/fa-expand","l":true,"info":"entry point for messages from devices like:\n````\nfunction _sendOUT(deviceid, key,value){\n// builds a fake OUT message \nvar newMsg = { \"payload\":{\n      \"deviceId\": deviceid,  \n // for virtual change:\"deviceId\": gatewayId;\n      \"data\": {\n          \"t\": Math.floor( Date.now() / 1000 );\n // for virtual add:\"cid\": deviceid;\n          \"dps\":{\n              [key]:value\n          }}}};\nreturn newMsg;  \n}\n````\nOutput:\n - updates `global.tuyastatus[dev-name][attribute-name] = standard units`\n - adds a record to 'messages' DB table (filtered by `tuyaDAEMON.'DB messages filter`' node )\n - fires EVNTRIGGERXXX  (see `tuyaTRIGGERS.'event trigger'` node)"},{"id":"c991322e.a484e","type":"function","z":"173260fb.d021ff","name":"*format  command","func":"// Data codification is function of the device and dps: here you can add new encode functions().\n// To a new data format:\n// 1)  Add a new encoding function() in the array dataencode, using a new 'TYPE_NAME'\n// 2)  Add the dual decode function()) to \"OUT data process\" node.\n// 3)  now you can use the new 'TYPE_NAME' as typefield  in global.alldevices\n//\nvar dataencode = {\n\n   BYTESMALLFLOAT: function (value) {\n      // transforms temperature to byte: 19.5 => 195 => C3H\n      // required by thermostat\n     if (Number.isNaN(Number.parseFloat(value))) {\n         return 0;\n      }\n      return ~~(Number.parseFloat(value) * 10.0);\n   },\n\n   BOOLEANONOFF: function (value) {\n      // transforms 'ON'/'OFF' to boolean  true/false (very tolerant :  see https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons)\n      // it|en: can be localized for internationalization\n      if ( (value == 0) || (value == null) || (value.toUpperCase() === \"OFF\") || (value.toUpperCase() === \"FALSE\") || (value.toUpperCase() === \"NO\"))\n         return false;\n      return true;\n   },\n\n    \n   ENUMONOFFHOLD: function (value) {\n      // transforms 'OFF'/'ON'/'HOLD' to byte ENUM 0/1/2\n      // it|en: can be localized for internationalization\n       // required by switch\n     if ((value == 0) || (value == null) || (value.toUpperCase() === \"OFF\") || (value.toUpperCase() === \"FALSE\") || (value.toUpperCase() === \"NO\"))\n         return \"0\";\n      if (value.toUpperCase() === \"HOLD\")\n         return \"2\";\n      return \"1\";\n   },\n\n   STRUCTARGETTEMP: function (value) {\n      // transform the JSON structure:\n      //   {\"count\":4,\n      //    \"changes\":[{\"time\":\"00:00\",\"temp\":15.5},\n      //              {\"time\":\"07:00\",\"temp\":20},\n      //              {\"time\":\"16:30\",\"temp\":21},\n      //              {\"time\":\"21:00\",\"temp\":16.5}]}\n      // to  base64(Uint8Array[17])\n      // required by thermostat\n\n      function hmTomin(hm) { // local function\n         pieces = hm.split(':');\n         return (parseInt(pieces[0]) * 60 + parseInt(pieces[1]));\n      }\n      function mult10(value) {\n         return ~~(Number.parseFloat(value) * 10.0)\n      }\n\n      var o = JSON.parse(value);\n      var buf = Buffer.alloc(o.count * 4 + 1);\n\n      buf.writeInt8(o.count, 0);\n      for (var i = 0; i < o.count; i++) {\n         buf.writeInt16BE(hmTomin(o.changes[i].time), i * 4 + 1);\n         buf.writeInt16BE(mult10(o.changes[i].temp), i * 4 + 3);\n      }\n      return buf.toString('base64');\n   },\n\n   ARRAY8INT: function (value) {\n      // Transforms a UInt8Array, e.g.[17,16,16,16,15,15,17,18,19,19,18,18,18,18,17,16,17,18,18,0,0,0,0,0]\n      // to  coded64 data => ERAQEA8PERITExISEhIREBESEgAAAAAA\n      // required by thermostat\n      b = Buffer.from(JSON.parse(value));\n      return b.toString('base64');\n   },\n\n   STRUCTTIMEHMS: function (value) {\n      //  Transforms a time \"HH:MM:SS\"\n      //  in coded data base64(Uint16Array[3])\n      //  tentative, on work\n      pieces = value.split(':');\n      var buf = Buffer.alloc(6);\n      buf.writeInt16LE(parseInt(pieces[0]), 0);\n      buf.writeInt16LE(parseInt(pieces[2]), 2);\n      buf.writeInt16LE(parseInt(pieces[4]), 4);\n      return buf.toString('base64');\n   },\n   \n   STRUCTCOULOR: function (value) {\n     // accepts: JSON or object\n     // encode only partial:\n     //      {   \"hex\":\"RRGGBB0000FFFF\" }\n     //  or: {   \"red\": RR,\n     //          \"green\": GG,\n     //          \"blue\": BB    }\n     //  Transforms to RRGGBB0000FFFF\n     //  required by humidifier led\n     \n      var o ;\n     if (typeof value === 'string') {\n          o = JSON.parse(value);\n     } else {\n        o=value;  \n     }\n     if ((o.hex !== undefined) && (typeof o.hex === 'string') && (o.hex.length == 14))\n           return (o.hex);\n     var buf = Buffer.alloc(7);\n      buf.writeUInt8(o.red, 0);\n      buf.writeUInt8(o.green,  1);\n      buf.writeUInt8(o.blue,  2);\n      buf.writeUInt16BE(0,  3);\n      buf.writeUInt16BE(0xFFFF,  5);\n      return buf.toString('hex');\n    }\n\n\n};\n// -------------------------------------------------- do not change\n// local functions:\n\n// find ObjDevicem, using o.name or o.id, from a device[]: local, only used by _getObjDevice())\n// otherwise return undefined.\nfunction _checkobj(list, dx) {\n   var o;\n   if (list == undefined)\n      return o;\n   o = list.find(device => device.name === dx);\n   if (o === undefined)\n      o = list.find(device => device.id == dx);\n   if (o === undefined)\n      o = list.find(device => device.cid == dx);\n   return (o);\n}\n// get ObjDevice, from name|id, no limits or only real|virtual|fake\n// otherwise return undefined.\nfunction _getObjDevice(dname, limit = null) {\n   function okcheck(lim, branch) {\n      return ((lim === null) || (lim == branch))\n   }\n\n   var odev;\n   var alld = global.get(\"alldevices\");\n   if (dname === undefined)\n      return (odev);\n   if (okcheck(limit, \"real\"))\n      odev = _checkobj(alld.real, dname);\n   if ((odev == undefined) && okcheck(limit, \"virtual\"))\n      odev = _checkobj(alld.virtual, dname);\n   if ((odev == undefined) && okcheck(limit, \"fake\"))\n      odev = _checkobj(alld.fake, dname);\n   return (odev);\n}\n\n//  returns name/cid/id from odev\nfunction getdevname(odev) {\n   return (odev.name === undefined ? (odev.cid == undefined ? odev.id : odev.cid) : odev.name);\n}\n\n// gets real/gateway name, from  device object\nfunction _getconnectname(odev) {\n   if (_isreal(odev))\n      return (getdevname(odev));\n   var o_gat = _getObjDevice(odev.gateway, \"real\");\n   return (getdevname(o_gat));\n}\n\n// true if device is a real device (virtual == cid exists)\nfunction _isreal(odev) {\n   return (odev.cid === undefined);\n}\n\n//true if device is a fake existing device\nfunction _isfake(dname) {\n   return (_getObjDevice(dname, \"fake\") !== undefined);\n}\n\n// returns deviceId (real) or cid (virtual), never fails\nfunction _getID(odev) {\n   if (_isreal(odev))\n      return (odev.id);\n   return (odev.cid);\n}\n\n// true if is a GET command  (GET == msg.value not exists)\nfunction _isget(mx) {\n   return (mx.payload.value === undefined);\n}\n\n// true if is a SET command  (SET == msg.value  exists)\nfunction _isset(mx) {\n   return  ((mx.payload.property !== undefined) && (mx.payload.value !== undefined));\n}\n\n// returns now(), formatted for mySQL, never fails\nfunction _mySQLdatetime() {\n   //datetime format for mySQL: '2020-12-18 20:45:02'\n   // using 'sv' for date format (but local timezone)\n   return (new Date().toLocaleString('sv'));\n}\n\nfunction formatData(data){\n    var clean = JSON.stringify(data);\n    if (clean[0] ==='\"')\n       clean= clean.substring(1).slice(0,-1);\n    return clean;\n}\n\n\n\n// ---------------------  main function\n// Builds IN messages (commands SET/GET) for devices.\n// updates the DB\n// format: see 'IN  commands' link node.\n\nvar req = {};\nvar warn = null;\nvar query = {};\n\n//\nvar o = _getObjDevice(msg.payload.device);\nif (o === undefined) {\n   node.warn(\"ERROR: add to alldevices the device: '\" + msg.payload.device + \"'\");\n   return [null, null, null, null];\n}\n\nif (_isfake(msg.payload.device)){\n   msg.to = o.id;\n   return [null, msg, null, null];\n   }\n\n// test connected == false?\nvar nx = _getconnectname(o);\nif (nx !== undefined) {\n   var tuyastatus = global.get(\"tuyastatus\")\n      if ((tuyastatus !== undefined) && (tuyastatus[nx] !== undefined) && (tuyastatus[nx][\"_connected\"] === false)) {\n         node.warn(\"Operation not performed: '\" + getdevname(o) + \"' is not connected.\");\n         return ([null, null, null, null]);\n      }\n} else {\n   node.warn(\"ERROR: add to 'alldevices' the gateway '\" + o.gateway + \"' (used by '\" + getdevname(o) + \"')\");\n   return [null, null, null, null];\n}\n\n//          \"comment01\":\"optional 'capability' for devices:[ one or more of 'SET','GET','SCHEMA','MULTIPLE', NONE','ALL'] (default SET)\",\nvar cap;\nif (o.capability != undefined)\n   cap = Array.from(o.capability);\n//  ( \"GET\",\"SET\",\"SCHEMA\") | \"NONE\" | \"ALL\"\nif ((cap === undefined) || (cap.length < 1))\n   cap = [\"ALL\"]; // the default is ALL\n\nreq.payload = {};\nif (_isreal(o)) {\n   // if it is real\n   req.to = o.id;\n} else {\n   // if it is virtual\n   req.payload.devId = o.cid; // uses cid for virtual devices\n   req.to = o.gateway;\n}\n\nreq.topic = \"msg for \" + msg.payload.device;\n\nif (cap.includes(\"NONE\") || cap.includes(\"none\")) {\n   node.warn(\"GET/SET operations not allowed because the '\" + getdevname(o) + \"' is not accessible by user.\");\n   return [null, null, null, null];\n}\nif (_isget(msg)) {\n   req.payload.operation = \"GET\";\n\n   if (msg.payload.property === undefined) // is get schema\n      if (cap.includes(\"SCHEMA\") || cap.includes(\"ALL\") || cap.includes(\"schema\") || cap.includes(\"all\")) {\n         req.payload.schema = true;\n         query.topic = \" INSERT INTO `messages` (`timestamp`, `action`,`device-id`, `device-name`, `dps`, `dp-name` )\";\n         query.topic += \" VALUES ('\" + _mySQLdatetime() + \"','TX', '\" + _getID(o) + \"', '\" + getdevname(o).replace(/'/g, \"\\\\'\") + \"','SCHEMA','SCHEMA') ;\";\n         query[\"payload\"] = {\n            deviceId: _getID(o)\n         };\n         return ([req, null, {\n                  payload: \"TX: SCHEMA from '\" + getdevname(o) + \"'\",\n                  to: req.to\n               }, query]);\n      } else {\n         node.warn(\"SCHEMA GET not allowed by the '\" + getdevname(o) + \"'\");\n         return [null, null, null, null];\n      }\n\n   if (!(cap.includes(\"GET\") || cap.includes(\"ALL\") || cap.includes(\"get\") || cap.includes(\"all\"))) {\n      node.warn(\"GET commands not allowed by the '\" + getdevname(o) + \"'\");\n      return [null, null, null, null];\n   }\n}\n\nif (_isset(msg)) {\n   if (msg.payload.property.toUpperCase() === \"MULTIPLE\")\n      if (cap.includes(\"MULTIPLE\") || cap.includes(\"ALL\") || cap.includes(\"multiple\") || cap.includes(\"all\")) {\n         req.payload.multiple = true;\n         req.payload.data = msg.payload.value;\n         // todo: bd query for multiple  set\n         query.topic = \" INSERT INTO `messages` (`timestamp`, `action`,`device-id`, `device-name`, `dps`, `dp-name`, `data`)\";\n         query.topic += \" VALUES ('\" + _mySQLdatetime() + \"','TX', '\" + _getID(o) + \"', '\" + getdevname(o).replace(/'/g, \"\\\\'\") + \"','MULTIPLE','MULTIPLE', '\" + JSON.stringify(msg.payload.value) + \"') ;\";\n         query[\"payload\"] = {\n            deviceId: _getID(o)\n         };\n         return ([req, null, {\n                  payload: [\"TX MULTIPLE: to '\" + getdevname(o) + \"'\", msg.payload.value ],\n                  to: req.to\n               }, query]);\n      } else {\n         node.warn(\"MULTIPLE SET not allowed by the '\" + getdevname(o) + \"'\");\n         return [null, null, null, null];\n      }\n   if (!(cap.includes(\"SET\") || cap.includes(\"ALL\") || cap.includes(\"set\") || cap.includes(\"all\"))) {\n      node.warn(\"SET commands not allowed by the '\" + getdevname(o) + \"'\");\n      return [null, null, null, null];\n   }\n}\n\n// common\nvar p;\nif (Array.isArray(o.dps)) {\n   p = o.dps.find(data => data.name == msg.payload.property); // msg.payload.property is name ?\n   if (p === undefined)\n      p = o.dps.find(data => data.dp == msg.payload.property); // is number, or string ?\n}\n// not found or o.dps don't exists\nif (p === undefined) { // not found\n   node.warn(\"In alldevices add to '\" + getdevname(o) + \"' the data point: '\" + msg.payload.property + \"'\");\n   p = {\n      dp: \"none\"\n   }; //fallback\n   p.dp = msg.payload.property;\n}\n// \"comment02\":\"optional 'capability' for dps, one of: 'RO' |'WO' |'RW' |'PUSH' (default WO)\",\nvar capp = (((p === undefined) || (p.capability === undefined)) ? \"RW\" : p.capability);\nswitch (capp.toUpperCase()) {\ncase \"PUSH\":\n   node.warn(\"Can not SET/GET the PUSH value of '\" + getdevname(o) + '\".\"' + msg.payload.property + \"'\");\n   return [null, null, null, null];\ncase \"RO\":\n   if (_isset(msg)) {\n      node.warn(\"Can not SET the Read Only value of '\" + getdevname(o) + '\".\"' + msg.payload.property + \"'\");\n      return [null, null, null, null];\n   }\n   break;\ncase \"WO\":\n   if (_isget(msg)) {\n      node.warn(\"Can not GET the Write Only value of '\" + getdevname(o) + '\".\"' + msg.payload.property + \"'\");\n      return [null, null, null, null];\n   }\n   break;\ncase \"TRG\":\n   node.warn(\"Reserved: '\" + getdevname(o) + '\".\"' + msg.payload.property + \"' is used with TRIGGER\");\n   return [null, null, null, null];\n}\nreq.payload.dps = p.dp.toString();\n// data encoding\nif (_isset(msg)) {\n   if (p.typefield === undefined)\n      req.payload.set = msg.payload.value;\n   else {\n      if (dataencode[p.typefield] === undefined) {\n         node.warn(\"Not found the encode.['\" + p.typefield + \"'] function() required by \" + getdevname(o) + '\".\"' + msg.payload.property + \"': data unchanged.\");\n         req.payload.set = msg.payload.value;\n      } else{\n         req.payload.set = dataencode[p.typefield](msg.payload.value);\n      }\n   }\n}\n// outputs: tuya/fake/info/db\n\n// builds the DB  log\nquery.topic = \" INSERT INTO `messages` (`timestamp`, `action`, `device-id`, `device-name`, `dps`, `dp-name`, `data`, `value`) \";\nquery.topic += \" VALUES ('\" + _mySQLdatetime() + \"', 'TX' , '\" + _getID(o) + \"', '\" + getdevname(o).replace(/'/g, \"\\\\'\") + \"','\" + req.payload.dps + \"', '\" + msg.payload.property.replace(/'/g, \"\\\\'\") + \"', \" + (_isset(msg) ? \"'\" + formatData(req.payload.set) + \"'\" : \"NULL\") + \", \" + (_isset(msg) ? \"'\" + formatData(msg.payload.value) + \"'\" : \"NULL\") + \" );\";\n\n// the warning message\nif (_isset(msg))\n   warn = {\n      payload: [\"TX SET: '\" + getdevname(o) + \"'/'\" + msg.payload.property + \"'\", msg.payload.value ],\n      to: req.to\n   };\nelse\n   warn = {\n      payload: \"TX GET:'\" + getdevname(o) + \"'/'\" + msg.payload.property + \"'\",\n      to: req.to\n   };\nreturn ([req, null, warn, query]);\n","outputs":4,"noerr":0,"initialize":"","finalize":"","x":390,"y":240,"wires":[["1a9b7af5.924e85","5777b120.3dc3e"],["18817677.061b9a"],["4244626d.05ecbc"],["70d88fb4.7fcc2"]]},{"id":"2ec83963.a7d146","type":"link out","z":"173260fb.d021ff","name":"","links":["9fe80f7e.f3f7e"],"x":1135,"y":200,"wires":[],"icon":"font-awesome/fa-expand"},{"id":"d4a32280.a4dc8","type":"switch","z":"173260fb.d021ff","name":"*real device selector","property":"to","propertyType":"msg","rules":[{"t":"eq","v":"b12373b1b789b5123cro7p","vt":"str"},{"t":"eq","v":"123 85573d8bfc05123e6","vt":"str"},{"t":"eq","v":"<more device id>","vt":"str"},{"t":"eq","v":"bfa123aa196ae5975cy123","vt":"str"}],"checkall":"true","repair":false,"outputs":4,"x":640,"y":120,"wires":[["dfd320c0.b4f74"],["5c8eb6e4.500348"],[],["305e7686.63b0fa"]]},{"id":"8a1da02d.424ae","type":"link in","z":"173260fb.d021ff","name":"IN  commands","links":["2abb8b42.fb0014","4ba246d3.ce8678","12833e9c.41dce1","bb0a853c.789078","b9bfe83e.88b628","25e4f27d.911f4e"],"x":170,"y":240,"wires":[["c991322e.a484e"]],"l":true,"info":"Unique entry point for commands from application flows.\n\nFor a great incapsulation, external application flows can use only `usr-device-name`, `usr-property-name` and `usr-decoded-data`, as defined in global.alldevices. (see `tuyaDAEMON.'format command'` node and `global.alldevices,(real|virtual)[dname][pname].typefield`)).\n\n\n`msg.payload` for **SET** command (sends a new value to a device: usually the device stores it and sends back the modified value):\n````\n    {\n        \"device\": \"tuya_bridge\",    // sr-device-name  (accepts also id|cid, only  for test), case-sensitive\n        \"property\": \"on reset\",     //  usr-propery-name (accepts also dps value, only for test), case-sensitive\n           \"value\": \"ON\"            //  user-value, as required by encode()\n    }\n````\n\n`msg.payload` for **GET** command (refresh a parameter in **global.tuyastatus** asking the actual value from a device):\n````\n    {\n        \"device\": \"tuya_bridge\",  //  usr-device-name  (accepts also id|cid, only  for test), case-sensitive\n        \"property\": \"on reset\",     //  usr-propery-name (accepts also dps value, only for test), case-sensitive\n    }\n````\n`msg.payload` for **GET schema** command (massive refresh of **global.tuyastatus** from a device):\n````\n    {\n        \"device\": \"tuya_bridge\",        //  usr-device-name  (accepts also id|cid, only  for test). case-sensitive\n    }\n````\n\n`msg.payload` for **SET multiple** command (_deprecated because uses dps index and coded data_):\n````\n    {\n        \"device\": \"tuya_bridge\",            //  usr-device-name  (accepts also id|cid, only  for test). case-sensitive\n      \"property\": \"MULTIPLE\",               // reserved name\n         \"value\":  {\"1\":true, \"101\":\"100\"}  //  object, unprocessed, as required by device\n    }\n````\n\n**Commands handling**\n\n- In general, **tuyaDEAMON CORE** send ALL commands for real and virtual devices.\n- The commands for _fake devices_ are available from a _link OUT node_, so thet can be processed by related fake_commands **node-red** modules.\n\n\n"},{"id":"cff32cc3.68b48","type":"comment","z":"173260fb.d021ff","name":"OUT msg process","info":"_tuyaDAEMON process chain for messages coming from all device._\n\nInput: msg from any `smart-tuya-device` node or internally generated.\n\nOuput: \n  - the global.tuyastatus object is updated.\n  - a log of every received data is stored in the 'messages' DB table.\n  - info, trace and warning messages are output on the debug pad.\n  \nThe user can control the info and trace messages and select the stored records.","x":390,"y":640,"wires":[]},{"id":"305e7686.63b0fa","type":"link out","z":"173260fb.d021ff","name":"to bridge device","links":["69321d9a.30b7d4"],"x":675,"y":220,"wires":[],"icon":"font-awesome/fa-expand"},{"id":"baf09713.494098","type":"comment","z":"173260fb.d021ff","name":"Add a new smart device - 1","info":"**Howto: add a new device to tuyaDAEMON - 1 flow**\n\n_Step by step guide._\n\n_Preconditions:_\n\n- Your device MUST work in _smartLife_ app.\n- You must know the **device ID** and the **device Key** of your new device.\n  See 'Tuyapi' for a guide [https://github.com/codetheweb/tuyapi/blob/master/docs/SETUP.md](https://github.com/codetheweb/tuyapi/blob/master/docs/SETUP.md).\n - I suggest to download _tuyapi_ and _tuyapi-cli_ [https://github.com/TuyaAPI/cli](https://github.com/TuyaAPI/cli) and use the _tuyapi-cli_ in _'wizard' mode_: you will get the complete list of IDs and keys of all your devices (but not the cid, see later).\n- On **node-red**, install last version of _'node-red-contrib-tuya-smart-device'_ module, the simple way is using `'Menage palette'` on main **node-red** menu.\n--------------------------\n_Step 1:  tuyaDAEMON flow modifications_\n\n1.1 \n - Add (or copy) a new `tuya-smart-device` node.\n - Set new node _properties_:  `device id`, `device key` and `device name` (the name can be any, it is not used by tuyaDEAMON).\n \n1.2\n - edit the properties of the existing _switch node_ `'*real device selector'`: \n - add a new rule:  `msg.to == device id` for a new output.\n \n1.3\n - link the new output of the `switch node` to input node of the `tuya-smart-device` \n\n1.4\n - Select and duplicate the couple of nodes: `'spy status'` and `'connect'` (`connect` is a subflow, you can also find it in _palette:subflows_)\n - Config `'spy status'` property _'Report status from'_ choosing on list only the new `tuya-smart-device` node.\n - Config the `'connect'` property _'deviceId'_ using the device id.\n - Connect the output of  `'connect'` with the input of _'filter and upadate'_ function node.\n \nnote: the nodes having an asterisk on name (e.g. *real device selector) CAN/MUST be modified by the user to add devices or for fine tune tuyaDEAMON.\n-------------------\n_This complete the required flow modifications. Continue with_ **Step 2**.\n","x":990,"y":260,"wires":[]},{"id":"1a9b7af5.924e85","type":"debug","z":"173260fb.d021ff","d":true,"name":"trace:  msg IN for tuya devices","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":650,"y":420,"wires":[]},{"id":"bc933c53.b4bd9","type":"debug","z":"173260fb.d021ff","d":true,"name":"trace: msg OUT from tuya devices","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":640,"y":460,"wires":[]},{"id":"5c8eb6e4.500348","type":"tuya-smart-device","z":"173260fb.d021ff","deviceName":"here your device#2","deviceId":"56123573d8bfc05123e6","deviceKey":"a878db123c1b1234","x":990,"y":140,"wires":[["2ec83963.a7d146"]],"info":"**tuya_ms_104**   \n\n_tuya bridge for \"WiFi Smart Switch Module MS-104\"_\n\nAfter any command, this device sends (and this node captures) a 'status' message carring only the changed values.\n\nA command can be send by node-red, SmartLife app, Google home, Google voice: in any case this node captures the status message.\n\n_note:_\n If node-red changes the switch state, SmartLife is updated correctly, but Google Home not.\n \n_Input:_\nTo send a command via node-red. the payload structure must be:\n` multiple: true\n  data: object\n    1: true\n    102: 5`\n\n_nb:_\nset **Device Virtual ID** and **Device Key** to a tuya connected and working switch, model M-104 ( see [https://it.aliexpress.com/wholesale?SearchText=smart+switch+ms+104](https://it.aliexpress.com/wholesale?SearchText=smart+switch+ms+104))."},{"id":"b25c688d.705df8","type":"link in","z":"173260fb.d021ff","name":"low level IN","links":["bf37eb00.512bf8","c7359038.1f24e"],"x":190,"y":120,"wires":[["1a9b7af5.924e85","5777b120.3dc3e"]],"l":true,"info":"Low level entry point, payload is send directly to `tuya-smart-device` node.\nFor test, extensions etc.\n\nIN device messages (commands):\n \n SET single\n ````\n      {\n      \"to\":\"60a823fffeb5b90d\",  // tuyaDAEMON extrension: deviceID/gatewayID\n      \"payload\": {\n      // virtual devices, add cid:    \"devId\": \"60a453fffeb1b908\",\n          \"dps\":103,\n          \"set\":220  // BOOLEAN, INT/ENUM, STRING      \n          }\n      }\n````\n SET multiple\n````\n      {\n      \"to\":\"60a823fffeb5b90d\",  // tuyaDAEMON extrension: deviceID/gatewayID\n      \"payload\": {\n      // virtual devices, add cid:    \"devId\": \"60a453fffeb1b908\",\n          \"multiple\":true,\n          \"data\": {\n             103:220  // dps:value \n             }\n          }\n      }\n````\n\n GET single\n````\n      {\n      \"to\":\"60a823fffeb5b90d\",  // tuyaDAEMON extrension: deviceID/gatewayID\n      \"payload\": {\n    // virtual devices, add cid:    \"devId\": \"60a453fffeb1b908\",\n          \"operation\":\"GET\",\n          \"dps\":103\n          }\n      }\n````\nGET schema\n````\n      {\n      \"to\":\"60a823fffeb5b90d\",  // tuyaDAEMON extrension: deviceID/gatewayID\n      \"payload\": {\n    // virtual devices, add cid:    \"devId\": \"60a453fffeb1b908\",\n          \"operation\":\"GET\",\n          \"schema\"=true\n          }\n      }\n````\n \n"},{"id":"e25f8186.a5e4d","type":"comment","z":"173260fb.d021ff","name":"global alldevices","info":"**'global.alldevice': a DB implemented as JSON tree object for fast access.**\n\n_The goal of `'global.alldevice'` structure is to store in a unique place all information required by tuyaDAEMON to get a full insulation layer from the tuya communication details and to have a safe preventive control on allowed operations._\n\nThis data structure must be user-maintained, containing info on all connected tuya devices.\n\n_Some tuyaDAEMON definitions:_\n\n - A `real device` is a tuya device standard, WiFi and AC-powered (i.e. permanently connected to WiFi), compatible with the _smart-tuya-device_ node.\n \n - A `virtual device` is a tuya device accessible from a _smart-tuya-device_ node that connects not directly the device, but a `gateway` (eg  Zigbee Gateway), shared by many virtual devices.\n \n - A `fake device` is a real or artificial device, not handled by  _smart-tuya-device_ nodes, but maintained by some ad hoc **node-red** modules. All fake devices uses` global.tuyastatus` and the `DB 'message' table` to share values. \n    Some fake devices:\n\n    -  `'mirror' devices`: are tuya devices existing in _smartlife_, but for some reason not found using the _smart-tuya-device_ node, e.g. a battery-powered WiFi sensor.  _These devices can send/receive status and events to/from _node-red_ using `TRIGGERS`, via automation in _tuya-cloud_. See **tuyaTRIGGERS** flow, e.g. WiFi PIR motion sensor, IR TV remotes etc. To keep the **tuyaDAEMON** light, we will implement this not in an extended manner, but only on real exigences basis._\n    \n    -  `'abstract' devices`, handled by  **tuyaDEAMON** evtensions. Example: SYSTEM, that reports some parameters abut the tuyaDEAMEN run.\n    \n    - `custom devices`, using any private protocol of communication, whith dedicated node-red flows doing the required transformations.\n      \n\n---------------\n\n**JSON alldevices structure: device examples**\n\n````\nFor real devices (minimal):\n           {\n\t\t(1)    \"id\": \"123301602cf4325eae00\",  \n\t    (2)    \"name\": \"umidificatore\",\n\t           \"dps\": [\n    \t\t\t\t{\n    \t(3)         \"dp\": 1,\n        (2)         \"name\": \"spray\",\n    \t\t\t\t}\n\t\t\t   ]\n           }\n           \nFor virtual devices (minimal)    \n// accesed using gateway and cid:\n          {\n\t    (1)    \"id\": \"123910468caab5e75887\",\n\t\t(4)    \"cid\": \"1233acfffe526223\",\n\t\t(5)    \"gateway\": \"123093b1b788b5992cro7p\",\n\t    (2)    \"name\": \"umidificatore\",\n\t           \"dps\": [\n\t\t\t\t   {\n\t\t(3)        \"dp\": 1,\n        (2)        \"name\": \"spray\",\n\t\t\t\t   }\n\t\t\t   ]\n           }\n  \nFor mirror devices (fake)\n//  handled by tuyaTRIGGER, never accessed by user.  \n           {\n\t\t(1)     \"id\": \"123710408caab5e79887\",\n\t\t(2) \t\"name\": \"Sensore di movimento\",\n\t\t        \"dps\": [\n\t\t\t    \t{\n\t\t(10)        \"dp\": 1010,\n\t\t\t\t\t\"name\": \"Alarm\",\n\t\t\t\t    }\n\t\t\t]\n\t\t}\n  \nFor system (fake)\n\n// handled by tuyaDEAMON extensions: some GET/SET can be defined using capabilities\n\t\t{\n\t\t(9)    \"id\": \"_system\",\n\t\t(9)    \"name\": \"HAL at home\",\n\t\t\t   \"dps\": [\n\t\t\t     \t{\n\t\t(10)\t\t\"dp\": \"_laststart\",\n\t\t(10)         \"name\": \"start\"\n\t\t\t\t    },\n\t\t\t\t    {\n\t\t(10)\t\t\"dp\": \"_ACpower\"\n\t\t\t\t    }\n\t\t\t\t]\n\t\t}\n````\t\t \n           \nRich optional structure (for core, system):\n           \n````\n\t   {\n\t\t(1)     \"id\": \"123301602cf4325eae00\",  \n\t    (2)     \"name\": \"umidificatore\",\n\t\t(7) \t\"capability\": [\"SET\",\"SCHEMA\"],\n\t\t(11)    \"power\":\"AC\",\n\t            \"dps\": [\n\t\t\t\t{\n\t\t(3)       \"dp\": 1,\n                  \"name\": \"spray\",\n\t    (12)      \"typefield\": \"BOOLEANONOFF\"\n\t\t\t    },\n\t\t\t\t{\n\t\t\t      \"dp\": 6,\n\t\t\t\t  \"name\": \"led mode\",\n\t\t(13)      \"capability\": \"WO\",\n\t\t(6)       \"comment\": \"as string, values: 'coulour','colourful1' \"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n````\n**notes**\n\n1) the `deviceId`, as found using `tuya-cli wizard`, mandatory, used by CORE.\n2) friendly names, user defined, used by public `IN commands` and on `tuyastatus`. Optional but strongly recommended, used by CORE. Any langage, utf8. If missed, `id` or `dp` are used instead.\n3) real `dp`: you can find it in `messages` from the device (status change after a command  by _smartlife_), mandatory, used by CORE.\n4) `cid` index: only for virtual devices, you can find it in `messages` from the device (status change after a command  by _smartlife_), mandatory, used by CORE.\n5) `gateway` id, only for `virtual devices`, mandatory, used by CORE.\n6) `free comment`, allowed in any place, for private use. For multiline comments use 'comment01',  'comment02'.., optional.\n7) `device capability`, to filter the user commands. Array [ one or more of (`'SET'`,`'GET'`,`'SCHEMA'`,`'MULTIPLE'`) or `'NONE'` or `'ALL'`], optional (default ['ALL']), used by CORE to filter user commands.\n9) a `fake device` can use any `id`. Conventions: \n    - `'mirror' devices`: uses the id reported by  using `tuya-cli wizard` (unique but useless).\n    - `'abstract' devices`: uses a string starting with underscore (\"_system\")  defined in code.\n10)  a `fake device` can use any `dp`. Conventions:\n    - `'mirror' devices`: equal to TUYATRG number (I chose 1000-1999),  used  by **tuyaTRIGGERS** extension, defined in code so cannot be changed. \n    - `'abstract' devices`: uses a string starting with underscore (\"_system\"),  defined in code.\n11) classifies `real devices` using the type of power supply, values `'BAT'` | `'AC'` | `'UPS'`, optional (default 'BAT'), used by SYSTEM. '`UPS`' must be used used also for AC power with buffer battery or power bank.\nIf '`power`' miss, the device is NOT used in connections statistics done by _SYSTEM_ device (see).\n12) identifies the `decode()` and `encode()` functions used to convert data from/to devices. Values are user defined in `'format command'` and `'OUT data process'` nodes (see), optional (default 'no convertion'), used by CORE.\n13) single `dp` capability, to filter the user commands, one of `'RO'|'WO'|'RW'|'PUSH'!'TRG'`, optional (default 'RW'), used by _CORE_ and by _tuyaTRIGGERS_ flow to filter user commands (`'PUSH'` == none:  only passive update from device,`'TRG'`== none: same but via TRIGGER).\n\n_note:_ This structure is expandible addittive: if some custom extension requres infos on device/dp basis, that information can be added to `alldevices`, provided that the pre-existing definitions are not changed.\n\n","x":180,"y":380,"wires":[]},{"id":"619df12c.348e4","type":"status","z":"173260fb.d021ff","name":"spy status","scope":["dfd320c0.b4f74"],"x":1260,"y":80,"wires":[["5426b54d.99298c"]]},{"id":"5315ca5b.4b7f94","type":"status","z":"173260fb.d021ff","name":"spy status","scope":["63177140.66f71","5c8eb6e4.500348"],"x":1260,"y":140,"wires":[["c6d3a5bb.1fa638"]]},{"id":"7330cf81.3a32d","type":"comment","z":"173260fb.d021ff","name":"_system DEVICE MONITOR","info":"Connection monitor\n\nThis nodes handle the `\"_connected\"` property in global.tuyastatus, added to all real devices only.\n\n- This property can be used by your applications, and it is used by the `'system'` fake device, to produce _ALARM events_.\n\n- If you don't are interest about `'system'` and `\"_connected\"` you can disable/delete this tuyaDAEMON section.","x":1320,"y":380,"wires":[]},{"id":"5426b54d.99298c","type":"subflow:ee953c15.ada29","z":"173260fb.d021ff","name":"","env":[{"name":"deviceId","value":"bfb123b1b789b59a1223o7p","type":"str"},{"name":"deviceID","value":"bfb073b1b789b5994cro7p","type":"str"}],"x":1430,"y":80,"wires":[["81103bac.696bc8"]]},{"id":"c6d3a5bb.1fa638","type":"subflow:ee953c15.ada29","z":"173260fb.d021ff","name":"","env":[{"name":"deviceId","value":"56685573d8bfc05082e6","type":"str"},{"name":"deviceID","value":"56685573d8bfc05082e6","type":"str"}],"x":1430,"y":140,"wires":[["81103bac.696bc8"]]},{"id":"d62f5a18.fe10b8","type":"debug","z":"173260fb.d021ff","name":"RX  info","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":720,"y":500,"wires":[]},{"id":"4244626d.05ecbc","type":"debug","z":"173260fb.d021ff","name":"TX info","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":720,"y":380,"wires":[]},{"id":"154e84b8.8c7b0b","type":"comment","z":"173260fb.d021ff","name":"Debug pad options","info":"**Disable unwonted trace and info messages on debug pad.**\n\n - Disable unwonted debug nodes.\n  \n - To filter only some info messages, modify the the code in function node: _'info message filter'_ \n\n - To reduce the records sended to DB, edit the code in function nodes: _'*TX DB messages filter'_  and _'*RX DB messages filter'_\n \n - Warn messages are alway sended.\n \n If you like to get a better run, as a temporary solution, you can do some modifications to the tuyapi ver 5.3.1 code, as advised in [issue#389](https://github.com/codetheweb/tuyapi/issues/389)  \n \n","x":910,"y":460,"wires":[]},{"id":"4170e71.70b8518","type":"file","z":"173260fb.d021ff","name":"","filename":"alldevices.json","appendNewline":false,"createDir":false,"overwriteFile":"true","encoding":"utf8","x":360,"y":500,"wires":[[]]},{"id":"7a540832.656648","type":"inject","z":"173260fb.d021ff","name":"SAVE ","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"$globalContext(\"alldevices\")\t","payloadType":"jsonata","x":170,"y":500,"wires":[["4170e71.70b8518"]]},{"id":"81a9b329.092b1","type":"link out","z":"173260fb.d021ff","name":"low level OUT","links":["a9aac6e5.70f988"],"x":640,"y":720,"wires":[],"l":true,"info":"Low level output, all messages as sended by devices.\n\nThe messages are unprocessed, directly from `tuya-smart-device` node. \n\n_Used by_:  `tuyaTRIGGERS.'event trigger'` node\n\n_See also_: `'to logging'` input link node for the OUT msg structure.\n\nOUT msg structures:\n\nexample: msg (real)\n ````\n        {\n        _msgid: \"12342f3fd.8697fc\"\n        _event: \"node:12343963.a7d846\"\n        payload: object\n           deviceId: \"123455aa196ae5975cy6ii\"\n           deviceName: \"*tuya_bridge\" \n           data: object\n              t: 1609234903  // timestamp, in seconds.\n              dps: object\n                 102: 1020   // array of dp:value\n        }\n```` \n\nexample msg: (virtual)\n````\n        {\n        _msgid: \"12346a44.e81238\"\n        payload: object\n           deviceId: \"123473b1b789b4994cro7p\"\n           deviceName: \"Zigbee Gateway\"\n           data: object\n              cid: \"12348d00856a1c15\"\n              t: 1609235292\n              dps: object\n                 102: 1020   // array of dp:value\n        }             \n````\n"},{"id":"d22f53a4.c54b9","type":"inject","z":"173260fb.d021ff","name":"auto","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":"9","topic":"","payload":"","payloadType":"date","x":195,"y":920,"wires":[["2a358b0d.e48944"]],"icon":"node-red/trigger.svg","l":false},{"id":"2a358b0d.e48944","type":"function","z":"173260fb.d021ff","name":"start timestamp","func":"\n\n// ==================================================== general use functions, here as reposity\n\n// get ObjDevice, from name|id|cid, in  alldevices  or only in real|virtual|fake\n// otherwise return undefined.\nfunction _getObjDevice(key, limit = null) {\n    // find ObjDevice, using o.name or o.id or o.cid, from a device[] (i.e.  real|virtual|fake)\n    // otherwise return undefined.\n    function _checkobj(list, dx) {\n       var o;\n       if (list == undefined)\n          return o;\n       o = list.find(device => device.name === dx);\n       if (o === undefined)\n          o = list.find(device => device.id === dx);\n       if (o === undefined)\n          o = list.find(device => device.cid === dx);\n      return (o);\n    }\n   //  local test\n   function okcheck(lim, branch) {\n      return ((lim === null) || (lim === branch))\n   }\n   var odev;\n   var alld = global.get(\"alldevices\");\n   if (key === undefined)\n      return (odev);\n   if (okcheck(limit, \"real\"))\n      odev = _checkobj(alld.real, key);\n   if ((odev === undefined) && okcheck(limit, \"virtual\"))\n      odev = _checkobj(alld.virtual, key);\n   if ((odev === undefined) && okcheck(limit, \"fake\"))\n      odev = _checkobj(alld.fake, key);\n   return (odev);\n}\n\n//true if device (name|id|cid), is a fake existing device\nfunction _isfake(dvid) {\n   return (_getObjDevice(dvid, \"fake\") !== undefined);\n}\n\n// ====== odev access\n\n// get the Device name (fallback id, 'undefined'), from Odev,  never fails\n function _getOdevUsrName(odev){\n  if  (odev!== undefined) return(odev.name === undefined?odev.id:odev.name );\n  return (\"undefined\");   \n }\n \n//   get the Device name (fallback id) from key (name|id|cid)\n function _getDevUsrName(key){\n  return (getOdevUsrName( _getObjDevice(key)));   \n }\n\n\n// ==============================  to handle devices out msg\n// true if device is a real device (virtual := cid exists)\n// input msg\n// true if related device is a real/fake device (virtual := cid exists)\nfunction _isReal(mx) {\n   return (mx.payload.data.cid === undefined);\n}\n// input msg\n// true if related device is a real/fake device (virtual := cid exists)\nfunction _isVirtual(mx) {\n   return (mx.payload.data.cid !== undefined);\n}\n\n// from OUT msg, get the device object in alldevices, if it don't exist return undefined + warn\nfunction _getodevice(mx) {\n   var odev;\n   if (_isreal(mx)) {\n      odev = _getObjDevice(mx.payload.deviceId, \"real\");\n      if (odev === undefined) {\n         odev = _getObjDevice(mx.payload.deviceId, \"fake\");\n      }\n      if (odev === undefined) {\n         node.warn(\"ERROR: ADD to alldevices the real/fake deviceid: \" + mx.payload.deviceId + \" (\" + mx.payload.deviceName + \")\");\n      }\n   } else {\n      odev = _getObjDevice(mx.payload.data.cid, \"virtual\");\n      if (odev === undefined) {\n         node.warn(\"ERROR: ADD to alldevices the virtual device cid: \" + mx.payload.data.cid + \" [gateway: \" + mx.payload.deviceId + \"]\");\n      }\n   }\n   return (o);\n}\n\n// from OUT msg, returns device name or id or  \"undefined\"\nfunction _getName(mx) {\n   var odev = _getodevice(mx);\n   if (odev!== undefined)\n      return (odev.name === undefined ? odev.id : odev.name);\n   return (\"undefined\");\n}\n\n// ===========================  more:\n\n// local functions, using previous\n\n function getSysObj(alldevices){\n return   alldevices.fake.find(device => device.id === \"_system\");\n }\n \n function getSysUsrName(odev){\n  if  (odev!== undefined) return(odev.name);\n  return (\"_system\");   \n }\n\n// =======================  main\n\n// local function to iniect in \"to logging\"\nfunction _sendSys(key,value){\n// builds a fake OUT message \nvar newMsg = { \"payload\":{\n      \"deviceId\": \"_system\",\n      \"data\": {\n         \"dps\":{\n              [key]:value\n          }}}};\nreturn newMsg;  \n}\n\n//  timestamp in s (like data.t)\nfunction _getNowSecTimestamp(){\n    return Math.floor(Date.now() / 1000);\n}\n\n// returns data.t or now(), formatted for mySQL, never fails\nfunction _mySQLdatetime(mx = null) {\n   //datetime format for mySQL: '2020-12-18 20:45:02'\n   // using 'sv' for date format and local timezone\n   if ((mx == null) || (mx.payload.data.t === undefined))\n      return (new Date().toLocaleString('sv'));\n   return (new Date(Number(mx.payload.data.t) * 1000).toLocaleString('sv'));\n}\n\nreturn  _sendSys(\"_laststart\", _mySQLdatetime());\n\n","outputs":1,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is deployed.\n\n// initializes tuyastatus._system\n function getSysObj(alldevices){\n return   alldevices.fake.find(device => device.id === \"_system\");\n }\n \n function getDevUsrName(odev){\n  if  (odev !== undefined) return(odev.name);\n  return (odev.id);   \n }\n\n\nfunction getDpUsrName(dpx,odev){\n  if  ((odev !== undefined) && (Array.isArray(odev.dps))){\n      var dpo = odev.dps.find(dpnt => dpnt.dp === dpx);\n      if ((dpo !== undefined) && (dpo.name !== undefined)) \n         return (dpo.name);\n  }\n  return (dpx);   \n }\n\nvar tuyastatus = global.get(\"tuyastatus\");\nif (tuyastatus == undefined)\n        tuyastatus = {};\nvar osys = getSysObj(global.get(\"alldevices\"));\nvar sysUsrName = getDevUsrName(osys);\nif (tuyastatus[sysUsrName] == undefined)\n        tuyastatus[sysUsrName] = {};\nvar startUsrName = getDpUsrName(\"_laststart\",osys);\ntuyastatus[sysUsrName][startUsrName] = null ; \nglobal.set(\"tuyastatus\", tuyastatus);\n \n\n","finalize":"","x":340,"y":920,"wires":[["db455c46.e4ac7"]],"info":"A message at the end of initial setup time (on my PC 7-8s). ready."},{"id":"db455c46.e4ac7","type":"link out","z":"173260fb.d021ff","name":"","links":["9fe80f7e.f3f7e","b3a9c8c0.d9a348"],"x":475,"y":920,"wires":[],"icon":"font-awesome/fa-expand"},{"id":"a6a98ae5.79e068","type":"comment","z":"173260fb.d021ff","name":"_system FAKE DEVICE","info":"**SYSTEM is a fake device** \n\nI.e `_system` is a device handled by tuyaDAEMON, and offerts a centralized information point about tuyaDAEMON and devices status.\n\n**The device _system_ is with fallowing capabilities:**\n\ndefined in _tuyaDAEMON_:\n - **_start**: \"2020-12-31 17:56:01\"|null, _the tuyaDAEMON local start time. For the first 8 seconds it is null, to signal the node-red startup._\n - **_ACpower**: true, _if some AC-powerd devices are connected._\n     false, _if all AC powered device are disconnected_\n - **_WiFinet**: true, _if some WiFi devices (not battery-powered) are connected._\n    false, _if all WiFi device are disconnected_\n - **_LANnet**: true, _if a remote server (http://nodered.org) is reachable_\n    false, _otherwise._\n - **_ACunconnected**: array[x], _List of  AC-powered disconnected devices. When == all, the AC ALARM is send._\n - **_WiFiunconnected**: array[x],  _List of WiFi (AC and UPS) disconnected devices. When == all and ACpower == true the WIFI ALARM is send._\n\ndefined in _tuyaTRIGGER_:\n - **_trgPing**: object { count, avg, max, min}, the tuya cloud trigger timing, Do this test in a quiet moment.\n  \nFor users convenice, `system` also present some LINK:\n - **connection event**  _fired every device status change, logged_\n - **AC ALARM**: _sends a msg every change of ACpower_.\n - **WIFI ALARM**: _sends a msg every change of WiFinet, if ACpower is true._\n - **LAN ALARM**: _sends a msg every change of LANnet_.\n \nIn `global.tuyastatus` we can found, using also tuyaTRIGGER, a `_system` object like this:\n````\n    HAL at home: object\n       start: \"2021-01-08 09:32:08\"\n       _ACpower: true\n       _ACunconnected: array[2]\n           0: \"umidificatore\"\n           1: \"Smart IR 3\"\n       _LANnet: true\n       _WiFinet: true\n       _WiFiunconnected: array[2]\n           0: \"umidificatore\"\n           1: \"Smart IR 3\"\n       _trgPing: object\n           count: 4\n           avg: 213\n           max: 260\n           min: 171\n````    \nAnd for any 'real' device (example):           \n\n````\n    Smart IR 1: object\n      _connected: true\n````\n\nnote:  `'system'` is built as an addon: if your application doesn't need those resources, you can disable/delete all _'system' nodes_. Connection events will no longer be processed.","x":260,"y":840,"wires":[]},{"id":"68e9ad9d.b12ed4","type":"link in","z":"173260fb.d021ff","name":"auto start","links":["edf84736.d76338"],"x":595,"y":880,"wires":[["d652405b.b153b"]],"icon":"font-awesome/fa-expand"},{"id":"eaf3e0e8.2c619","type":"function","z":"173260fb.d021ff","name":"WiFi check","func":"\n// ceck  devices  AC and  AC + battery ('UPS'): all unconnected => WiFi down\n\n// ===================================== do not change\nvar CONN  = \"_connected\";    //  dps = CONN, same as name, see also sub-flow \"connected\" function\nvar PWIFI =\"_WiFinet\";\nvar PAC   =\"_ACpower\";\nvar ULST  = \"_WiFiunconnected\";\nvar alldevices;\nvar tuyastatus;\nvar count = 0;\nvar tot = 0;\nvar arraybad = [];\n\nfunction _sendOUT(value, list){\n// builds an artificial OUT message \nvar newMsg = { \"payload\":{\n      \"deviceId\": \"_system\",\n      \"data\": {\n          \"dps\":{\n              [PWIFI]:value,\n              [ULST]: list\n          }}}};\nreturn newMsg;  \n}\n\n\nfunction _checkWIFI(o) {\n if ((o.power === undefined) || (o.power === 'BAT')) return;\n if (tuyastatus[o.name] === undefined) return\n if (tuyastatus[o.name][CONN] === undefined) return;\n \n tot++;\n if (tuyastatus[o.name][CONN]){\n     count++;\n } else {\n      arraybad.push(o.name);\n      }\n }\n \n \n \n function getDpName(o, dpx){\n    if ((o !== undefined) && Array.isArray(o.dps)){\n        p = o.dps.find(data => data.dp == dpx);\n        if ((p !== undefined) && (p.name !== undefined)) return p.name;\n        }\n  return dpx;       \n  }\n \n\n function getSysObj(alldevices){\n return   alldevices.fake.find(device => device.id === \"_system\");\n }\n \n function getSysUsrName(o){\n  if  (o !== undefined) return(o.name);\n  return (\"_system\");   \n }\n\n//  ----------------  main\n    alldevices = global.get(\"alldevices\");\n    if (alldevices === undefined) return null;\nvar o =  getSysObj(alldevices);  \nvar fakedevice = getSysUsrName(o);\n    tuyastatus = global.get(\"tuyastatus\");\n    if (tuyastatus === undefined) return null;\n    // init\n    var usrWIFI = getDpName(o, PWIFI);\n    var oldlist = flow.get(ULST);\n    count = 0;\n    tot = 0;\n    \n    // testing: \n    alldevices.real.forEach(element => _checkWIFI(element));\n    flow.set(ULST, arraybad);\n\n    // function outputs:    \n    if (tot < 1) {\n        node.status({fill:\"yellow\",shape:\"dot\",text:\"WiFi devices not found\"});\n        return null;\n       }\n       \n    var sendnew  = (tuyastatus[fakedevice] === undefined) \n         || (tuyastatus[fakedevice][usrWIFI] === undefined) \n         || ( JSON.stringify(oldlist) !== JSON.stringify(arraybad));\n    \n    node.status({fill:(count ==0?\"red\":\"green\"),shape:\"ring\",text:\"WiFi devices ON: \"+count+\"/\"+tot});\n    var nmsg =  _sendOUT((count > 0), JSON.stringify(arraybad));\n    \n     // return(update, alarm)\n    if ( sendnew && (tuyastatus[fakedevice] != undefined) && (tuyastatus[fakedevice][usrWIFI] === (count == 0)))\n        return [nmsg, nmsg];\n    if ( sendnew )\n        return [nmsg, null];\n    return [null, null];\n   \n","outputs":2,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is deployed.\nnode.status({fill:\"yellow\",shape:\"dot\",text:\"OK\"});\nflow.set(\"WiFiunconnected\", [\"new\"]);","finalize":"","x":1210,"y":940,"wires":[["68d21677.32a9c8"],["9eef7e3e.15a96"]]},{"id":"482cde4d.4c944","type":"delay","z":"173260fb.d021ff","name":"","pauseType":"delay","timeout":"2","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":760,"y":940,"wires":[["eaf3e0e8.2c619","1029af2.b1d2451"]]},{"id":"a8d66c9a.4c12b","type":"http request","z":"173260fb.d021ff","name":"Nodered site get","method":"GET","ret":"txt","paytoqs":"ignore","url":"http://nodered.org","tls":"","persist":false,"proxy":"","authType":"","x":1020,"y":1000,"wires":[["ba7ba473.a1dfe8"]]},{"id":"ba7ba473.a1dfe8","type":"function","z":"173260fb.d021ff","name":"LAN check","func":"PLAN = \"_LANnet\";\n\nfunction _sendOUT(key,value){\n// builds a fake OUT message \nvar newMsg = { \"payload\":{\n      \"deviceId\": \"_system\",\n      \"data\": {\n          \"dps\":{\n              [key]:value\n          }}}};\nreturn newMsg;  \n}\n\n function getSysObj(alldevices){\n return   alldevices.fake.find(device => device.id === \"_system\");\n }\n \n function getSysUsrName(o){\n  if  (o !== undefined) return(o.name);\n  return (\"_system\");   \n }\n\n\n//  ----------------  main\nvar alldevices = global.get(\"alldevices\");\n    if (alldevices === undefined) return null;\nvar fakedevice = getSysUsrName(getSysObj(alldevices));\n\nvar  tuyastatus = global.get(\"tuyastatus\");\n    if (tuyastatus === undefined) return null;\n\n// this test must be updated in case of node-red home page change\nif(msg.payload.indexOf('is a programming tool for wiring') !== -1) {\n    node.status({fill:\"green\",shape:\"ring\",text:\"LAN connected\"});\n// node.warn([\"LAN check OK: \", tuyastatus[fakedevice]]);\n    if (tuyastatus[fakedevice][PLAN] !== true)     \n        return ( _sendOUT(PLAN, true));\n} else {\n    node.status({fill:\"red\",shape:\"ring\",text:\"LAN disconnected\"});\n// node.warn([\"LAN check BAD: \", tuyastatus[fakedevice]]);\n    if (tuyastatus[fakedevice][PLAN] !== false)\n       return ( _sendOUT(PLAN, false));\n}\nreturn null;\n\n","outputs":1,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is deployed.\n \n function getFakeDevObj(alldevices, idx){\n return   alldevices.fake.find(device => device.id === idx);\n }\n \n function getDeviceName(o){\n  if  (o !== undefined) return(o.name);\n  return (\"_system\");   \n }\n\nPLAN = \"_LANnet\";\n node.status({fill:\"green\",shape:\"ring\",text:\"OK\"});\n var tuyastatus = global.get(\"tuyastatus\");\n if (tuyastatus === undefined) \n      tuyastatus = {};\n var fakedevice = getDeviceName( getFakeDevObj(global.get(\"alldevices\"), \"_system\"));\n if (tuyastatus[fakedevice] === undefined) \n     tuyastatus[fakedevice] = {};\n // default\n tuyastatus[fakedevice][PLAN] = null;     \n global.set(\"tuyastatus\", tuyastatus);\n","finalize":"","x":1210,"y":1000,"wires":[["f9994459.243578","68d21677.32a9c8"]]},{"id":"68d21677.32a9c8","type":"link out","z":"173260fb.d021ff","name":"","links":["9fe80f7e.f3f7e"],"x":1395,"y":860,"wires":[],"icon":"font-awesome/fa-expand"},{"id":"e266674.29c2098","type":"function","z":"173260fb.d021ff","name":"ACpower check","func":"// devices AC powered + no batteries: all off => AC power down\n\n// ===================================== do not change\nvar CONN = \"_connected\";    //  dps = CONN, same as name, see also sub-flow \"connected\" function\nvar PAC =\"_ACpower\";\nvar ULST = \"_ACunconnected\";\n//\nvar alldevices;\nvar tuyastatus;\nvar count = 0;\nvar tot = 0;\nvar arraybad = [];\n\nfunction _sendOUT(value, list){\n// builds an artificial OUT message \nvar newMsg = { \"payload\":{\n      \"deviceId\": \"_system\",\n      \"data\": {\n          \"dps\":{\n              [PAC]:value,\n              [ULST]: list\n          }}}};\nreturn newMsg;  \n}\n\n\nfunction _checkAC(o) {\n if ((o.power === undefined) || (o.power !== 'AC')) return;\n if (tuyastatus[o.name] === undefined) return\n if (tuyastatus[o.name][CONN] === undefined) return;\n \n tot++;\n if (tuyastatus[o.name][CONN]){\n     count++;\n } else {\n      arraybad.push(o.name);\n      }\n }\n \n \n function getFakeDevObj(alldevices, idx){\n return   alldevices.fake.find(device => device.id === idx);\n }\n \n function getDeviceName(o , basen){\n  if  (o !== undefined) return(o.name === undefined? basen:o.name);\n  return (basen);   \n }\n\n function getDpName(o, dpx){\n    if ((o !== undefined) && Array.isArray(o.dps)){\n        p = o.dps.find(data => data.dp == dpx);\n        if ((p !== undefined) && (p.name !== undefined)) return p.name;\n        }\n  return dpx;       \n  }\n \n\n// ---------------- main\n//  if (flow.get(\"start\") == null) return 0;\n   \n// stuff to access data\n    alldevices = global.get(\"alldevices\");\n    if (alldevices === undefined) return null;\n    tuyastatus = global.get(\"tuyastatus\");\n    if (tuyastatus === undefined) return null;\n    // init\n    var o = getFakeDevObj(alldevices, \"_system\");\n    var fakedevice = getDeviceName(o, \"_system\");\n    var usrPAC = getDpName(o, PAC);\n    var oldlist = flow.get(\"ACunconnected\");\n    count = 0;\n    tot = 0;\n    \n    // testing: \n    alldevices.real.forEach(element => _checkAC(element));\n    flow.set(\"ACunconnected\", arraybad);\n\n    // function outputs:    \n    if (tot < 1) {\n        node.status({fill:\"yellow\",shape:\"dot\",text:\"AC devices not found\"});\n        return null;\n       }\n       \n    var sendnew  = (tuyastatus[fakedevice] === undefined) \n         || (tuyastatus[fakedevice][usrPAC] === undefined) \n         || ( JSON.stringify(oldlist) !== JSON.stringify(arraybad));\n    \n    node.status({fill:(count ==0?\"red\":\"green\"),shape:\"ring\",text:\"AC devices ON: \"+count+\"/\"+tot});\n    var nmsg =  _sendOUT((count > 0), JSON.stringify(arraybad));\n    \n     // return(update, alarm)\n    if ( sendnew && (tuyastatus[fakedevice] != undefined) && (tuyastatus[fakedevice][usrPAC] === (count == 0)))\n        return [nmsg, nmsg];\n    if ( sendnew )\n        return [nmsg, null];\n    return [null, null];\n   \n  \n  ","outputs":2,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is deployed.\n// Code added here will be run once\n// whenever the node is deployed.\nnode.status({fill:\"yellow\",shape:\"dot\",text:\"OK\"});\nflow.set(\"ACunconnected\", [\"new\"]);","finalize":"","x":1220,"y":880,"wires":[["68d21677.32a9c8"],["58cf0889.35af68"]]},{"id":"d652405b.b153b","type":"delay","z":"173260fb.d021ff","name":"","pauseType":"delay","timeout":"2","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":760,"y":880,"wires":[["482cde4d.4c944","e266674.29c2098"]]},{"id":"9eef7e3e.15a96","type":"link out","z":"173260fb.d021ff","name":"WIFI ALARM","links":[],"x":1510,"y":940,"wires":[],"l":true,"info":"TRIGGER for custom flows.\n\nFired at any change."},{"id":"58cf0889.35af68","type":"link out","z":"173260fb.d021ff","name":"AC ALARM","links":[],"x":1510,"y":880,"wires":[],"l":true,"info":"TRIGGER for custom flows.\n\nFired at any change."},{"id":"f9994459.243578","type":"link out","z":"173260fb.d021ff","name":"LAN ALARM","links":[],"x":1510,"y":1000,"wires":[],"l":true,"info":"TRIGGER for custom flows.\n\nFired at any change."},{"id":"f9a629eb.f4f498","type":"comment","z":"173260fb.d021ff","name":"tuyaDAEMON CORE","info":"\n## **TuyaDAEMON project**\n\n\n_A two-way bridge between Tuya-cloud and node-red for custom extensions of Tuya ecosystem._\n\nTuyaDAEMON isolates your **custom node-red flows** from all details of tuya/node-red data and commands exchanges:\n- allows bidirectional exchanges to/from _all tuya devices and Tuya automations_.\n- decodes and transforms incominig Tuya data  to _standard units_.\n- manages all codifications and checks before sending your _commands to Tuya cloud_.\n- updates the `global.tuyastatus` structure (_device:property:value_) with _status messages from all Tuya devices_.\n- logs all events in the mySQL` 'tuyathome:messages'` table \n- uses _frendly names_ for all devices and properties, in any language\n**INPUT**\n\n  Only one public entry point, for user (SET/GET/SCHEMA/MULTIPLE) commands, the _'IN commands link'_ node (see). Command (SET) example:\n  ````\n  {  \"device\":\"USB siren\",\n     \"property\":\"alarm\",\n     \"value\":\"ON\"   }\n  ````\n  \n _note:_ tuyaDEAMON _makes the_ GET _and_ SCHEMA _commands practically superfluous. Their meaning becomes \"update now `global.tuyastatus`\"_.\n\n**OUTPUT**\n\n  none: a client flow CAN get device data polling the `global.tuyastatus` structure, RT updated or CAN get historical data from the `messages` DB table.\n  \n\n_User can define:_\n- TUYA TRIGGERS from _smartlife scene/event/alarm_ to fire custom _node-red flows_\n- RED TRIGGERS from _node-red_ to fire _smartlife automations_.\n\nMany internal I/O connections are available for private use and for tuyaDAEMON extensions.\n  \n\n**IMPLEMENTATION**\n\n To interact with _Tuya devices_ I chose [`node-red-contrib-tuya-smart-device`](https://github.com/vinodsr/node-red-contrib-tuya-smart-device), which uses [tuyapi](https://github.com/codetheweb/tuyapi), the most interesting software on **tuya<=>node-red** integration that I have found.\n They do their job well, but there are some limitations:\n \n 1) Some devices are unreachables: **TuyAPI** does not support some sensors due to the fact that they only connect to the network when their state changes. Usually are WiFi devices battery-powered.\n \n 2)The implementation of the Tuya protocol is very variable for different devices: e.g. I have found very few devices that respond to `schema` requests.\n \n 3) _Tuya devices_ can update  their own firmware version via **OTA**: for the user, this is an investment guarantee, but it can introduce problems when the software (`tuyapi` and `tuya-smart-device`) is not updated: some device messages can't be decoded.\n \n 4) Tuyapi sometimes finds an error message from devices: `\"json obj data unvalid\"`: the source of this is not clear (see [issue # 246](https://github.com/codetheweb/tuyapi/issues/246)), but the best interpretation is \"_the required operation is not available_\".\n \n 5) **Tuyapi** throws some errors at the moment not caught by **tuya-smart-device**: `\"Error: Error from socket\"` and `\"find () timeout. Is the device turned on and the correct ID or IP?\"`.\n Because now a **tuya-smart-device** can't be disabled, these useless messages can be very frequent. In normal use, some devices can stay disconnected long time, such as power sockets or power strips used only on request.\n\n \n _To manage such a rapidly changing environment, I choose to use a data structure in **tuyaDAEMON** to describe individual devices and single datapoint capabilities, so that all operations that are actually not managed or bogous can be intercepted and not sent to the devices, giving stable and reliable operations with no surprises. And if the evolution of the SW offers us new features, it is easy to update the behavior of tuyaDAEMON._\n \n  _A smart workaround, implemented in **tuyaTRIGGER** module, allows the bidirectional event communication also with all devices unreachables by `tuyapi`._ _**The user is guaranteed that in all cases all tuya devices will be integrated with tuyaDAEMON.**_\n  \n  \n**Customization**\n\n **TuyaDAEMON** is very sperimental, the CORE module MUST be modified by user for every new device. \n \n _Any effort is made to make it modular, small, easy to modify and fully documented.\n All contributions and criticisms are welcome._ \n \n \n In **tuyaDAEMON** we have now four modules:\n - **tuyaDEAMON CORE:** the main flow, for communication with many tuya `'real' devices`, and also with devices using a _gateway_ (`'virtual' devices`) e.g. Zigbee sensors.\n - **Connection module:** add to all _real device_ the new RT property 'connected' to report device status. Optional.\n - **System module:** Offerts a `'fake' device` (_system) with some useful RT properties: _Alarms_ in case of WiFi, Lan or AC power down, _list of unconned devices_ etc. Optional, requires the  _'Connection module'_.\n - **tuyaTRIGGER module,** _give us some important features:_\n   - The start of **tuya automations** from _node-red_\n   - The ability to fire **node-red flows** from _smartlife_, enabling _node-red remote and vocal control_.\n   - The management RT of `'mirror' devices` for all devices not caught by **tuyapi**\n   \n    This module, optional, uses a smart trick on a partially dedicated HW device.\n- _Extra flow_: \"siren mirror\", a 'mirror' device study case.\n- _Extra flow_: \"test devices\" with some examples of device tests\n \n**Configuration**\n\nIn addition to usual configuration requirements for the nodes `mySQL` and `tuya-smart-device`:\n     \n1) _CORE_ includes `global.alldevices`, a big JSON structure with all required information on `real/virtual/fake` devices, that control the _CORE_ behavior on device/dps basis. Any new device must be added to it. To update/modify/edit this structure:\n    - you can edit it directly using the _'alldevices'_ config node.\n    - you can export it to the file `alldevices.json` for backup or to edit it using external editors (e.g. _Notepad++_ and _'JSON Viewer'_ plugin) and back with cut-paste.\n    - Soon an application can produce an `'alldevice'` scheletron starting from a _DB of tuya device definitions_.\n    - For detailed definitions see _global alldevices_ comment node\n    \n    \n2) To reduce the workload in the production environment:\n     - `debug` nodes can control the _debug pad_ content: enabling/disabling them the user can modulate the visible information.\n     - `filters` can reduce the info and the DB writing charge. \n     - see _'Debug pad options'_ comment node.\n     \n\n--------------------\n**Versions**\n\n_tuyaDAEMON version 1.0_ (15/01/2021)\n- node-red-contrib-tuya-smart-device 2.0.0\n- tuyapi ver. 6.1.1\n\nInitial version     ","x":200,"y":40,"wires":[]},{"id":"b8260773.399138","type":"comment","z":"173260fb.d021ff","name":"Add a new smart device - 2","info":"**Howto: add a new device to tuyaDAEMON - Step 2**\n\n\n\nTo add a new device, after the addition of _reqired nodes to flow_, you must update the ``global.alldevices`` structure. See `'global.alldevices'` comment for reference.\n\nIn this guide you will build the requered structure slowly, driven by tuyaDAEMON info messages and _smartlife_.\n\n2.0 \n  Eliminate/disable all not used/not configured `smart_tuta_devices` nodes or you will have many error messages.\n\n2.1\n  - tuyaDAEMON is running, all _info_ and _trace_ debug nodes are enabled. \n  - Clear the debug pad.\n  - Using _smartlife_ send a simple command to the new device.\n  - In the debug pad you must see:\n````\n    26/12/2020, 20:09:39node: updates global.tuyastatus, formats SQL'`\n      function : (warn)`\n        \"ADD to alldevices the real deviceid: 12345678987654321abc\"`\n````\nor: \n````\n        \"ADD to alldevices the virtual device cid: 1234567321abc [gateway:12345678987654321abc]  `\n````\n - Edit the node _'Config'_ and open `alldevice`.\n    Don't delete the actual data (you can delete example devices later).\n    For real devices add to  `alldevice` some like this, using the rigth values, in the 'real' branch:\n ````\n    {\n        \"id\": \"12345678987654321abc\",\n        \"name\": \"<new-device-name>\"\n    },\n````\n    For virtual devices (i.e. using a gateway: the 'gateway' itself must be present in the real section), add in the 'virtual' branch:\n```` \n    {\n        \"id\": \"12345678987654321abc\"\n        \"cid\": \"bcdef9876543\"\n        \"gateway\": \"987654321012346789ab\"\n        \"name\": \"<new-device-name>\"\n    },\n````\n Where: \n   -    `'gateway'` is the id of the associate _gateway real device_. \n   -    `'cid'` is the _id_ used by the gateway.  \n   -    `'Id'` is the _device id_ you get doing \"`tuya-cli wizard`\".\n   -    `'new-device-name'` any, in any language, also with spaces. This will be the public device name.\n \n - That is minimal, but enough for now.\n   Make attention to commas, use [format ISON] to check your data. \n - Save. Deploy.\n\n2.2\n - Resend a command using _smartlife_, in the debug pad you will see:\n ````\n \"In alldevices missed the '<new-device-name>':dps[<dp-x>] definition.\"`\n```` \n  - Now you know a  `dps` (<dp-x> = 1, or 2, or 101... ), associated to the command sended via _smartlife_.\n  -  You must edit again the node 'Config' and open `alldevice`: edit the list, you must add some like this:\n  ````\n    { \n        \"id\": \"12345678987654321abc\",\n        \"name\": \"<new-device-name>\"\n        \"dps\": [\n            {`\n                \"dp\": <dp-x>,\n                \"name\": \"<new-x-value-name>\"\n            },\n            {`\n                \"dp\": <dp-y>,\n                \"name\": \"<new-y-value-name>\"\n            }\n        ]\n    },\n  ````\n - For 'new-x-value-name' it is better to use same name used in _smartlife_, if it exist. Use `'unknow'` for data point on study phase. \n - Save, deploy.\n - Resend same command using _smartlife_, in the debug pad you will see some like:\n ````  \n    27/12/2020, 13:02:09node: updates global.tuyastatus, formats SQL\n       function : (warn)\n        \"STATUS: '<new-device-name>'/'<new-value-name>' = 7\"\n ````\nThis is the standard info from **tuyaDAEMON**. Done.\n\n2.3\n - You can explore further, doing the same with all _smartlife_ commands for your device.\n   You must keep calm: I found some _thermostatic radiator valves_ with 28 data points... Keep running **tuyaDAEMON** 24h then collect all the records with 'undefined' or 'unknow' from DB: you can find new hidden data points.\n\n - The value you get can be more complicated than '7' or 'colour': maybe it is _coded_.\n    - Some decode functions are in \"_updates global.tuyastatus, formats SQL_\" node.\n    - Or you can write your `decode()` and `encode()` functions for a new `typefield`, and place it on top of \"_updates global.tuyastatus, formats SQL_\" and \"_format command_\" function nodes.\n    -  Share your new functions... :)\n    - Some tests are required to re-engeenering the codification used: useful is the little flow 'TEST UNKNOW RESPONSES' in `'TEST DEVICE'`: you can test if data are binary and coded using _'code64'_.\n    - Example of binary data coded _'code64'_, the _temperature day planning_ (typefield: `STRUCTARGETTEMP` )\n```` \n    data: BAAAAKABpADIA94A0gTsAKU=   [base64(Uint8Array[17])]\n    \n    decoded, JSON: \n            {\n               \"count\":4,\n               \"changes\":[\n                    {\"time\":\"00:00\",\"temp\":16},\n                    {\"time\":\"07:00\",\"temp\":20},\n                    {\"time\":\"16:30\",\"temp\":21},\n                    {\"time\":\"21:00\",\"temp\":16.5}\n                ]\n            }\n````\n\n - Found the correct decode function, you can update 'alldevice' like so:\n````    \n        {\n            \"dp\": 103,\n            \"name\": \"target Temperature\",\n            \"typefield\": BYTESMALLFLOAT\"  \n        }\n````\n   `BYTESMALLFLOAT` transforms a byte like `8FH = 143` to a _decimal temperature_ value: `\"14.3\"`  \n\n\n- Else, if you unlucky, you can get some like this:\n````  \n    function : (warn)`\n        \"ERROR from <new device name>: data hex:332e330019001efbfb  (3.3\u0019\u0001��)\"\n````      \n That minds an internal problem: _tuyapi_ library as failed the data decoding to a JSON standard structure. \n You can not Read or Write this device. Signal the problem in github [_'tuyapi'_](https://github.com/codetheweb/tuyapi), and wait for a new release.\n      \n_Conclusions:_\n\n Testing the device commands with _smartlife_ you can get:\n\n * a) a 'standard' JSON structure: unique problem can be the _data decoding_.\n \n * b) an ERROR: \"`.. not JSON data but 'json obj data unvalid'...`\": rare using _smartlife_, but common testing with _node-red_. It minds \"operation not allowed\" on dps basis.\n \n * c) an ERROR \"`...not JSON data but HEX:...`\" on device basis.\n \n_Strategies:_\n   - The case (b) usually is about 'GET' and 'SCHEMA' commands, and a **tuyaDEAMON** user don't need really it: the `global.tuyastatus` structure stores all last infomations from devices.\n   - Case (c) you can't use (at the moment) the _smart_tuya_device_ with tis device. But you can use **any device in tuyaDAEMON**, getting/setting all relevant events using the **tuyaTRIGGER** mirrowing (see **tuyaTIGGER** flow). \n      \n2.4 more **capabilities**\n \n- On a **device**, to filter only the allowed requests, can be added the _\"capability\"_ value: Array [ one or more of `('SET','GET','SCHEMA'.'MULTIPLE')|'NONE'|'ALL'`] (default `ALL`)\n- You can classify **real devices** using the type of power supply, values `'BAT'` | `'AC'` | `'UPS'`.\n    That is optional (default 'BAT') and used by `system` device.\n- On single **dps**, you can also add a _\"capability\"_: String, one of: `'RO' |'WO' |'RW' |'PUSH'|'TRG'` (default `RW`)\n     (`PUSH:` the value is send autonomously by the device. `TRG:` the value is read/write only using TRIGGERS, not directly.\n\n2.5 notes\n - We can also add to `alldevice` some `commentxx` values, to remember important things about a device or single dps: limits, meanning etc... For private use.\n\n- Usually, when a value is changed by _smartlife_ or _node-red_, the new status is send back by the device. Becose the global structure `tuyastatus` keeps trace of all last values, we don't need really the GET operation.\n\n  \n - The `SAVE` input node triggers the creation of the file `'alldevices.json'` in the working directory of the Node-RED process.\n You can use it as beckup. You can edit it using _Notepad++_ and the _'JSON Viewer'_ plugin.\n \n ","x":990,"y":300,"wires":[]},{"id":"4b5500aa.235f7","type":"inject","z":"173260fb.d021ff","name":"CECK NOW","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":510,"y":1000,"wires":[["d652405b.b153b"]]},{"id":"81103bac.696bc8","type":"function","z":"173260fb.d021ff","name":"filter and upadate","func":"\nvar tuyastatus   =  global.get(\"tuyastatus\");\nvar xdev =  tuyastatus[msg.payload.deviceName];\nif (xdev === undefined) return null;\n// testing:\nvar oldconnected =  xdev._connected;\nvar nowconnected =  msg.payload.data.dps._connected\n// node.warn(\"test: connected \" +dev.name+\" new: \"+nowconnected+\" old: \"+oldconnected );\n// filters only real connection change events. \nif (nowconnected !== oldconnected) {\n    xdev._connected = nowconnected;\n    global.set(\"tuyastatus\", tuyastatus);   \n    return(msg);\n}  \n\nreturn null;\n\n\n\n\n\n","outputs":1,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is deployed.\nvar tuyastatus   =  global.get(\"tuyastatus\");\n","finalize":"","x":1670,"y":300,"wires":[["edf84736.d76338"]]},{"id":"2caa595d.2a0106","type":"function","z":"173260fb.d021ff","name":"*Info messages filter","func":"// kills unwanted tuyaDEAMON info messages \n// -----------------------------------------\n// add test as required, use only the payload string.\n//\n// filter example: \n// kills all TRIGGERS messages (see tuyaTRIGGER)\n// payload: \"RX STATUS: 'tuya_bridge'/'reserved (trigger)' = 0\"\n if(msg.payload[0].startsWith(\"RX: 'tuya_bridge'/'reserved\"))\n         return(null);\n         \n//  more....\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":880,"y":580,"wires":[["d62f5a18.fe10b8"]],"info":"On installation and test:\n  Best don't filer any message.\nOn production:\n  Better to filter not useful events.\n  _________________________________\n  \n See the example filter:\n Test can be done on \n     ` msg.payload.deviceId         for real devices\n       msg.payload.data.dps[<dpx>]  for specific events`\n  \n   "},{"id":"c90b7eb2.07595","type":"link in","z":"173260fb.d021ff","name":"from more connected","links":["63e6d5d.0a5da2c"],"x":1495,"y":440,"wires":[["81103bac.696bc8"]],"icon":"font-awesome/fa-expand"},{"id":"18817677.061b9a","type":"link out","z":"173260fb.d021ff","name":"fake cmds ","links":["3d5351ac.12b92e","85849e54.4b055","ed7caa46.78c218","369ab28b.348ebe"],"x":670,"y":280,"wires":[],"icon":"font-awesome/fa-expand","l":true,"info":"OUTPUT for commands to fake devices, unprocessed by tuiaDAEMON CORE.\n\nMessages are as sended (see `IN commands` node) plus\n   `msg.to = iDdevice`, added to speedup."},{"id":"70d88fb4.7fcc2","type":"function","z":"173260fb.d021ff","name":"*TX DB query filter","func":"// kills unwanted DB queries\n// -----------------------------------------\n// add test as required, use:\n// msg.payload.deviceId  (device|cid)\n// msg.topic = SQL query\n\n\n// if ( msg.payload.deviceId == \"system\") return null;\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":870,"y":640,"wires":[["1a711832.f93bb8"]],"info":"On installation and test:\n  Best don't filer any message.\nOn production:\n  Better to filter not useful events.\n  _________________________________\n  \n See the example filter:\n Test can be done on \n     ` msg.payload.deviceId         for real devices\n       msg.payload.data.dps[<dpx>]  for specific events`\n  \n   "},{"id":"edf84736.d76338","type":"link out","z":"173260fb.d021ff","name":"Connection events","links":["68e9ad9d.b12ed4","9fe80f7e.f3f7e"],"x":1730,"y":360,"wires":[],"l":true,"info":"TRIGGER internal/external.\n\nFired at any change of devices connection status.\nThis event is logged and fires an update of AC/LAN/AC properties in _system"},{"id":"85849e54.4b055","type":"link in","z":"173260fb.d021ff","name":"cmd IN","links":["18817677.061b9a"],"x":775,"y":820,"wires":[["39b988f0.76c6b8"]],"icon":"font-awesome/fa-expand"},{"id":"39b988f0.76c6b8","type":"function","z":"173260fb.d021ff","name":"pick and execute","func":"// Implementation of GET/SET/SCHEMA/MULTIPLE  commands \n// for 'abstract' device \"_system\"\n// accepts only GET: fires a data refresh.\n// absorb all msg.\n\n// --------------- locals\n// find Obj-Device, using dev-name or dev-id or dev-cid, from a device[] (i.e.  real[]|virtual[]|fake[])\n// limit == null (default): uses alldevices\n// if not found return undefined.-\n\nfunction _getObjDevice(key, limit = null) {\n    function _checkobj(list, dx) {\n       var o;\n       if (list == undefined)\n          return o;\n       o = list.find(device => device.name === dx);\n       if (o === undefined)\n          o = list.find(device => device.id === dx);\n       if (o === undefined)\n          o = list.find(device => device.cid === dx);\n      return (o);\n    }\n   function okcheck(lim, branch) {\n      return ((lim === null) || (lim === branch))\n   }\n   var odev;\n   var alld = global.get(\"alldevices\");\n   if (key === undefined)\n      return (odev);\n   if (okcheck(limit, \"real\"))\n      odev = _checkobj(alld.real, key);\n   if ((odev === undefined) && okcheck(limit, \"virtual\"))\n      odev = _checkobj(alld.virtual, key);\n   if ((odev === undefined) && okcheck(limit, \"fake\"))\n      odev = _checkobj(alld.fake, key);\n   return (odev);\n}\n\n//   get obj-dp from dp-name or dp-id, in obj-dev\n//   if not found return undefined.-\nfunction getOdevDpx(d,odev){\nvar dp ;\n  if  ((odev !== undefined) && (Array.isArray(odev.dps)))  {\n       dp = odev.dps.find(dpx => dpx.nome == d);\n    if (dp === undefined)\n        dp = odev.dps.find(dpx => dpx.dp == d);\n      }\n  return (dp);   \n }\n \nfunction _isGetCommand (idDev, msx) {\n return ((msx.to === idDev) && (msx.payload.property !== undefined) && (msx.payload.value === undefined));\n}\n\n// ------------- main\n//  partial implementation of _system GET (== 'update now globalstatus') for\n//  _LANnet, _ACpower, _ACunconnected, _WiFinet, _WiFiunconnected\n//  any output fires a flow that updates globalstatus\n\nif (_isGetCommand(\"_system\", msg)) {  // a GET\n// find dp\n    var dpx = getOdevDpx( msg.payload.property, _getObjDevice(\"_system\",\"fake\"));   \n// outputs: /AC/WiFi/Lan/\n    switch (dpx.dp){\n      case \"_ACpower\":\n      case \"_ACunconnected\":\n            return([msg,null, null]);\n      case \"_WiFinet\":\n      case \"_WiFiunconnected\":\n             return([null,msg, null]);\n      case \"_LANnet\":\n            return([null,null, msg]);\n   }\n// not found: no error.  More _system commands  can exist, in other flows\n}\nreturn([null,null, null]);\n","outputs":3,"noerr":0,"initialize":"","finalize":"","x":930,"y":820,"wires":[["e266674.29c2098"],["eaf3e0e8.2c619"],["a8d66c9a.4c12b"]]},{"id":"fe1a20ab.104ce","type":"delay","z":"173260fb.d021ff","name":"","pauseType":"rate","timeout":"5","timeoutUnits":"seconds","rate":"30","nbRateUnits":"10","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":420,"y":700,"wires":[["81a9b329.092b1","a878b58e.e4ea08","bc933c53.b4bd9"]]},{"id":"5777b120.3dc3e","type":"delay","z":"173260fb.d021ff","name":"","pauseType":"rate","timeout":"5","timeoutUnits":"seconds","rate":"20","nbRateUnits":"10","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":400,"y":120,"wires":[["d4a32280.a4dc8"]]},{"id":"1029af2.b1d2451","type":"trigger","z":"173260fb.d021ff","name":"","op1":"","op2":"ok","op1type":"nul","op2type":"str","duration":"2","extend":true,"overrideDelay":false,"units":"s","reset":"","bytopic":"all","topic":"topic","outputs":1,"x":760,"y":1000,"wires":[["a8d66c9a.4c12b"]]},{"id":"e16b895d.8992a8","type":"config","z":"173260fb.d021ff","name":"*alldevices","properties":[{"p":"alldevices","pt":"global","to":"{\"real\":[{\"id\":\"123073b1b789b599abco7p\",\"name\":\"Zigbee Gateway\",\"comment01\":\"send/receive messages to/from sub-devices (virtual)\",\"comment02\":\"example: you can remove\",\"power\":\"AC\"},{\"id\":\"b12345aa191235975cy6ii\",\"name\":\"tuya_bridge\",\"power\":\"AC\",\"comment\":\"HW used to implement TRIGGERS, required\",\"capability\":[\"SET\"],\"dps\":[{\"dp\":1,\"name\":\"switch\",\"typefield\":\"BOOLEANONOFF\",\"comment\":\"value: false|true\"},{\"dp\":101,\"name\":\"on reset\",\"typefield\":\"ENUMONOFFHOLD\",\"comment\":\"startup switch value: 0|1|2: OFF, ON, HOLD\"},{\"dp\":102,\"name\":\"reserved (trigger)\",\"capability\":\"TRG\",\"comment01\":\"value: 0..86400s (24H), SET to 0, switch don't change\",\"comment02\":\"when the countdown reaches 0, switch toggles\"}]},{\"id\":\"12385573d8bfc0501234\",\"name\":\"Smart IR 1\",\"power\":\"AC\",\"comment01\":\"example: you can remove\",\"comment02\":\"rare captures from tuya ? sub-devices not availables, use only with tuya automations\",\"dps\":[{\"dp\":1,\"name\":\"unknow\",\"comment\":\"mode? found push 'study_key' and 'send_ir'\",\"capability\":[\"PUSH\"]}]}],\"virtual\":[{\"name\":\"Temperature 2\",\"cid\":\"001234500056aaaa5\",\"gateway\":\"335565aa196ae5912abcde\",\"comment01\":\"Zigbee device\",\"comment02\":\"example: you can remove\",\"capability\":[\"NONE\"],\"dps\":[{\"dp\":103,\"name\":\"Temperatura\"},{\"dp\":101,\"name\":\"Umidità\"}]}],\"fake\":[{\"id\":\"_system\",\"name\":\"HAL@home\",\"comment\":\"fake device, for system status, required\",\"capability\":[\"NONE\"],\"dps\":[{\"dp\":\"_laststart\",\"name\":\"start\"},{\"dp\":\"_trgPing\"},{\"dp\":\"_ACpower\"},{\"dp\":\"_WiFinet\"},{\"dp\":\"_ACunconnected\"},{\"dp\":\"_WiFiunconnected\"},{\"dp\":\"_LANnet\"}]},{\"id\":\"12327807d8bfc0c51234e\",\"name\":\"USB siren\",\"comment01\":\"WiFi siren, disabled:HEX data, mirror\",\"comment02\":\"mirror device, example, you can remove\",\"power\":\"UPS\",\"capability\":[\"SET\",\"SCHEMA\"],\"dps\":[{\"dp\":\"1800\",\"name\":\"alarm\",\"comment\":\"values: ON|OFF, updated RT from device\",\"capability\":\"WO\"},{\"dp\":\"2820\",\"name\":\"setup\",\"comment\":\"values: alarm|(more todo), local update\",\"capability\":\"WO\"},{\"dp\":\"1820\",\"name\":\"battery\",\"comment\":\"values: OK(default)|LOW, PUSH 24H from device\",\"capability\":\"PUSH\"}]},{\"id\":\"12387827d8bfc0ddddaa5\",\"name\":\"Sensore porta\",\"comment\":\"WiFi battery sensor, mirror device\",\"comment02\":\"mirror device, example, you can remove\",\"power\":\"BAT\",\"capability\":[\"NONE\"],\"dps\":[{\"dp\":1030,\"name\":\"Open\",\"capability\":\"TRG\"}]}]}","tot":"json"}],"active":true,"x":210,"y":440,"wires":[],"info":"To add a new device, or for fine tune an existing one, you must rdit the global.alldevice JSON structure.\n\nFor format and details see '_global.alldevices_' and '_add a new device, step 3_'  comment nodes. "},{"id":"7e3077c8.ff8e88","type":"MySQLdatabase","name":"","host":"127.0.0.1","port":"3306","db":"tuyathome","tz":"","charset":"UTF8"}]