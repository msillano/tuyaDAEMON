[
    {
        "id": "f30e8140.1bed9",
        "type": "subflow",
        "name": "do command",
        "info": "This node creates a command for a device, i.e. the output can go to `core.std_cmds` or `core.fast_cmds` inputs.\n\nGeneral purpose, used to send tuyaDEAMON commands.\n\n### Parameters\n<dl class=\"message-properties\">\n    <dt>remote <span class=\"property-type\">string | @string | NULL</span> </dt>\n    <dd>   the tuyaDEAMON instance (as in _core.global.remotemap_) or NULL.\n        \n - Default: NULL => delete 'remote' (i.e. local)\n - uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n      - early binding:  a string, e.g. `foo`\n      - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.instance_name`\n      - evalued value: a string starting with '@', e.g. `@Date.now()`\n- runtime override: from `msg.command.remote` value\n\n </dd>\n    <dt>device <span class=\"property-type\">string | @string | NULL</span> </dt>\n    <dd>   the device user-name or `ID` or `CID` (as in _core.global.alldevices_).\n \n - Default: NULL => delete 'device'\n -  uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n     - early binding:  a string, e.g. `core`\n     - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.instance_name`\n     - evalued value: a string starting with '@', e.g. `@Date.now()`\n - runtime override: from `msg.command.device` value\n\n</dd>\n   <dt>property <span class=\"property-type\">string | @string | NULL</span> </dt>\n   <dd>   the data point ID or user.name (string: \"3\" or \"_version\")\n        \n - Default: NULL => delete 'property'\n -  uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n     - early binding:  a string, e.g. `_DBase`\n     - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.instance_name`\n     - evalued value: a string starting with '@', e.g. `@Date.now()`\n- runtime override: from `msg.command.property` value\n\n</dd>\n<dt>value<span class=\"property-type\">any | @string | NULL</span></dt>\n<dd>  the new value to send to the device (unencoded).\n        \n - Default: NULL => delete 'value' \n - uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n     - early binding: boolean | number | string | JSON object, as required by DP definition in `global.alldevices`\n     - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.instance_name`\n     - evalued value: a string starting with '@', e.g. `@Date.now()`\n- runtime override: from `msg.command.value` value\n\n</dd> </dl>\n\n### Input\n\n  Any, used only to provoke the output, but values like `msg.command.remote` can override the parameters.\n\n### Output\n\nA standard tuyaDAEMON msg command.\n\n### Details\n\nStandard message structure \n````\nobject\n     {\n        payload :{ \n            remote:   <remote>, \n            device:   <device>,\n            property: <property>,\n            value:    <value>\n        }}\n````\nrules:\n````\nif remote = NULL (or missed) => local instance.\nif device = NULL (or missed) and remote valid => GET remote device list\n   elseif property = NULL (or missed)  => GET device SCHEMA\n      elseif value = NULL (or missed)   =>   GET property\n         else  => SET property\n````\n###References\nFor command format, see `std_cmds` and `fast_cmds` nodes in 'CORE' flow.\n\n\n\n\n",
        "category": "",
        "in": [
            {
                "x": 120,
                "y": 60,
                "wires": [
                    {
                        "id": "cb536e9b3a81862a"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 600,
                "y": 60,
                "wires": [
                    {
                        "id": "cf230930.f37938",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "remote",
                "type": "str",
                "value": "NULL",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "device",
                "type": "str",
                "value": "core",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "property",
                "type": "str",
                "value": "version",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "value",
                "type": "str",
                "value": "NULL",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str",
                            "num",
                            "bool",
                            "json"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "cf230930.f37938",
        "type": "function",
        "z": "f30e8140.1bed9",
        "name": "make msg",
        "func": "\n// builds the object\n    var res = {\n        payload :{\n            remote:   flow.get(\"remote\"),\n            device:   flow.get(\"device\"),\n            property: flow.get(\"property\"),\n            value:    flow.get(\"value\")\n        }\n    }\n\n// processes NULL cases    \n    if ((!(res.payload.remote))||(res.payload.remote == 'NULL'))\n           delete (res.payload.remote)\n    \n     if (res.payload.device == \"NULL\"){\n          delete (res.payload.device);\n          delete (res.payload.property);\n          delete (res.payload.value);\n    }\n\n    if (res.payload.property == \"NULL\") {\n          delete (res.payload.property);\n          delete (res.payload.value);\n    }\n    \n    if (res.payload.value == \"NULL\")\n           delete (res.payload.value);\n\n return res;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 60,
        "wires": [
            []
        ],
        "info": "Implements 'NULL' rules, format output."
    },
    {
        "id": "cb536e9b3a81862a",
        "type": "function",
        "z": "f30e8140.1bed9",
        "name": "late binding",
        "func": "\nfunction _upadateParam(_pname){\n     var  _xvalue = env.get(_pname);\n     if (_xvalue){\n      let temp = _xvalue.toString().trim();\n        if (temp.startsWith('global.'))\n           _xvalue = global.get(temp.substring(7));\n        else if(temp.startsWith('flow.'))\n           _xvalue = flow.get(\"$parent.\"+ temp.substring(5));\n        else if(temp.startsWith('msg.'))\n           _xvalue = msg[temp.substring(4)];\n// extra eval           \n        else if(temp.startsWith('@'))\n           _xvalue = eval(temp.substring(1));\n       }\n      \n// optional: to set the parameter dynamically with a message property, same name\n      if((msg.command)&&(msg.command[_pname]))\n           _xvalue = msg.command[_pname];\n           \n// save actual value in the (sub)flow context           \n      flow.set(_pname, _xvalue);\n      }\n      \n// CUSTOMIZE HERE\n// get actual values\n _upadateParam(\"remote\");\n _upadateParam(\"device\");\n _upadateParam(\"property\");\n _upadateParam(\"value\");\n // done\nreturn msg;\n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 60,
        "wires": [
            [
                "cf230930.f37938"
            ]
        ],
        "info": "See [Subflows and configuration: late and runtime parameters binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042)\n\nModified:\n- added evalued binding: @&lt;expression>  => eval(&lt;expression>). e.g. `@Date.now()` \n- runtime override: uses `msg.command.xxx`"
    },
    {
        "id": "e1c6cc8a.2f92a",
        "type": "subflow",
        "name": "REFRESH",
        "info": "\nUse this subflow to drive devices with `REFRESH` capability.\n\nIt acts like a filter on device msg, intercepts and implements two pseudo-DP to handle the REFRESH:\n\n - SET  `_refreshCycle` ` off| time [s]` : off/on polling\n - GET  `_refreshCycle` : back last value\n  \n - SET `_refresh`  `dummy` : immdiate REFRESH\n-  GET `_refresh`  ignored\n\n### Parameters\n\n   <dl class=\"message-properties\">\n        <dt>deviceId\n            <span class=\"property-type\">string</span>\n        </dt>\n        <dd>   The ID of the wired Tuya device (same as in `core.global.alldevices`).\n        </dd>\n         <dt>Max_time\n            <span class=\"property-type\">number</span>\n        </dt>\n        <dd>  Timeout [s] for `_refreshCycle`, without `stop` message.\n        \n - Default: `global.MAXREFRESH`, a common value for all devices. If the user like, it can use a different 'global' value for any device.\n - uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n   - early binding:  a number, e.g. `60`\n   - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.MAXREFRESH`\n   - evalued value: a string starting with '@', e.g. `@global.get('MAXREFRESH')*3`\n\n        </dd>\n </dl>\n \n### Inputs\n\nAll low level messages for a device.\n\n### Outputs\n\n1. To device: all input messages, less `_refresh` and `_refreshCycle`, \nplus 'REFRESH' messages for the device.\n\n2. To logging: some log messages.\n\n### Details\n\nSome devices (e.g. AC power meter) convert and send data (PUSH) at very low frequence, and a GET returns the last PUSHed data.\nBut sometime, e.g. when the UI is open, it is better to uptate the interface at a faster rate (smartLife app uses 5s).\nIf the device implements the REFRESH command, the user can send two pseudoDP:\n1. `_refresh`: to convert and GET an immediate value (PUSH).\n2. `_refreshCycle`: to start a automatic PUSH cycle, with an user defined rate, until a 'stop' command or until 'Max time' has expired.\n\nnote: add in alldevices the device.capability 'REFRESH', else ERROR message.\n\n### References\nFor the native documentation see [tuyapi](https://codetheweb.github.io/tuyapi/index.html#tuyadevicerefresh) and [node-red-contrib-tuya-smart-device](https://github.com/vinodsr/node-red-contrib-tuya-smart-device#input-format)<br>\nFor device message formats see `low_level_IN` 'core' node\n",
        "category": "",
        "in": [
            {
                "x": 100,
                "y": 60,
                "wires": [
                    {
                        "id": "2542f38785a72b2e"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 770,
                "y": 120,
                "wires": [
                    {
                        "id": "c306cbee.682538",
                        "port": 1
                    },
                    {
                        "id": "9eb78521.a29748",
                        "port": 0
                    }
                ]
            },
            {
                "x": 760,
                "y": 180,
                "wires": [
                    {
                        "id": "c306cbee.682538",
                        "port": 2
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "deviceID",
                "type": "str",
                "value": "",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "Max time",
                "type": "num",
                "value": "global.MAXREFRESH",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#DDAA99",
        "inputLabels": [
            "msg"
        ],
        "outputLabels": [
            "device",
            "logging"
        ],
        "icon": "font-awesome/fa-circle-o-notch"
    },
    {
        "id": "c306cbee.682538",
        "type": "function",
        "z": "e1c6cc8a.2f92a",
        "name": "REFRESH control",
        "func": "\nconst FASTDP = \"_refreshCycle\";   // set: 'off'| time [s]\nconst REFDP  = \"_refresh\";        // set: any (trigger)\nconst DEVID  = env.get(\"deviceID\");\n// options for tests\nconst REFONLY   = {operation: \"REFRESH\"};\nconst REFONE    = {operation: \"REFRESH\", dps:20};\nconst REFMANY   = {operation: \"REFRESH\", requestedDPS:[1,9,6,17,18,19,20]};\nconst REFSCHEMA = {operation: \"REFRESH\", schema:true};\n// in this version used only REFONLY, because the others do not give appreciable differences,\nfunction isNone(value){\n    if(value){\n        if(typeof(value) === \"string\"){\n            if(value.toUpperCase() === 'OFF') return true;\n            if(value.toUpperCase() === 'NO') return true;\n            if(value.toUpperCase() === 'NONE') return true;\n        }\n    return false;\n    }\nreturn true;\n}\n\nif (DEVID === \"\"){\n node.warn(\"ERROR [REFRESH] deviceID not set.\");\n return[null];\n}\n// builds the output message\nvar newMsg = {\n    \"payload\": {\n        \"deviceId\": DEVID,\n        \"deviceName\": \"dummy\", // as device node, not used\n        \"data\": {\n            \"dps\": {}\n        }\n    }\n};\n\n// --------------------------------\n// ignores pseudoDP\nif ((msg.payload === undefined) || (msg.payload.dps === undefined)) return [null, msg];\n//\n// test for REFDP  SET/GET case\nif (msg.payload.dps === REFDP){\n    if (msg.payload.set !== undefined) { // is set\n        newMsg.payload.data.dps[REFDP] = \"sent\";\n        return ([null, {payload:REFONLY}, newMsg]);\n        } else\n    return [null];   // no GET\n }\n\n//  test for  REFDP MULTIPLE case\nif ((msg.payload.data !== undefined) && (msg.payload.data[REFDP] !== undefined) ) {\n    delete msg.payload.data[REFDP];\n    newMsg.payload.data.dps[REFDP] = \"sent\";\n    node.send([null, { payload: REFONLY }, newMsg]);\n    return ([null, msg]);\n}\n\n// ----------------------------------\n// test for FASTDP  SET/GET case\nif (msg.payload.dps === FASTDP) {\n    if (msg.payload.set !== undefined) { // is set\n        context.set(\"fast\", msg.payload.set);\n        newMsg.payload.data.dps[FASTDP] = msg.payload.set;\n        if (isNone(msg.payload.set)) {\n             return ([{ payload: \"stop\" }, null, newMsg]);\n        } else{\n          return ([{ payload:REFONLY, \n                     loop:{duration: msg.payload.set, units:\"Second\", maxtimeout: flow.get(\"Max time\"), maxtimeoutunits:\"Second\"}} , null, newMsg]);\n        } \n    } else { // is get, back last value\n        newMsg.payload.data.dps[FASTDP] = context.get(\"fast\");\n        return ([null, null, newMsg]);\n    }\n}\n\n// test for FASTDP  MULTIPLE case\nif ((msg.payload.data !== undefined) && (msg.payload.data[FASTDP] !== undefined)) {\n    let fst = msg.payload.data[FASTDP];\n    delete msg.payload.data[FASTDP];\n    context.set(\"fast\", fst);\n    newMsg.payload.data.dps[FASTDP] = fst;\n    if (isNone(fst)) {\n             return ([{ payload: \"stop\" }, null, newMsg]);\n        } else{\n          return ([{ payload: REFONLY , \n                     loop:{duration: fst, units:\"Second\", maxtimeout: env.get(\"Max time\"), maxtimeoutunits:\"Second\"}} , null, newMsg]);\n        } \n}\n\n// test for ALL,  SCHEMA case\nif (msg.payload.schema) {\n    newMsg.payload.data.dps[FASTDP] = context.get(\"fast\");\n    return ([null, msg, newMsg]);\n}\n// else do nothing\nreturn [null, msg];\n",
        "outputs": 3,
        "noerr": 0,
        "initialize": "// Code added here will be run once\n// whenever the node is deployed.\ncontext.set(\"fast\",0);",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 120,
        "wires": [
            [
                "9eb78521.a29748"
            ],
            [],
            []
        ],
        "info": "CUSTOMIZATION:\n\n- duplicate this node for any new device\n- update in code the deviceId\n  \nsee: [Howto: add a new device to tuyaDAEMON](https://github.com/msillano/tuyaDAEMON/wiki/Howto:-add-a-new-device-to-tuyaDAEMON)"
    },
    {
        "id": "9eb78521.a29748",
        "type": "looptimer-advanced",
        "z": "e1c6cc8a.2f92a",
        "duration": "10",
        "units": "Second",
        "maxloops": "1000000",
        "maxtimeout": "60",
        "maxtimeoutunits": "Second",
        "name": "",
        "x": 580,
        "y": 60,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "2542f38785a72b2e",
        "type": "function",
        "z": "e1c6cc8a.2f92a",
        "name": "late binding",
        "func": "\nfunction _upadateParam(_pname){\n     var  _xvalue = env.get(_pname);\n     if (_xvalue){\n        let temp = _xvalue.toString().trim();\n        if (temp.startsWith('global.'))\n           _xvalue = global.get(temp.substring(7));\n        else if(temp.startsWith('flow.'))\n           _xvalue = flow.get(\"$parent.\"+ temp.substring(5));\n        else if(temp.startsWith('msg.'))\n           _xvalue = msg[temp.substring(4)];\n           // extra eval           \n        else if(temp.startsWith('@'))\n           _xvalue = eval(temp.substring(1));\n      }\n      \n// optional: to set the parameter dynamically with a message property, same name\n//      if((msg.command)&&(msg.command[_pname]))\n//        _xvalue = msg.command[_pname];\n           \n// save actual value in the (sub)flow context           \n      flow.set(_pname, _xvalue);\n      }\n      \n// CUSTOMIZE HERE\n// get actual values\n _upadateParam(\"Max time\");\n // done\nreturn msg;\n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 230,
        "y": 60,
        "wires": [
            [
                "c306cbee.682538"
            ]
        ],
        "info": "See [Subflows and configuration: late and runtime parameters binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042)\n\nModified:\n- added evalued binding: @&lt;expression>  => eval(&lt;expression>). e.g. `@Date.now()` \n"
    },
    {
        "id": "15c9daba.b55285",
        "type": "subflow",
        "name": "dynamic retry",
        "info": "Transform the `status` msg from a _tuya-smart-device_ node into an _event_ message. Implement a dynamic retry policy.\n\n### Parameters\n\n   <dl class=\"message-properties\">\n        <dt>deviceId\n            <span class=\"property-type\">string</span>\n        </dt>\n        <dd>   The ID of the wired Tuya device (same as in `core.global.alldevices`).\n        </dd>\n         <dt>MinTimeout\n            <span class=\"property-type\">number | string | @string</span>\n        </dt>\n        <dd>  Low limit for fast retry [ms].\n\n  - uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n    - early binding:  a number | string, e.g. `1000`\n    - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.fast-connection`\n    - evalued value: a string starting with '@', e.g. `@1*1000`\n\n </dd>\n <dt>MaxTimeout <span class=\"property-type\">number | string | @string</span> </dt>\n        <dd>High limit for slow retry [ms].\n\n  - uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n      - early binding:  a number | string, e.g. `60000`\n      - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.slow-connection`\n      - evalued value: a string starting with '@', e.g. `@1*60*1000`\n\n </dd>\n  </dl>\n\n### Inputs\n\n From _tuya-smart-device_ `client satus` output.\n\n### Outputs\n  1. **event msg**:  a new event message:\n ````\n  object\n   { \"payload\":{\n        \"deviceId\": <deviceID>,\n        \"data\": {\n           \"dps\":{\n              \"_connected\": true|false\n            }}}}\n ````\n \n It can ben routed to `logging` input node of `core` flow.\n\n 2. a **low level SET message**: SET timeout for the device, sent directly to core `low_lev_IN` input node.\n````\n  object\n   { \"payload\":{\n        \"toDev\": idevice,\n        \"payload\": {\n           \"dps\": \"_findTimeout\",\n           \"set\": <dynamic-value>\n           }}}\n````\n\n### Details\nSome devices, usully always ON, requires fast timeout to reconnect soon (see `static retry` subflow), but other devices, sometime OFF, requires a different strategy: `dynamic retry`.\n\n\nThis subflow process the `status` output from a tuya-smart-device node. If the connection status changes, it creates an event for standard logging, filtering unecessary messages.\n\nDynamically optimizes the timeout of Tuya device connection attempts (since `smart-tuya-device-node` 4.0.2):\n- When the device is _connected_, the retry timeout is fast, set to `MinTimeout`.\n- If the device is _disconnected_, the timeout grows randomly until a `MaxTimeout`.\n\n_Example:_\nSet in `smart-tuya-device-node`:\n  - `Interval for retry connection` = 1000 (default, 1 sec).\n  - `Connection search interval` = 1000 \n\nWith the default settings (1s, 60s), the minimum retry interval is approximately _10 seconds_ (affected by many factors).\n\nIf the device is disconnected, the interval increases in random increments to approximately _sec. 60 in 9/10 minutes_ \n\nUse it with Tuya devices often OFF or not in use (e.g. mobile AC plugs).\n\n### References\n\nSee also `static retry` subflow.<br>\nFor the native documentation see  [node-red-contrib-tuya-smart-device](https://github.com/vinodsr/node-red-contrib-tuya-smart-device#input-format).<br>\nFor messages formats see `logging` 'core' node and `low_level_IN` 'core' node.\n\n",
        "category": "",
        "in": [
            {
                "x": 40,
                "y": 40,
                "wires": [
                    {
                        "id": "292158fe075ae5f4"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 740,
                "y": 20,
                "wires": [
                    {
                        "id": "a7c39c7.4e2dd6",
                        "port": 0
                    }
                ]
            },
            {
                "x": 760,
                "y": 80,
                "wires": [
                    {
                        "id": "a7c39c7.4e2dd6",
                        "port": 1
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "deviceId",
                "type": "str",
                "value": " ID (see global.alldevices)",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "MinTimeout",
                "type": "num",
                "value": "1000",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "MaxTimeout",
                "type": "num",
                "value": "60000",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#DDAA99",
        "inputLabels": [
            "from status"
        ],
        "outputLabels": [
            "out msg",
            "to low_lev_msg"
        ],
        "icon": "font-awesome/fa-rss-square"
    },
    {
        "id": "a7c39c7.4e2dd6",
        "type": "function",
        "z": "15c9daba.b55285",
        "name": "connected message - dynamic",
        "func": "// to set global.tuyasyatus.xxxx._connected\n\nconst CONN = \"_connected\"; //  pseudoDP\nconst TMT = \"_findTimeout\";\nconst RMT = \"_retryTimeout\";\n\n// local functions\nfunction _sendReal(idevice, value) {\n   // builds a fake OUT message\n   var newMsg = {\n      \"payload\": {\n         \"deviceId\": idevice,\n         \"data\": {\n            \"dps\": {\n               [CONN]: value\n            }\n         }\n      }\n   };\n   return newMsg;\n}\n\nfunction _sendTimeout(idevice, timeout) {\n   var tmtMsg = {\n      \"toDev\": idevice,\n      \"payload\": {\n         \"dps\": TMT,\n         \"set\": timeout\n      }\n   };\n   return tmtMsg;\n}\n\nfunction getRandomArbitrary(min, max) {\n   return Math.random() * (max - min) + min;\n}\n\n// ------------------  main\nconst XfLo = 1.0; // min increment 0%\nconst XfHi = 1.4; // min increment 40%\n// user set parameter device id\nlet deviceId = env.get(\"deviceId\");\nlet Tmin = flow.get(\"MinTimeout\");\nlet TMAX = flow.get(\"MaxTimeout\");\n//\nlet cold = context.get(deviceId + \"_con\");\nlet cnew = cold;\nlet told = context.get(deviceId + \"_time\");\nlet tnew = told;\ncMsg = null;\ntMsg = null;\n//status.text\nif (msg.payload == undefined) return [null];\nswitch (msg.payload.state) {\n    case \"CONNECTED\":\n      if (told > Tmin) {\n          tnew = Tmin;\n       }\n       cnew = \"connected\";\n       break;\n   case \"DISCONNECTED\":\n       if (told < TMAX) {\n          tnew = Math.floor(told * getRandomArbitrary(XfLo, XfHi));\n       }\n       cnew = \"connecting\";\n        break;\n   case \"CONNECTING\":\n       cnew = \"connecting\";\n       break;\n    }\n\nif (cnew !== cold) {\n   cMsg = _sendReal(deviceId, cnew === \"connected\");\n   context.set(deviceId + \"_con\", cnew);\n}\n\nif (tnew !== told) {\n   tMsg = _sendTimeout(deviceId, tnew);\n   context.set(deviceId + \"_time\", tnew);\n}\nreturn ([cMsg, tMsg]);\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "// Code added here will be run once\n// set the default status _connected to null in tuyastatus\n// creates tuyastatus entry to null.\nlet deviceId = env.get(\"deviceId\");\ncontext.set(deviceId + \"_con\", \"none\");\nlet Tmin = env.get(\"MinTimeout\");\ncontext.set(deviceId + \"_time\", Tmin);\n",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 40,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "292158fe075ae5f4",
        "type": "function",
        "z": "15c9daba.b55285",
        "name": "late binding",
        "func": "\nfunction _upadateParam(_pname){\n     var  _xvalue = env.get(_pname);\n     if (_xvalue){\n      let temp = _xvalue.toString().trim();\n        if (temp.startsWith('global.'))\n           _xvalue = global.get(temp.substring(7));\n        else if(temp.startsWith('flow.'))\n           _xvalue = flow.get(\"$parent.\"+ temp.substring(5));\n        else if(temp.startsWith('msg.'))\n           _xvalue = msg[temp.substring(4)];\n// extra eval           \n        else if(temp.startsWith('@'))\n           _xvalue = eval(temp.substring(1));\n       }\n      \n// optional: to set the parameter dynamically with a message property, same name\n//      if((msg.command)&&(msg.command[_pname]))\n//           _xvalue = msg.command[_pname];\n           \n// save actual value in the (sub)flow context           \n      flow.set(_pname, _xvalue);\n      }\n      \n// CUSTOMIZE HERE\n// get actual values\n _upadateParam(\"MinTimeout\");\n _upadateParam(\"MaxTimeout\");\n // done\nreturn msg;\n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 170,
        "y": 40,
        "wires": [
            [
                "a7c39c7.4e2dd6"
            ]
        ],
        "info": "See [Subflows and configuration: late and runtime parameters binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042)\n\nModified:\n- added evalued binding: @&lt;expression>  => eval(&lt;expression>). e.g. `@Date.now()` \n- runtime override: uses `msg.command.xxx`"
    },
    {
        "id": "81d3b584.14c888",
        "type": "subflow",
        "name": "do logging",
        "info": "This subflow simulates data received from a _real tuya device_, i.e. it builds an 'event' to be sent to the `core.logging` input.\n\nGeneral purpose, used to build events in mirror and fake devices.\n\n### Parameters\n<dl class=\"message-properties\">\n    <dt>remote <span class=\"property-type\">string | @string | NULL</span> </dt>\n    <dd>   the tuyaDEAMON instance (as in _core.global.remotemap_) or NULL.\n        \n - Default: NULL => delete 'remote' (i.e. local)\n - uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n      - early binding:  a string, e.g. `ANDROID`\n      - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.instance_name`\n      - evalued value: a string starting with '@', e.g. `@global.get('instance_name')`\n- runtime override: from `msg.logging.remote` value\n\n </dd>\n    <dt>deviceID <span class=\"property-type\">string | @string</span> </dt>\n    <dd>   the device user-name or `ID` or `CID` (as in _core.global.alldevices_).\n \n -  uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n     - early binding:  a string, e.g. `core`\n     - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.TUYABRDG`\n     - evalued value: a string starting with '@', e.g. `@\"tuya\"+\"_bridge\"`\n - runtime override: from `msg.logging.deviceID` value\n\n</dd>\n   <dt>propertyDP <span class=\"property-type\">string | @string</span> </dt>\n   <dd>   the data point ID or user.name (string: \"3\" or \"_version\")\n        \n-  uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n     - early binding:  a string, e.g. `foo`\n     - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.COUNTDP`\n     - evalued value: a string starting with '@', e.g. `@global.get()`\n- runtime override: from `msg.logging.propertyDP` value\n\n</dd>\n<dt>value<span class=\"property-type\">any | @string | NULL</span></dt>\n<dd>  the new value from the device.\n        \n- Default: NULL => \"\"\n- uses [late binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042) node (extended), and accepts:\n     - early binding:  a string, e.g. `foo`\n     - late binding: a string starting with 'global.' | 'flow.' | 'msg.' e.g. `global.instance_name`\n     - evalued value: a string starting with '@', e.g. `@Date.now()`\n- runtime override: from `msg.logging.value` value\n\n</dd> </dl>\n\n### Input\n\n  Any, used only to provoke the output, but values like `msg.logging.remote` can override the parameters.\n\n\n### Output\n\n````` \n  object\n     {\n    \"payload\": {\n        \"remote_from\" : <remote>,       // optional  \n        \"deviceId\": <deviceId>,\n        \"data\": {\n            \"dps\": {\n                \"<propertyDP>\" = <value>\n            }}}\n`````\n### References\nFor event messages format see `logging` INPUT node in 'core' flow.<br>\nAbout mirror devices, see ['Smoke_Detector':-case-study](https://github.com/msillano/tuyaDAEMON/wiki/mirror-device-'Smoke_Detector':-case-study)\n\n",
        "category": "",
        "in": [
            {
                "x": 140,
                "y": 80,
                "wires": [
                    {
                        "id": "4276113107f56397"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 660,
                "y": 80,
                "wires": [
                    {
                        "id": "6d1b2b8f.c5e554",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "remote",
                "type": "str",
                "value": "NULL",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "deviceID",
                "type": "str",
                "value": "required",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "propertyDP",
                "type": "str",
                "value": "required",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "value",
                "type": "str",
                "value": "any value allowed",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str",
                            "num",
                            "bool",
                            "json",
                            "env"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#87A980",
        "icon": "node-red/debug.svg"
    },
    {
        "id": "6d1b2b8f.c5e554",
        "type": "function",
        "z": "81d3b584.14c888",
        "name": "format logging msg",
        "func": "    // builds a fake OUT message\n   var newMsg = {\n         \"payload\": {\n           \"remote_from\" : flow.get(\"remote\"),\n           \"deviceId\" : flow.get(\"deviceID\"),\n           \"data\":{\n                dps :{}\n                }\n            }\n        }\n  // late binding CUSTOM: special 'NULL' process for 'do Logging' subflow\n   if (newMsg.payload.remote_from === 'NULL')\n         delete(newMsg.payload.remote_from);\n  \n   newMsg.payload.data.dps[flow.get(\"propertyDP\").toString()] = ((flow.get(\"value\") === 'NULL')? \"\" : flow.get(\"value\"));\n\n   return (newMsg);\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 80,
        "wires": [
            []
        ],
        "info": "implements 'NULL' rules, format output object."
    },
    {
        "id": "4276113107f56397",
        "type": "function",
        "z": "81d3b584.14c888",
        "name": "late binding",
        "func": "\nfunction _upadateParam(_pname){\n     var  _xvalue = env.get(_pname);\n     if (_xvalue){\n        temp = _xvalue.toString().trim();\n        if (temp.startsWith('global.'))\n           _xvalue = global.get(temp.substring(7));\n        else if(temp.startsWith('flow.'))\n// fom caller flow context        \n           _xvalue = flow.get(\"$parent.\"+ temp.substring(5));\n        else if(temp.startsWith('msg.'))\n           _xvalue = msg[temp.substring(4)];\n// extra eval           \n        else if(temp.startsWith('@'))\n           _xvalue = eval(temp.substring(1));\n      }\n// optional: to set the parameter dynamically with a message property\n      if((msg.logging)&&(msg.logging[_pname]))\n           _xvalue = msg.logging[_pname];\n\n// save actual value in the (sub)flow context  \n      flow.set(_pname, _xvalue);\n      }\n      \n _upadateParam(\"remote\");\n _upadateParam(\"deviceID\");\n _upadateParam(\"propertyDP\");\n _upadateParam(\"value\");\n\n // done\nreturn msg;\n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 80,
        "wires": [
            [
                "6d1b2b8f.c5e554"
            ]
        ],
        "info": "See [Subflows and configuration: late and runtime parameters binding](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042)\n\nModified:\n- added evalued binding: @&lt;expression>  => eval(&lt;expression>). e.g. `@Date.now()` \n- runtime override: uses `msg.logging.xxx`"
    },
    {
        "id": "ee953c15.ada29",
        "type": "subflow",
        "name": "static retry",
        "info": "Transform the `status` msg from a _tuya-smart-device_ node into an _event_ message.\r\n\r\nRequired adding  a new Tuya device (alternative: `dynamic rety` subflow)\r\n\r\n### Parameters\r\n\r\n   <dl class=\"message-properties\">\r\n        <dt>deviceId\r\n            <span class=\"property-type\">string</span>\r\n        </dt>\r\n        <dd>   The ID of the wired Tuya device (same as in `core.global.alldevices`).\r\n        </dd>\r\n   </dl>\r\n\r\n### Inputs\r\n\r\n From _tuya-smart-device_ `client satus` output.\r\n\r\n### Outputs\r\n\r\n A new event message:\r\n ````\r\n  object\r\n   { \"payload\":{\r\n      \"deviceId\": <deviceID>,\r\n      \"data\": {\r\n          \"dps\":{\r\n            \"_connected\": true|false\r\n          }}}}\r\n ````\r\n \r\n It can ben routed to _logging_ input node of `core` flow.\r\n\r\n### Details\r\n\r\nProcess the `status` output from a tuya-smart-device node. If the connection status changes, it creates an event for standard logging, filtering unecessary messages.\r\n\r\nUse it with Tuya devices always ON. \r\n\r\n\r\nIf the device is disconnected, the reconnect interval, function(findTimeout, retryTimeout), is fixed. It is set in the _tuya-smart-device_ node (default) and modified with the pseudo-dp: \r\n  - SET  `_findTimeout`   Integer [ms]\r\n  - SET  `_retryTimeout`  Integer [ms]\r\n\r\n### References\r\n\r\nSee also `dynamic retry` subflow.<br>\r\nFor the event formats see `core.logging` INPUT node.",
        "category": "",
        "in": [
            {
                "x": 80,
                "y": 80,
                "wires": [
                    {
                        "id": "6160136.f5f99ec"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 510,
                "y": 80,
                "wires": [
                    {
                        "id": "6160136.f5f99ec",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "deviceId",
                "type": "str",
                "value": " ID (see global.alldevices)",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#DDAA99",
        "inputLabels": [
            "in staus"
        ],
        "outputLabels": [
            "to log"
        ],
        "icon": "font-awesome/fa-rss-square"
    },
    {
        "id": "6160136.f5f99ec",
        "type": "function",
        "z": "ee953c15.ada29",
        "name": "connected message - static",
        "func": "// to set global.tuyasyatus.xxxx._connected \n// creates a response for the dp \"_connected\"\n// store value and filter events\n\nvar CONN = \"_connected\";  //  tuyadaemon internal define\n// see also tuyaDAEMON.\"connection check\" function\n// local function\nfunction _sendReal(idevice,  value){\n// builds a fake OUT message \nvar newMsg = { \"payload\":{\n      \"deviceId\": idevice,\n      \"data\": {\n          \"dps\":{\n            [CONN]:value\n          }}}};\nreturn newMsg;  \n}\n\n// user set parameter device id (simple)\nvar deviceId = env.get(\"deviceId\");\n\nvar nowconnected;\nif((msg.payload !== undefined)&&(msg.payload.state !== undefined)){\n   nowconnected =  (msg.payload.state == \"CONNECTED\" || msg.payload.state == \"node-red:common.status.connected\" );        // can change\n}\nif((msg.status !== undefined)&&(msg.status.text !== undefined)){\n   nowconnected =  (msg.status.text == \"CONNECTED\" || msg.status.text == \"node-red:common.status.connected\" );        // can change\n}\nif (nowconnected == undefined) return null;\n// filering \nlet old = context.get(deviceId+\"_con\");\n// node.warn([\"STATUS \",msg, nowconnected, old]);\n\nif (old === nowconnected) return null;\ncontext.set(deviceId+\"_con\", nowconnected);\n\nreturn(_sendReal(deviceId, nowconnected));\n\n\n\n\n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "// Code added here will be run once\n// set the default status _connected to 'none' in tuyastatus\nvar deviceId = env.get(\"deviceId\");\ncontext.set(deviceId+\"_con\",\"none\");",
        "finalize": "",
        "libs": [],
        "x": 260,
        "y": 80,
        "wires": [
            []
        ],
        "info": "Makes  the _event_ message."
    },
    {
        "id": "173260fb.d021ff",
        "type": "tab",
        "label": "CORE",
        "disabled": false,
        "info": "\nThe **tuyaDAEMON CORE** handles the LOW LEVEL MQTT communications with devices, offering you a  bidirectional integration with 'real' and 'virtual' Tuya devices.\n\nVersion 2.2.0\n\n   see: https://github.com/msillano/tuyaDAEMON\n   see: https://github.com/msillano/tuyaDAEMON/tree/main/tuyaDAEMON\n\n### Installation\n\nsee [github documentation](https://github.com/msillano/tuyaDAEMON/tree/main/tuyaDAEMON#installation)\n\n### Configuration\n\nUpdate the node: 'global CORE config': follow the node documentation.\n \n Checklist:\n - in _Global CORE config_ node set the `instance_name`\n - in _Global CORE config_ node update the `remoteMAP` with `instance_name`\n - in _Global CORE config_ node set `alldevice_file_path` to a local value.\n - in all CORE `DB nodes` verify the correct associations with `DB configuration` nodes\n\nTest CORE, then add in sequence (optional):\n  - tuyadaemon.core_TRIGGER, configure and test it.\n  - tuyadaemon.core_SYSTEM, configure and test it\n  - tuyadaemon.core_MQTT, configure and test it\n\n### IMPORTANT: node-red-contrib-tuya-smart-device updating.\n\nFor better performances with tuyaDAEMON you can replace the standard node-red-contrib-tuya-smart-device 4.1.1 with an updated version.\nThis will produce less 'error messages' and fastest device connections, important factor having many devices.\n\n   - download the file `tuya-smart-device-updated.4.1.1.zip` from https://github.com/vinodsr/node-red-contrib-tuya-smart-device/issues/83\n   - make a copy of the file \"[D:\\nodered\\flow-1984]\\node_modules\\node-red-contrib-tuya-smart-device\\src\\tuya-smart-device.js\" as backup.\n   - replace \"tuya-smart-device.js\" with the file in  `tuya-smart-device-updated.4.1.1.zip`\n   - done: restart node-red\n\n### Updating devices from a precedent version.\n\nOpen tuyaDAEMON new and the old one as well (using a lan or different ports).\n\nIn old: select the nodes (device selector, refresh, tuya_smart, retry) and EXPORT to clipboard the 'selected nodes'.\n\nIn new: open the 'core' flow and IMPORT from Clipboard (do not replace subflows):\n - Restore connections. \n - update '*catch device and LAN errors' node\n - Update the global.alldevice from old using 'cut+paste' or the tools: tuyadaemonthings and tuyadamontool.\n\n### Adding new Tuya devices\n see the wiki: https://github.com/msillano/tuyaDAEMON/wiki/Howto:-add-a-new-device-to-tuyaDAEMON\n \n### pogrammer's note:\n -  private IN/OUT link nodes for internal flow use: they are all without label and with a special double arrow icon ('fa_expand' icon).\n -  private IN/OUT intra-flows links are without label.\n -  public  IN/OUT link nodes, useful for custom devices or extension flows: they are all labeled and accepted 'msg' formats are in the node documentation.\n \n\n### custom extensions are easy in the areas:\n - new device data encoding/decoding functions, to translate device data into human format. There are now 14 functions, but you can add more for your devices (see '*ENCODE/DECODE user library' node)\n - number and strategy of use of the DBs: the default value is max 2 DBs, and all the event and command logs go into a single DB. Maybe you need to change this (see 'CUSTOMIZE: DBase servers (readme)' node)\n "
    },
    {
        "id": "a878b58e.e4ea08",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "OUT data process",
        "func": "// sends any message to DB (sql in msg.topic), updates tuyastatus\n// version 1.1 (use of _call_library)\n// version 2,0 (use of context.global.alldevices  amd  context.global.datadecode\n//-------------------------------------------\n\n// local functions:\n\n// -------------------------------------------- private functions\nvar oDev = null;\nvar _dataname = \"\";\n\n// updates the global \"tuyastatus\"\n// note: for real devices: tuyastatus._connected is handle by static/dynamic retry node.\n//       for fake devices: tuyastatus._connected is handle by \"xxx flow startup\" node in the flow.    \n//       for virtual devices:  tuyastatus._connected is handle here\nfunction _addToStatus(remote, dnx, _datanx, dx, tx) {\n    var mystatus = global.get(\"tuyastatus['\"+dnx +\"']\");\n    if (mystatus === undefined)\n        mystatus = {};\n    mystatus[_datanx] = dx;\n    if (_datanx != \"_connected\")\n        mystatus._connected = true;\n    mystatus._t = tx;\n    global.set(\"tuyastatus['\"+dnx+\"']\", mystatus);\n}\n\n// clean data (object, array) using JSON.stringify, to get a string for DB\nfunction formatData(data) {\n    var clean = JSON.stringify(data);\n    if (clean[0] === '\"')\n        clean = clean.substring(1).slice(0, -1);\n    //    return clean.replace(/'/g, '&#39;');  // sigle quotes are dangerous in sql\n    //    return clean.replace(/'/g, '\\\\x27');\n    return clean.replace(/'/g, \"\\\\'\");\n}\n\n// For DB output, string\nfunction formatName(data) {\n    if (data == null)\n        return 'NULL';\n    //    return data.replace(/'/g, '&#39;');  // sigle quotes are dangerous in sql\n    //    return data.replace(/'/g, '\\\\x27');\n    return data.replace(/'/g, \"\\\\'\");\n}\n\n// true if device is a real device (virtual := cid exists)\nfunction _isreal(mx) {\n    return (mx.payload.data.cid === undefined);\n}\n\n// returns deviceId (real) or cid (virtual), never fails\nfunction _getID(mx) {\n    return ( mx.payload.data.cid || mx.payload.deviceId);\n}\n\n// returns data.t or now(), formatted for mySQL, never fails\nfunction _mySQLdatetime(mx) {\n    //datetime format for mySQL: '2020-12-18 20:45:02'\n    // using 'sv' for date format and local timezone\n    if (mx.payload.data.t === undefined)\n        return (new Date().toLocaleString('sv'));\n    return (new Date(Number(mx.payload.data.t) * 1000).toLocaleString('sv'));\n}\n\n// returns val, processed by correct datadecode[] function, if required, and sets  _dataname\nfunction _processData(odev, oPx, mx, adpn, val) {\n    _dataname = \"\";\n    if (oPx === undefined) {\n        // not found DP? no PSEUDODP? warning and continue (no change value)\n        if ( ! context.global.PSEUDODP.includes(adpn.toUpperCase())) // extra pseudo-DPs\n            node.warn([\"WARNING [OUT data]: In alldevices missed the '\" + oDev.name + \"':dps[\" + adpn + \"] definition.\"]);\n        _dataname = adpn;\n        return (val);\n    }\n    _dataname = (oPx.name === undefined) ? adpn : oPx.name;\n// general continue\n    if ((oPx.typefield === undefined) || (oPx.typefield === 'NONE'))\n        return (val); // no process\n    if ( context.global.datadecode[oPx.typefield] === undefined) {\n        node.warn(\"ERROR [OUT data]:Not found \" + oPx.typefield + \" dencode function() for '\" + _dataname + \"': data unchanged.\");\n        return (val);\n    }\n// exception for _zeroLog: no decode return data also if oPx.typefield exists.\n    if (oPx.dp === \"_zeroLog\")\n           return(val);\n    try {\n        return  context.global.datadecode[oPx.typefield](val);\n    } catch (error) {\n        node.warn([\"ERROR [OUT data]:in \" + oPx.typefield + \" decode function on value (\" + (typeof(val) === \"string\")?val:JSON.stringify(val) + \"): \" + error,oPx]);\n        return (val);\n    }\n\n}\n\n// get the device object from alldevices, if it don't exist return undefined + warn\n// with a fine handling of error messages.\nfunction _getODevice(mx) {\n    var o;\n    if (_isreal(mx)) {\n        o = context.global.alldevices.getODev(mx.payload.deviceId, \"real\");\n        if (o === undefined) {\n            o = context.global.alldevices.getODev( mx.payload.deviceId, \"fake\");\n        }\n        if (o === undefined) {\n            node.warn(\"ERROR [OUT data]: ADD to alldevices the real/fake deviceId: \" + mx.payload.deviceId + \" (\" + mx.payload.deviceName + \")\");\n        }\n    } else {\n        o = context.global.alldevices.getODev(mx.payload.data.cid, \"virtual\");\n        if (o === undefined) {\n            node.warn(\"ERROR [OUT data]: ADD to alldevices the virtual cid: \" + mx.payload.data.cid + \" [gateway: \" + mx.payload.deviceId + \"]\");\n        }\n    }\n    return (o);\n}\n\n// some ASSERT, just in case...\nif (!(msg.payload.deviceId ))  {\n   node.warn([\"ASSERT fail: in the answer the payload.deviceId must be defined.\", msg]) ;   \n   return null;\n}\nif (!(msg.payload.data)) {\n    node.warn([\"ASSERT fail: in the answer the payload.data is mandatory\", msg]);\n    return null;\n}\n// ---------------------  main\n\nvar warmsg = null; // info debug (1)\nmsg.topic = \"\"; // sql query (2)\n\nvar myId = global.get(\"instance_name\");\nif (msg.payload.remote !== undefined) myId = msg.payload.remote;\n\noDev = _getODevice(msg);\nif (oDev === undefined)\n    return ([null]);    //error sended,  abort\nvar dname = context.global.alldevices.getDevName(oDev);\nmsg[\"from\"] =  _getID(msg);\nmsg[\"hide\"] =  oDev.hide || \"\";\n\n// now processes dp=value couples\nif (msg.payload.data.dps !== undefined) {\n    try {\n//      node.warn([\"out data process IN \", msg]);\n     Object.entries(msg.payload.data.dps).forEach(([key, value]) => {\n// ---- LOOP for DPs        \n        if ((value === undefined) || (value === null)) {\n              node.warn([\"ERROR [OUT data]: from \"+dname+\"/dps[\" + key + \"], the value is not defined.\", msg]);\n              return ;\n              }\n           var warmsg = null;\n           var oPthis =context.global.alldevices.getODps(oDev, key);\n           var pdata = _processData(oDev, oPthis, msg, key, value);\n             // builds sql step by step\n            msg.topic += \" INSERT INTO `messages` (`timestamp`, `daemon`, `action`, `device-id`, `device-name`, `dps`, `dp-name`, `data`, `value`)\\n\";\n            msg.topic += \" VALUES ('\" + _mySQLdatetime(msg) + \"', '\" + myId + \"' , 'RX', '\" + _getID(msg) + \"', '\" + formatName(dname) +\n            \"','\" + key + \"', '\" + formatName(_dataname) + \"', '\" + formatData(value) + \"', '\" + formatData(pdata) + \"') ;\\n\";\n            msg.infodp = key.toString();     // to filter DB\n            if (_dataname !== undefined) {\n                // timestamp as seconds\n                var tx = msg.payload.data.dps.t;\n                if (tx === undefined)\n                    tx = Math.floor(Date.now() / 1000);\n               // info message\n               let sstr = \"RX: \";\n               //  remote_from exists ?\n               if (typeof(msg.payload.remote_from) === \"string\"){\n                  if ( msg.payload.remote_from ===\"\" || msg.payload.remote_from == \"NULL\")\n                           sstr = \"RX: \";   // local\n //                        sstr = global.get(\"instance_name\")+\": RX: \";\n                      else\n                  if(global.get(\"remotemap.local\")[msg.payload.remote_from] === undefined)\n                         sstr = \"UNKNOWN: RX: \";\n                      else\n                         sstr = msg.payload.remote_from+\": RX: \";\n                         }\n               warmsg = {\n                   payload: [sstr + dname + \"/\" + _dataname, pdata]\n                   };\n\n             //from 2.2.0\n                warmsg['hide'] = msg.hide + (((oPthis) && (oPthis.hide))? oPthis.hide:\"\");\n                if (!~warmsg.hide.indexOf(\"K\"))         //  K kills also tuyastatus update\n                    _addToStatus(msg.payload.remote_from, dname, _dataname, pdata, tx);\n                 //more data for fast post processing\n                if(msg.payload.remote_from !== undefined)\n                     warmsg['remote_from'] = msg.payload.remote_from;\n                warmsg['from'] = oDev.cid || oDev.id;\n                warmsg['infodp'] = key.toString();         // extra  for filter...\n                warmsg['info'] = {};            //  required by REST check and by share\n                warmsg['info']['device'] = dname;\n                warmsg['info']['property'] = _dataname;\n                warmsg['info']['value'] = pdata;           // decoded\n                let thishare =  (oPthis === undefined? undefined: oPthis.share ); // auto actions\n                // share only local\n                if ((thishare !== undefined) && (msg.payload.remote_from === undefined))\n                     warmsg['share'] = thishare;\n//             node.warn([\"out outproc \", warmsg,  msg]);\n               node.send([warmsg, null]); // SQL are appended\n            }\n        \n    });\n    } catch (error){\n         node.warn([\"Error in \" + dname + \" device message: \" + error, msg]);\n        return ([null]);\n       \n    }\n    \n} else {\n    if (typeof(msg.payload.data) === \"string\" ){\n        if (msg.payload.data == \"json obj data unvalid\") {\n            node.warn([\"ERROR [OUT data]: from device '\" + dname + \"': not JSON data but 'json obj data unvalid': operation not allowed?.\", msg]);\n        } else {\n            //  usually bad tuya id o key\n            var buff = Buffer.from(msg.payload.data);\n            node.warn([\"ERROR [OUT data]: from device '\" + dname + \"': not JSON data but HEX:\" + buff.toString('hex') + \"  ('\" + msg.payload.data + \"')\", msg]);\n        } }\n    else {\n       node.warn([\"ERROR [OUT data]: from device '\" + dname + \"', maybe bad format ? \", msg]);\n    }\n}\n\nif (msg.topic !== \"\") // some processed, SQL exists\n    return ([null, msg]);\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 1320,
        "wires": [
            [
                "2e4937fc.2ef1f8",
                "e6b9ecd2.653e4",
                "2caa595d.2a0106"
            ],
            [
                "dade252a6ed621f0"
            ]
        ],
        "info": "CUSTOMIZATION:\n\nEdit the code to add a new custom decode function.\n\nmore: \n1. add the dual custom encode function to the 'format command' node\n2. add the dual custom encode function to the 'fastFormat' node\n3. add the CODENAME in the `tuyahome.lookupdecode` table.\n4. now you can use it in global.alldevices, dp.typefield"
    },
    {
        "id": "9fe80f7e.f3f7e",
        "type": "link in",
        "z": "173260fb.d021ff",
        "name": "logging",
        "links": [
            "11023367.4cf45d",
            "1547be76.90a842",
            "15f6fb7d0b7757f5",
            "279abe12072b1eab",
            "2ec83963.a7d146",
            "44351050.b577b",
            "44804bb7.72ee84",
            "54d03d6e.945994",
            "5a8e972b.19e048",
            "6742a2bc05d81f01",
            "678390f9.125df",
            "6fc53253d2a01ae8",
            "798c4138.06176",
            "7b505949.7ba1e8",
            "83ac5d1.6b830a",
            "9a343958.4999a8",
            "aa6116ba.7b69c8",
            "bbd1da58.dba9c8",
            "bca73204.e6afc",
            "be8e7d4f.d6577",
            "c72cf7d0.7ff3c8",
            "cd81b742.e8a268",
            "d6125a353ea185cf",
            "e32fa2db.d0b7c",
            "e914f703.e257b8",
            "edf84736.d76338"
        ],
        "x": 170,
        "y": 1240,
        "wires": [
            [
                "3ef151475f89529b"
            ]
        ],
        "icon": "node-red/arrow-in.svg",
        "l": true,
        "info": "Main entry point for tuyaDEAMON events/responses.\n\nGeneral format (from tuya-smart-device node, modified):\n````\nmsg.payload:{     \n        \"remote_from\": undefined|remoteName,      // only from remote instance, see global.remotemap\n        \"deviceId\":    gatewayID|deviceid,          // from virtual devices => \"deviceId\": gatewayId\n        \"deviceName\":  name,                     // from tuya-smart-device node, optional - not used\n        \"data\": {\n            \"t\": Math.floor( Date.now() / 1000 );       // timestamp (sec), from tuya node, optional \n            \"cid\": deviceid;                                 // only from virtual devices, mandatory\n            \"dps\":{\n                [dp]: value                               // encoded, more than one dp in some cases\n                ....\n            }}}}\n````\n\nFake/custom devices uses a reduced structure:\n````\nmsg.payload:{     \n        \"remote_from\": undefined|SVxx             // only from remote instance, see global.remotemap\n        \"deviceId\":    dev-name|deviceid,        \n        \"data\": {\n            \"dps\":{\n                [dp-name|dp]: value                   // one or many dp, native value can be encoded \n                ....\n            }}}}\n````\n\nCORE processing:\n - fires related 'share' if defined in core.global.alldevices\n - fires actions if user defined in 'mirror' flows.\n\nCORE logging:\n - updates the|many `global.tuyastatus[dev-name][dp-name] = value-decoded`\n - trace on node-red debug.pad\n - send one|many MQTT messages to broker\n - add one|many records to DB\n - send back a HTTP response if started by a REST command.\n\nnote\n - if 't' value is missed, it is addeded by CORE.\n - \"deviceName\" is the tuya-smart-device node name, used only locally in the flow, not used by tuyaDAEMON.\n \n"
    },
    {
        "id": "c991322e.a484e",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "format  command",
        "func": "\n\n// true if device is a real device (virtual == cid exists)\nfunction _isreal(odev) {\n    return (odev.cid === undefined);\n}\n\n// returns deviceId (real) or cid (virtual), never fails\nfunction _getID(odev) {\n    return (odev.cid === undefined ? odev.id : odev.cid);\n}\n\n// true if is a GET command  (GET == msg.payload.value not exists)\nfunction _isget(mx) {\n    return (mx.payload.value === undefined);\n}\n\n// true if is a SET command  (SET == msg.value  exists)\nfunction _isset(mx) {\n    return ((mx.payload.property) && (mx.payload.value !== undefined));\n}\n\n\n// returns now(), formatted for mySQL, never fails\nfunction _mySQLdatetime() {\n    //datetime format for mySQL: '2020-12-18 20:45:02'\n    // using 'sv' for date format (but local timezone)\n    return (new Date().toLocaleString('sv'));\n}\n\n// For DB output, object/string\nfunction formatData(data) {\n    if (data == null)\n        return 'NULL';\n    var clean = JSON.stringify(data);\n    if (clean[0] === '\"')\n        clean = clean.substring(1).slice(0, -1);\n    //    return clean.replace(/'/g, '&#39;');  // sigle quotes are dangerous in sql\n    //    return clean.replace(/'/g, '\\\\x27');\n    return clean.replace(/'/g, \"\\\\'\");\n}\n\n// For DB output, string\nfunction formatName(data) {\n    if (data == null)\n        return 'NULL';\n    //    return data.replace(/'/g, '&#39;');  // sigle quotes are dangerous in sql\n    //    return data.replace(/'/g, '\\\\x27');\n    return data.toString().replace(/'/g, \"\\\\'\");\n}\n\nfunction _getHome() {\n    return global.get(\"instance_name\");\n}\n\n// ==============================  main function\n\nvar req = {};\nvar warn = null;\nvar query = {};\n//\n//---------------------- some assert. just in case...\n\nif ((!msg.payload)) {\n    node.warn([\"ASSERT fail: msg.payload must exist.\", msg]);\n    return [null];\n}\n\nif ((msg.payload.property !== undefined) && (typeof(msg.payload.property) !== \"string\")) {\n    node.warn([\"ASSERT fail: msg.payload.property, if it exists, must be a string.\", msg]);\n    return [null];\n}\n\n// no remote, local\nif (msg.payload.remote && (msg.payload.remote === _getHome())) {\n    delete msg.payload.remote;\n}\n\n// extra, local list, using REST ??\nif ((!msg.payload.remote) && (!msg.payload.device) && (!msg.payload.property) && (!msg.payload.value)){\n     msg.payload.remote = _getHome();\n }\n \n\nif ((!msg.payload.remote) && (!msg.payload.device)) {\n    node.warn([\"ASSERT fail: msg.payload.device must exist in local.\", msg]);\n    return [null];\n}\n\nif ((msg.payload.remote) &&  (!global.get('modules.core_system')))  {\n    node.warn([\"ASSERT fail: 'remote' requires the 'system' module installed.\", msg]);\n    return [null];\n}\n// ---------------- expand messages for remote\n\nif (msg.payload.remote) {\n    let dx = msg.payload;\n    msg.payload = {};\n    msg.payload.value = dx;\n    msg.payload.device = \"_system\";\n    msg.payload.property = \"_proxy\";\n   }\n\n// -----------------------  struff: msg normalization\n    var o = context.global.alldevices.getODev(msg.payload.device);\n    var p = context.global.alldevices.getODps(o, msg.payload.property);\n    msg   = context.global.alldevices.normalize( msg, o, p);\n    if (msg.error){\n        node.warn(\"[Std Cmds] \"+ msg.error);\n        return([null]);\n    }\n    if (msg.warning){\n        node.warn(\"[Std Cmds] \"+ msg.warning);\n        delete msg.warning;\n    }\n\n // after normalization:\n //    payload.device:  name | CID | deviceID | err\n //    payload.property: name | dpID | msg.payload.property + warn\n //    infodp: schema | dpID | msg.payload.property\n //    to:     CID | deviceID\n //    toDEV:  gatewayID | deviceID\n //    hide:   exists\n//  node.warn([\"[Format Command] std cmd normalized \",msg]) ;\n\n// -------------- encoding data on place (so also fake can use encode functions)\nvar uVal = null;\n// node.warn(\" data type is \"+typeof(msg.payload.value));\nif (msg.payload.value){\n    uVal = msg.payload.value;     // for DB\n    // multiple value MUST be encoded, fake can be an object not JSON\n    if((req.infodp !== \"multiple\") && (!(context.global.alldevices.fake.includes(o) && (typeof(msg.payload.value) === 'object')))) {   \n        msg.payload.value  = context.global.alldevices.encodeValue(msg.payload.value, p);\n        if ( msg.payload.value && msg.payload.value.error){\n            node.warn(msg.payload.value.error);\n            return[null];\n            }\n        }        \n}\n\nvar myId = _getHome();\n// ------------   test: device connected ?\nvar cnx = context.global.alldevices.getConnectName(o);\nvar dnx = context.global.alldevices.getDevName(o);\n\nif (cnx !== undefined) {\n//  property in PSEUDODP: can be used on disconnected devices  \n    if ((msg.payload.property !== undefined) && (msg.infodp) && ! context.global.PSEUDODP.includes(msg.infodp.toUpperCase())) {\n        var tuyastatus = global.get(\"tuyastatus\")\n            if ((tuyastatus[cnx]) && (tuyastatus[cnx][\"_connected\"] === false)) {\n                node.warn(\"WARNING: Operation not performed: '\" + cnx + \"' is not connected.\");\n                return ([null]);\n                }\n        }\n} else {\n    node.warn(\"ERROR: add to 'alldevices' the gateway '\" + o.gateway + \"' (used by '\" + dnx + \"')\");\n    return [null];\n}\n// ----  update structures\nreq[\"payload\"] = {};\nreq[\"to\"]      = msg.to;\nreq[\"infodp\"]  = msg.infodp;\nquery[\"to\"]    = msg.to;\nquery[\"infodp\"]= msg.infodp;\n// from 2.2.0\nquery[\"hide\"]  = msg.hide;\n\n// -------------- set default device capabilities\nvar cap;\nif (typeof o.capability !== 'undefined')\n    cap = Array.from(o.capability);\nif ((cap === undefined) || (cap.length < 1))\n    cap = [\"ALL\"]; // the default is ALL\n    \nif (p == undefined)  {  // to process unknown\n   p = {\n       dp :  msg.infondp,\n       };\n    }  \n    \nvar capp =  \"RW\";      // default\nif (typeof( p.capability)  === \"string\")\n    capp =  p.capability;\n//    \n var skipmsg = {\n        \"from\": msg.toDev || msg.to,\n        \"payload\": {\n            \"deviceId\": msg.toDev || msg.to ,\n            \"data\": {\n                \"t\": Math.floor(Date.now() / 1000),\n                \"dps\": {\n                    [p.dp]: msg.payload.value\n                }\n            }\n        }\n    };\n\n// =============================== SKIP dp:  no capabilities, no trace, separate output\nif (capp === \"SKIP\") {\n    if (msg.payload.value === undefined){\n        node.warn([\"ERROR[Std Cmds]: GET of the 'SKIP' properties is not allowed.\", msg]);\n        return [null];\n    }\n\n// uses  response skipmsg\n// virtual    \n if (o.cid !== undefined)   \n       skipmsg.payload.data.cid = o.cid;\n    return [null, null, null, null, skipmsg];\n} \n\n//====================== fake devices: test device capabilities, warn message and DB update only, separate output\nif (context.global.alldevices.fake.includes(o)) {\n    query.topic = \" INSERT INTO `messages` (`timestamp`, `daemon`, `action`, `device-id`, `device-name`, `dps`, `dp-name`, `data`, `value`) \";\n    query.topic += \" VALUES ('\" + _mySQLdatetime() + \"', '\" + myId + \"' ,'TX', '\" + _getID(o) + \"', '\" + formatName(msg.payload.device) + \"','\" + msg.infodp + \"', '\" + formatName(msg.payload.property) + \"', \" + (_isset(msg) ? \"'\" + formatData(msg.payload.value) + \"'\" : \"NULL\") + \", \" + (_isset(msg) ? \"'\" + formatData(uVal) + \"'\" : \"NULL\") + \" );\";\n    // the warning message\n    warn = {\n                payload: null,\n                to     : msg.to,\n                infodp : msg.infodp,\n                hide   : msg.hide\n              };\n    // special process for remote commands (_system/_proxy):\n    if ((msg.to === \"_system\") && ( msg.infodp === \"_proxy\") && (msg.payload.value) && (msg.payload.value.device == undefined)){  // is LIST\n                  warn.payload = msg.payload.value.remote+\": TX: GET device LIST\";\n                  warn.infodp = \"LIST\";       // dunny, to not do error\n          node.send([null, null, warn, null]); \n       } else\n    if ((msg.to === \"_system\") && ( msg.infodp === \"_proxy\") &&(msg.payload.value)){  // no LIST\n         //  normalize remote msg\n        let ro   = context.global.alldevices.getODev(msg.payload.value.device);\n        let rp   = context.global.alldevices.getODps(ro, msg.payload.value.property);\n        let rmsg = context.global.alldevices.normalize({payload: msg.payload.value}, ro, rp);\n        if (rmsg.error){\n            node.warn(rmsg.error);\n            return([null]);\n        }\n        if (rmsg.warning){\n            node.warn(rmsg.warning);\n            delete rmsg.warning;\n        }\n        \n        warn.to     =  rmsg.to;\n        warn.infodp =  rmsg.infodp;\n        \n    \n      // ----------------- info for remote\n      if  (_isset(rmsg)){ \n         if (  rmsg.infodp && ( rmsg.infodp.toUpperCase() === \"MULTIPLE\")) {\n       //           warn.payload = [msg.payload.value.remote+\": TX: SET MULTIPLE \" + rmsg.payload.device + \"/\" + rmsg.payload.property, rmsg.payload.value];\n                node.warn(\"ERROR: remote MULTIPLE commands not allowed.\",msg);\n                return [null];\n            } else {  // is SET\n                  warn.payload = [msg.payload.value.remote+\": TX: SET \" + rmsg.payload.device + \"/\" + rmsg.payload.property , rmsg.payload.value];\n            }\n        } else {\n             if ( rmsg.infodp && (rmsg.infodp.toUpperCase() === \"SCHEMA\")) { // is get schema\n                  warn.payload =  [msg.payload.value.remote+\": TX: GET SCHEMA \" + rmsg.payload.device, msg];\n             } else { // is GET\n                  warn.payload =  msg.payload.value.remote+\": TX: GET \" + rmsg.payload.device+ \"/\" + rmsg.payload.property ;\n                  }\n         }\n         \n        node.send([null, null, warn, null,null]); \n     } // ends SET _system/proxy\n     \n  // continue,  is local\n    if (_isset(msg)) {\n        if ( msg.infodp.toUpperCase() === \"MULTIPLE\") {\n            if (!(cap.includes(\"MULTIPLE\") || cap.includes(\"ALL\"))) {\n                node.warn(\"ERROR: MULTIPLE commands not allowed by the fake '\" + msg.payload.device + \"'\");\n                skipmsg.payload.data.dps[p.dp] = \"ERROR: MULTIPLE not allowed by device\"\n                return [null,null,null,null,skipmsg];\n            }\n            warn.payload = [\"TX: SET MULTIPLE: fake \" + msg.payload.device, msg.payload.value];\n        } else {\n            if (!(cap.includes(\"SET\") || cap.includes(\"ALL\"))) {\n                node.warn(\"ERROR: SET commands not allowed by the fake '\" + msg.payload.device + \"'\");\n                skipmsg.payload.data.dps[p.dp] = \"ERROR: SET not allowed by device\"\n                return [null,null,null,null,skipmsg];\n            }\n            if (! [\"RW\",\"WO\",\"WW\"].includes(capp)){\n                node.warn([\"ERROR: SET commands not allowed by '\" + msg.payload.property + \"'\", msg]);\n                skipmsg.payload.data.dps[p.dp] = \"ERROR: SET not allowed by this DP\"\n                return [null,null,null,null,skipmsg];\n             }\n           warn.payload =[\"TX: SET fake \" + msg.payload.device + \"/\" + msg.payload.property, msg.payload.value];\n        }\n    } else { // a GET\n        if (msg.infodp.toUpperCase() === \"SCHEMA\") { // is get schema\n            if (!(cap.includes(\"SCHEMA\") || cap.includes(\"ALL\"))) {\n                node.warn(\"ERROR: SCHEMA command not allowed by the fake '\" + msg.payload.device + \"'\");\n                skipmsg.payload.data.dps[p.dp] = \"ERROR: SCHEMA not allowed by device\"\n                return [null,null,null,null,skipmsg];\n             }\n            warn.payload = \"TX: GET SCHEMA: fake \" + msg.payload.device ;\n        } else {\n            if (!(cap.includes(\"GET\") || cap.includes(\"ALL\"))) {\n                node.warn(\"ERROR: GET commands not allowed by the fake '\" + msg.payload.device + \"'\");\n                skipmsg.payload.data.dps[p.dp] = \"ERROR: GET not allowed by device\"\n                return [null,null,null,null,skipmsg];\n            }\n            if (![\"RW\",\"RO\",\"GW\",\"WW\"].includes(capp)){\n                node.warn([\"ERROR: GET commands not allowed by '\" + msg.payload.property + \"'\",msg]);\n                skipmsg.payload.data.dps[p.dp] = \"ERROR: GET not allowed by this DP\"\n                return [null,null,null,null,skipmsg];\n             }\n\n             warn.payload = \"TX: GET fake \" + msg.payload.device + \"/\" + msg.payload.property ;\n        }\n      \n    } // ends GET\n\n// node.warn([\"FAKE\",msg,warn, query]);\n// outputs: tuya/fake/info/db/skip\nreturn [null, msg, warn, query, null];\n} //--------------------------- end fake\n\n//====================================== general request\n\nreq[\"toDev\"]   = msg.toDev;\nreq.topic = \"msg for \" + msg.payload.device;\n\nif (cap.includes(\"NONE\")) {\n    node.warn(\"ERROR: GET/SET operations not allowed '\" + msg.payload.device + \"' is not accessible by user.\");\n    return [null];\n}\n\n// TEST for REFRESH\nif(( req.infodp  === \"_refresh\") ||( req.infodp  === \"_fastRate\")) {  // pseudoDP for REFRESH\n       if (!(cap.includes(\"REFRESH\") || cap.includes(\"ALL\"))) {\n           node.warn(\"ERROR: REFRESH not allowed by the '\" + msg.payload.device + \"'\");\n           return [null];\n       }\n}\n// ----------------------- SCHEMA + GET\nif (_isget(msg)) {\n    req.payload.operation = \"GET\";\n    if (msg.infodp.toUpperCase() === \"SCHEMA\") // is get schema\n        if (cap.includes(\"SCHEMA\") || cap.includes(\"ALL\")) {\n            req.payload.schema = true;\n            query.topic = \" INSERT INTO `messages` (`timestamp`, `daemon`, `action`, `device-id`, `device-name`, `dps`, `dp-name` )\";\n            query.topic += \" VALUES ('\" + _mySQLdatetime() + \"','\" + myId + \"', 'TX', '\" + msg.to + \"', '\" + formatName(o.name||o.id) + \"','SCHEMA','SCHEMA') ;\";\n            query[\"payload\"] = {\n                deviceId: msg.to\n            };\n            return ([req, null, {\n                        payload: \"TX: SCHEMA from \" + msg.payload.device ,\n                        to: msg.to,\n                        infodp: msg.infodp,\n                        hide: msg.hide\n                        }, query, null]);\n        } else {\n            node.warn(\"ERROR: SCHEMA command not allowed by the '\" + msg.payload.device + \"'\");\n            return [null, null, null, null, null];\n        } // SCHEMA ends\n    //\n    if (!(cap.includes(\"GET\") || cap.includes(\"ALL\"))) {\n        node.warn(\"ERROR: GET commands not allowed by the '\" + msg.payload.device + \"'\");\n        return [null, null, null, null, null];\n    } \n   req.payload.dps =   msg.infodp;\n} // ----------------- GET ready\n\nif (_isset(msg)) {   //-------------------- MULTIPLE + SET\n    if (msg.infodp.toUpperCase()  === \"MULTIPLE\")\n        if (cap.includes(\"MULTIPLE\") || cap.includes(\"ALL\")) {\n            req.payload.multiple = true;\n            try {\n                if (typeof(msg.payload.value) === 'string')\n                    req.payload.data = JSON.parse(msg.payload.value);\n                else\n                    req.payload.data = msg.payload.value;\n            } catch (error) {\n                node.warn(\"ERROR: MULTIPLE bad value (\" + msg.payload.device + \") \" + error);\n            }\n            //\n            query.topic = \" INSERT INTO `messages` (`timestamp`, `daemon`, `action`,`device-id`, `device-name`, `dps`, `dp-name`, `data`)\";\n            query.topic += \" VALUES ('\" + _mySQLdatetime() + \"', '\" + myId + \"', 'TX', '\" + _getID(o) + \"', '\" + formatName(msg.payload.device) + \"','MULTIPLE','MULTIPLE', '\" + formatData(msg.payload.value) + \"') ;\";\n            query[\"payload\"] = {\n                deviceId: msg.to\n            };\n            return ([req, null, {\n                        payload: [\"TX MULTIPLE: to '\" + msg.payload.device + \"': \", msg.payload.value],\n                        to: req.to,\n                        infodp: req.infodp,\n                        hide: msg.hide\n                     }, query]);\n        } else {\n            node.warn(\"ERROR: MULTIPLE SET not allowed by the '\" + msg.payload.device + \"'\");\n            return [null, null, null, null];\n        } // ------ MULTIPLE ends\n    //\n    if (!(cap.includes(\"SET\") || cap.includes(\"ALL\"))) {\n        node.warn(\"ERROR: SET commands not allowed by the '\" + msg.payload.device + \"'\");\n        return [null, null, null, null];\n    }\n\nreq.payload.dps = msg.infodp.toString(); // dps always string: \"101\" or \"_connected\"\nreq.payload.set = msg.payload.value;\n}  //  --------------------  SET ends\n\n//\nswitch (capp) {\n    //  \"RW,WW,GW,RO,WO,TRG,PUSH,SKIP,UNK,NULL\",\ncase \"UNK\":\ncase \"RW\":  // ok, nothing to do\n     break;\ncase \"PUSH\":\n    node.warn(\"ERROR: Can not SET/GET the 'PUSH' DP '\" + msg.payload.device + '\".\"' + msg.payload.property + \"'\");\n    return [null, null, null, null];\ncase \"RO\":\n    if (_isset(msg)) {\n        node.warn(\"ERROR: Can not SET the Read Only DP '\" + msg.payload.device + '\".\"' + msg.payload.property + \"'\");\n        return [null, null, null, null];\n    }\n    break;\ncase \"WO\":\n    if (_isget(msg)) {\n        node.warn(\"ERROR: Can not GET the 'WO' DP '\" + msg.payload.device + '\".\"' + msg.payload.property + \"'\");\n        return [null, null, null, null];\n        }\n    if (msg.payload.value === null) {\n            node.warn(\"ERROR: Can not use 'SET:null' for 'WO' DP '\" + msg.payload.device + '\".\"' + msg.payload.property + \"'\");\n            return [null, null, null, null];\n        }\n    break;\ncase \"GW\":\n    if (_isset(msg)) {\n        node.warn(\"ERROR: Can not SET the 'GW' DP '\" + msg.payload.device + '\".\"' + msg.payload.property + \"'\");\n        return [null, null, null, null];\n    }\n    // transforms GET in SET:null\n    delete req.payload.operation;\n    req.payload.set = null;\n    break;\ncase \"WW\":\n    if (_isget(msg)) {\n      // transforms GET in SET:null\n      delete req.payload.operation;\n      req.payload.set = null;\n    }\n    break;\ncase \"TRG\":\n    node.warn(\"ERROR: '\" + msg.payload.device + '\".\"' + msg.payload.property + \"' has 'TRG' capability\");\n    return [null, null, null, null];\ncase \"SKIP\":\n  return [null, null, null, null];\ndefault:  \n    node.warn(\"ERROR: unknown capability for '\" + msg.payload.device + '\".\"' + msg.payload.property );\n    return [null, null, null, null];\n}\n\n// outputs: tuya/fake/info/db/logging\n// builds the DB  log\nquery.topic = \" INSERT INTO `messages` (`timestamp`, `daemon`, `action`, `device-id`, `device-name`, `dps`, `dp-name`, `data`, `value`) \";\nquery.topic += \" VALUES ('\" + _mySQLdatetime() + \"','\" + myId + \"', 'TX', '\" + _getID(o) + \"', '\" + formatName(msg.payload.device) + \"','\" + req.payload.dps + \"', '\" + formatName(msg.payload.property) + \"', \" + (_isset(msg) ? \"'\" + formatData(req.payload.set) + \"'\" : \"NULL\") + \", \" + (_isset(msg) ? \"'\" + formatData(uVal) + \"'\" : \"NULL\") + \" );\";\n\n// the warning message\nif (_isset(msg))\n    warn = {\n        payload: [\"TX SET: device \" + msg.payload.device + \"/\" + msg.payload.property, msg.payload.value],\n        to: msg.to,\n        infodp: msg.infodp,\n        hide : msg.hide\n    };\nelse\n    warn = {\n        payload: \"TX GET: device \" + msg.payload.device + \"/\" + msg.payload.property ,\n        to: msg.to,\n        infodp: msg.infodp,\n        hide : msg.hide\n    };\n\nreturn ([req, null, warn, query]);\n",
        "outputs": 5,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 1060,
        "wires": [
            [
                "4b771bf3.b8cef4"
            ],
            [
                "933b14e647ae6e8b"
            ],
            [
                "8792104e.e64d4"
            ],
            [
                "70d88fb4.7fcc2"
            ],
            [
                "3ef151475f89529b"
            ]
        ],
        "outputLabels": [
            "tuya",
            "fake",
            "info",
            "DB",
            "skip"
        ],
        "info": "Standard commands process\n\nsee 'std_cmds' node."
    },
    {
        "id": "2ec83963.a7d146",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "to logging",
        "links": [
            "9fe80f7e.f3f7e"
        ],
        "x": 1465,
        "y": 440,
        "wires": [],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "d4a32280.a4dc8",
        "type": "switch",
        "z": "173260fb.d021ff",
        "name": "*device selector",
        "property": "toDev",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "example1234567",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "example123456789",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "example987654321",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "example456789123",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "example891234567",
                "vt": "str"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 5,
        "x": 880,
        "y": 320,
        "wires": [
            [
                "305e7686.63b0fa"
            ],
            [
                "e543af34.b2468"
            ],
            [
                "ba1d97f9.86c698"
            ],
            [
                "2b66a27e.d6726e"
            ],
            [
                "3d5897cf.378f68"
            ]
        ],
        "info": "CUSTOMIZATION:\n\n- For a new device\n    - Add one output\n    - Add a new rule on 'msg.toDev' property using the deviceID\n    - Wire the new output to new 'tuya-smat-device' node.\n\nsee: [Howto: add a new device to tuyaDAEMON](https://github.com/msillano/tuyaDAEMON/wiki/Howto:-add-a-new-device-to-tuyaDAEMON)\n\nnote:\n -  Installing a new devices, use only the 'static retry' node.\n -  When all ok:\n     - if the device can be disconnected for longtime (e.g. mobile plugs) better to replace it with 'dinamic retry' node.\n     - if  the device can handle the 'REFRESH' command (e.g. AC power meters) you can add the 'REFRESH' node and add `'REFRESH'` to device capabilities in `global.alldevices`.\n\n - Use in 'device selector', 'REFRESH', 'tuya-smarty-device', 'static/dinamic retry' the SAME `deviceID` as in `global.alldevices`.\n \n - The position 1 is reserved to 'tuya_brige' device."
    },
    {
        "id": "8a1da02d.424ae",
        "type": "link in",
        "z": "173260fb.d021ff",
        "name": "std_cmds",
        "links": [
            "0263e3a5d46d04db",
            "02f14df9c251c497",
            "063ac16c1ab07a21",
            "06f244a00e127392",
            "17074ca7131094fa",
            "1782306c.d003c",
            "1e5c8c33.f6d8a4",
            "24aff198b96ec0ad",
            "270607f1.95ddd8",
            "2abb8b42.fb0014",
            "2e0b9f99.da3a5",
            "2ebe64d5.26754c",
            "34ce7f2ba4a63515",
            "4399bd03.cfe4e4",
            "453e1c500837dc6a",
            "4c3dd357f773ca66",
            "5523501e6118834f",
            "58c718a1.bbd748",
            "6ebd4962.eb72d8",
            "71ce8f74737eb46f",
            "78b729bf.554958",
            "7c949bb.9267764",
            "7e4ebbc98423b427",
            "85335530918380f6",
            "881bf4dd.364008",
            "8c48fbd5d8ae76ee",
            "92960929.5eae58",
            "9e7acf3.31b0c3",
            "a838f77b.9166c8",
            "b628aa72daf235de",
            "b741480f.454488",
            "b9792acd4662495b",
            "beb91b.bdf6e6e8",
            "c2eda0a.64cd86",
            "c6eec3b9.38b0b",
            "c7992347510c57a8",
            "ca2310c28ac77341",
            "d05feec8.64e4e",
            "d63884c8548d1deb",
            "de64614.cd6d8a",
            "e59aa8c315e74462",
            "f302b04b.6478b",
            "fb2a9b8.38c9068",
            "fb6126134dca20a3",
            "fbec3d25562e3e2a",
            "fc6aa253.9d063",
            "ffaeb60fe0d1ac58"
        ],
        "x": 180,
        "y": 1060,
        "wires": [
            [
                "c991322e.a484e"
            ]
        ],
        "l": true,
        "info": "Main entry point for tuyaDEAMON commands:\n\nFor a great incapsulation, external application can use only `usr-device-name`, `usr-property-name` and `usr-decoded-data`, as defined by [global.alldevices.](https://github.com/msillano/tuyaDAEMON/wiki/tuyaDAEMOM-global.alldevices) \n\nnote: user-namers can change in any moment, so TuyaDAEMON, extensions, fake devices must use the deviceID, dp, and encoded data.\n\n`msg.payload` for **SET** command (to set a device status or to trigger an action, in this case value MUST exist but it is discarted)\n````\n{  \"remote\"  : undefined|`SVRxxx`,        //  remote tuyaDEAMON ID, optional: see global.remotemap. \n   \"device\"  : `dev-usr`|`cid`|`id`,      //  device-name.\n   \"property\": `dp-usr`|`pseudoDP`|`dp`,  //  propery-name \n   \"value\"   : `any`|`accepted_value` }   //  uncoded value (see alldevice: 'type' and 'typefiel')\n````\n\n`msg.payload` for **GET** command (to get a value asking the device or using last from **global.tuyastatus** ):\n````\n{  \"remote\"  : undefined|`SVRxxx`,        //  remote tuyaDEAMON ID, optional: see global.remotemap. \n   \"device\"  : `dev-usr`|`cid`|`id`,      //  device-name.\n   \"property\": `dp-usr`|`pseudoDP`|`dp`}  //  propery-name \n````\n\n`msg.payload` for **GET schema** command (send to device or get value from **global.tuyastatus** ):\n````\n{  \"remote\"  : undefined|`SVRxxx`,    //  remote tuyaDEAMON ID, optional: see global.remotemap. \n   \"device\"  : `dev-usr`|`cid`|`id` } //  device-name.\n````\n\n`msg.payload` for **device LIST** from a remote tuyaDAEMON instance:\n````\n{  \"remote\"  : `SVRxxx`,              //  remote tuyaDEAMON ID: see global.remotemap. \n````\n\n`msg.payload` for **SET multiple** command (_deprecated because uses dps index and coded data_):\n````\n{  \"remote\"  : undefined|`SVRxxx`,       //  remote tuyaDEAMON ID, optional: see global.remotemap. \n   \"device\"  : `dev-usr`|`cid`|`id`,     //  device-name.\n   \"property\": `MULTIPLE`,               //  pseudoOP\n   \"value\"   : {dp1:val1, dp2:val2...}}  //  coded values \n````\n\n\n**Commands handling**\nOthers CORE INPUT nodes: \n   -  'fast_cmds'    (no logTX, std msg), \n   -  'fake_cmds_IN' (no logTX, normalized msg),\n   -  'low_level_in' (no logTX, native device msg + pseudoDP), \n   -  'share_in'     (no logTX, share msg).\n\n\n"
    },
    {
        "id": "cff32cc3.68b48",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "OUT msg process",
        "info": "_tuyaDAEMON process chain for messages coming from all device._\n\nInput: msg from any `smart-tuya-device` node or from 'fake' devices or internally generated.\n\nOuput: \n  - the global.tuyastatus object is updated.\n  - a log of every received data is stored in the 'messages' DB table.\n  - info, trace and warning messages are output on the debug pad.\n  \nThe user can control the info and trace messages and select the stored records.",
        "x": 190,
        "y": 1120,
        "wires": []
    },
    {
        "id": "305e7686.63b0fa",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "to triggers.tuya_bridge_IN",
        "mode": "link",
        "links": [
            "69321d9a.30b7d4"
        ],
        "x": 1045,
        "y": 240,
        "wires": [],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "bc933c53.b4bd9",
        "type": "debug",
        "z": "173260fb.d021ff",
        "d": true,
        "name": "*trace: msg OUT from all devices",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1840,
        "y": 1220,
        "wires": [],
        "info": "CUSTOMIZATION\n\n- Enable to see in the debug pad all msg sended from all devices.\n- Normal use: disabled"
    },
    {
        "id": "b25c688d.705df8",
        "type": "link in",
        "z": "173260fb.d021ff",
        "name": "low_level_IN",
        "links": [
            "3a1df4f8.435cec",
            "756a073a.e295b8"
        ],
        "x": 250,
        "y": 820,
        "wires": [
            [
                "4b771bf3.b8cef4"
            ]
        ],
        "l": true,
        "info": "Low level entry point, payload is send directly to local `tuya-smart-device` node, no log. \nFor Internal use for test, extensions etc.\n\nIN device messages (commands), Tuay protocol, modified:\n \n SET single,\n ````\n      {\n      \"toDev\":\"60a823fffe****\",     // tuyaDAEMON extrension: deviceID|gatewayID\n      \"payload\": {\n          \"devId\": \"60a453fffe*****\",  // cid, only for virtual devices (string)   \n          \"dps\":\"103\",                                // DP or pseudoDP (string)\n          \"set\":220                                 // BOOLEAN, INT/ENUM, STRING   \n          } }\n````\n SET multiple\n````\n      {\n      \"toDev\":\"60a823fff*****\",    // tuyaDAEMON extrension: deviceID/gatewayID\n      \"payload\": {\n          \"devId\": \"60a453fffe******\",         //cid, only if toDev = gatewayID\n          \"multiple\":true,\n          \"data\": {                 \n             \"103\":220,                                     // dps:value (many)\n             ....\n             } } }\n````\n\n GET single\n````\n      {\n      \"toDev\":\"60a823fff******\",   // tuyaDAEMON extrension: deviceID/gatewayID\n      \"payload\": {\n          \"devId\": \"60a453fffe******\",         //cid, only if toDev = gatewayID\n          \"operation\":\"GET\",\n          \"dps\":\"103\"\n          } }\n````\nGET schema\n````\n      {\n      \"to\":\"60a823fff******\",      // tuyaDAEMON extrension: deviceID/gatewayID\n      \"payload\": {\n          \"devId\": \"60a453fffe******\",         //cid, only if toDev = gatewayID\n          \"operation\":\"GET\",\n          \"schema\"=true\n          } }\n````\n-----------------------------------------\nsice 2.2.0:\nnew commands for 'tuya-smart-device' node:\n\n CONNECTION operations (_standby)\n  \n In tuyadDAEMON is implemented as a pseudoDP:  see \"pseudo DPs\" node.\n The pseudoDP are handled as standard native device DPS, but a node acts as adapter before post it to a device.\n Valid for all real devices using tuya-smart-devices node.\n````\n  tuyaDAEMON extrension:  (only SET)\n     {\n      \"toDev\":\"60a823fffe****\",     // tuyaDAEMON extrension: deviceID|gatewayID\n      \"payload\": {\n          \"devId\": \"60a453fffe*****\",   // cid, only for virtual devices (string)   \n          \"dps\":\"_standby\",                                           // pseudoDP    \n          \"set\": true|false|\"ON\"|\"OFF\"                         // BOOLEAN, STRING   \n          } }\n\n    native: [see here](https://github.com/vinodsr/node-red-contrib-tuya-smart-device)\n     {\n     \"toDev\":\"60a823fffe****\",      // tuyaDAEMON extrension: deviceID|gatewayID\n     \"payload\": {\n          \"operation\": \"CONTROL\",       \n          \"action\": \"CONNECT\"                    // or \"DISCONNECT\". \"RECONNECTS\"\n          }}\n````          \n TIMEOUT operations (_findTimeout & _retyTimeout)   \n \n In tuyadDAEMON implemented as two pseudoDP: _findTimeout & _retyTimeout. See \"pseudo DPs\" node. \n Also used in the implementation of \"dynamic rety\" node.\n Valid for all real devices using tuya-smart-devices node.\n````\n tuyaDAEMON extrension:   (only SET)\n     {\n      \"toDev\":\"60a823fffe****\",     // tuyaDAEMON extrension: deviceID|gatewayID\n      \"payload\": {\n          \"devId\": \"60a453fffe*****\",   // cid, only for virtual devices (string)   \n          \"dps\":\"_findTimeout\"|\"_retyTimeout\",                      // pseudoDP    \n          \"set\": 2000                                            // timeout in ms   \n          } }\n         \n          \n  native: [see here](https://github.com/vinodsr/node-red-contrib-tuya-smart-device)\n      {\n      \"to\":\"60a823fff******\",      // tuyaDAEMON extrension: deviceID/gatewayID\n      \"payload\": {\n         \"operation\": \"CONTROL\",       \n         \"action\": \"SET_RETY_TIMEOUT\"                 // or  \"SET_FIND_TIMEOUT\"\n         \"value\": number                                      // timeout in ms\n          }}\n````\n        \n new operation for tuya devices:\n [see](https://codetheweb.github.io/tuyapi/index.html#tuyadevice)\n \n REFRESH operation _refresh & _refreshCycle \n \n  In tuyadDAEMON implemented as two  pseudoDP: _refresh & _refreshCycle  see \"REFRESH\" subflow. \n   \n  Valid for a few real devices that use the tuya-smart-device node and implement REFRESH.\n note: usable only with devices that have a REFRESH node in the CORE flow and the 'REFRESH' capability in global.alldevices. \n Consider it an optional feature: it can be added at a later time.\n````\n tuyaDAEMON extrension:  (only SET)\n     {\n      \"toDev\":\"60a823fffe****\",      // tuyaDAEMON extrension: deviceID|gatewayID\n      \"payload\": {\n          \"devId\": \"60a453fffe*****\",   // cid, only for virtual devices (string)   \n          \"dps\":\"_refresh\",                        // pseudoDP: immediare command    \n          \"set\": any            // required but not used: the SET acts as trigger  \n          } }\n         \ntuyaDAEMON extrension:  (only SET)\n     {\n      \"toDev\":\"60a823fffe****\",     // tuyaDAEMON extrension: deviceID|gatewayID\n      \"payload\": {\n          \"devId\": \"60a453fffe*****\",   // cid, only for virtual devices (string)   \n          \"dps\":_refreshCycle\",                                       // pseudoDP    \n          \"set\": NUM(rate)| false|\"OFF\"                    // ON (rate in s)| OFF   \n          } }\n         \n\nnative: [see here](https://codetheweb.github.io/tuyapi/index.html#tuyadevice)\n      {\n      \"toDev\":\"60a823fffe****\",     // tuyaDAEMON extrension: deviceID|gatewayID\n      \"payload\": { \n         \"devId\": \"60a453fffe*****\",   // cid, only for virtual devices (string)   \n         \"operation\": \"REFRESH\",           // usually used alone or with one of:\n           \"dps\": undefined|dp,                             //refreshs only a dp\n           \"requestedDPS\":[1,9,6,17,18,19,20],               // refresh a dp set\n           \"schema\":true                                      // refresh all dps\n          }}\n````\n  \n\n"
    },
    {
        "id": "4854987c.2fea88",
        "type": "subflow:ee953c15.ada29",
        "z": "173260fb.d021ff",
        "name": "",
        "env": [
            {
                "name": "deviceId",
                "value": "example123456789",
                "type": "str"
            }
        ],
        "x": 1520,
        "y": 260,
        "wires": [
            [
                "81103bac.696bc8"
            ]
        ],
        "info": "CUSTOMIZATION\n\n- duplicate for any new device alltime connected\n- set properties: deviceID.\n\nfor more info: see \"*device selector\" node documentation."
    },
    {
        "id": "d62f5a18.fe10b8",
        "type": "debug",
        "z": "173260fb.d021ff",
        "name": "tuyaDAEMON.core",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 1240,
        "wires": []
    },
    {
        "id": "154e84b8.8c7b0b",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "Debug pad trace",
        "info": "COSTOMIZATION:\n\n - Disable unwonted trace nodes.\n \n - Warn/ERROR messages are alway sended.\n \n \n \n",
        "x": 1780,
        "y": 1260,
        "wires": []
    },
    {
        "id": "4170e71.70b8518",
        "type": "file",
        "z": "173260fb.d021ff",
        "name": "",
        "filename": "",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "true",
        "encoding": "utf8",
        "x": 420,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "7a540832.656648",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "EXPORT alldevices,json",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "filename",
                "v": "$flowContext(\"alldevice_file_path\")&\"\\\\alldevices.\"&$flowContext(\"instance_name\")&\".json\"",
                "vt": "jsonata"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "$globalContext(\"alldevices\")\t",
        "payloadType": "jsonata",
        "x": 210,
        "y": 320,
        "wires": [
            [
                "4170e71.70b8518"
            ]
        ],
        "info": "Command to export a file 'alldevices.json'.\nnote: the output path is defined in 'global CORE config' node."
    },
    {
        "id": "81a9b329.092b1",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "low_level_OUT",
        "links": [
            "3baeae11.41ef52",
            "5ba61f43.db9b9",
            "52af620f.a7e1cc",
            "fcc442c5.729a3",
            "e11a7cec.3edf2"
        ],
        "x": 760,
        "y": 1240,
        "wires": [],
        "l": true,
        "info": "Low level output, all messages as sended by devices.\n\nThe messages are unprocessed, directly from `tuya-smart-device` node. \n\n_Used by_:  `tuyaTRIGGERS.'event trigger'` node\n\n_See also_: `'to logging'` input link node for the OUT msg structure.\n\nOUT msg structures:\n\nexample: msg (real)\n ````\n        {\n        _msgid: \"12342f3fd.8697fc\"\n        _event: \"node:12343963.a7d846\"\n        payload: object\n           deviceId: \"123455aa196ae5975cy6ii\"\n           deviceName: \"*tuya_bridge\" \n           data: object\n              t: 1609234903  // timestamp, in seconds.\n              dps: object\n                 102: 1020   // array of dp:value\n        }\n```` \n\nexample msg: (virtual)\n````\n        {\n        _msgid: \"12346a44.e81238\"\n        payload: object\n           deviceId: \"123473b1b789b4994cro7p\"\n           deviceName: \"Zigbee Gateway\"\n           data: object\n              cid: \"12348d00856a1c15\"\n              t: 1609235292\n              dps: object\n                 102: 1020   // array of dp:value\n        }             \n````\n"
    },
    {
        "id": "f9a629eb.f4f498",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "tuyaDAEMON CORE 2.2.0",
        "info": "\n",
        "x": 210,
        "y": 80,
        "wires": []
    },
    {
        "id": "81103bac.696bc8",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "all: filter&update ",
        "func": "// this node processes \"_connected\" event:\n//   - filters duplicated msgs\n//   - updates the global.tuyastatus\n//   - sends message to logging. \n//  note: logging processes for dp '_connected' is special: \n//    the 'dp' '_connected' it is not required in alldevices.\n//  You can add to some devices the dp='_connected' \n//    for special processing, e.g. 'share'.\n\n\ntuyastatus = global.get(\"tuyastatus\");\nif (tuyastatus === undefined) return null;\n\n// local functions:\nvar CONN = \"_connected\";\n// access key\nvar oDev =    context.global.alldevices.getODev(msg.payload.deviceId, \"real\");\nif (oDev === undefined) return null;\nvar dname =   context.global.alldevices.getDevName(oDev);\nvar usrCon =  context.global.alldevices.getDpsName(oDev, CONN);\n// testing:\nif( tuyastatus[dname] === undefined) tuyastatus[dname] = {};\nvar xdev = tuyastatus[dname];\nvar oldconnected = xdev[usrCon];\nvar nowconnected = msg.payload.data.dps._connected;\nif (nowconnected !== oldconnected) {\n        xdev[usrCon] = nowconnected;\n        global.set(\"tuyastatus\", tuyastatus);\n        return (msg);\n    }\nreturn (null);\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1850,
        "y": 300,
        "wires": [
            [
                "edf84736.d76338"
            ]
        ]
    },
    {
        "id": "2caa595d.2a0106",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "Info events filter",
        "func": "// kills unwanted tuyaDEAMON EVENTS messages & MQTT\n\n// some ASSERT, just in case...\nif((typeof(msg.to) !== \"string\") && (typeof(msg.from) !== \"string\") )\n         node.warn([\"ASSERT fail: in msg the to/from (string) must exist.\", msg]) ;   \nif(typeof(msg.infodp) !== \"string\")\n         node.warn([\"ASSERT fail: in msg the msg.infodp (string) must exist.\" , msg]) ;   \n// from 2.2.0\nif(typeof(msg.hide) !== \"string\")\n         node.warn([\"ASSERT fail: in msg the msg.hide (string) must exist.\" , msg]) ;   \n\n// ==================== KILL EVENT debug + MQTT:  SYSTEM defined (can be updated)\nswitch (msg.from){    \n   case \"_system\":\n        if (msg.infodp === \"_proxy\")     return(null);   //  TRG internal use: REMOTE commands \n        if (msg.infodp === \"_toLogging\") return(null);   //  internal use: REST remote echo\n        if (msg.infodp === \"_zeroTask\")  return(null);   //  by definition: fast benchmarks\n        break;\n}\n\n// =================== KILL EVENY debug + MQTT: user defined in alldevices\nif ((!!~msg.hide.indexOf(\"E\")) || (!!~msg.hide.indexOf(\"K\")))\n            return null; // killed\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 1300,
        "wires": [
            [
                "d62f5a18.fe10b8",
                "9fe75b23.a05408"
            ]
        ],
        "icon": "font-awesome/fa-filter",
        "info": "CUSTOMIZATION:\n\nFilter to reduce info messages on Debug pad.\n\nFiltering action is done usually by the 'hide' device/dp property, under user control.\nSome cases are done by this code, to force default behavior.\n\n- On installation and test:\n  Best don't filter any message.\n- On production:\n  Better to filter not useful events.\n\n_________________________________\n  \nIn code, filter can be done on: \n       msg.from:            RX info, the deviceId\n       msg.to:              TX info, the deviceId\n       msg.infodp:          the dpId          \n"
    },
    {
        "id": "c90b7eb2.07595",
        "type": "link in",
        "z": "173260fb.d021ff",
        "name": "more_devices_IN",
        "links": [
            "4fb32195.592ef",
            "63e6d5d.0a5da2c"
        ],
        "x": 1575,
        "y": 180,
        "wires": [
            [
                "81103bac.696bc8"
            ]
        ],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "70d88fb4.7fcc2",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "*DB command filter",
        "func": "// CUSTOMIZATION\n\n// to filter and route data to 0..n DB, for logging (TX) or execute sql commands\n// Default using 2 DB:  'local' and 'remote'.\n// 3 outputs: local, no log (for TX and RX events)/ locale + log(for sqlDBlocal)/remote + log(for sqlDBremote)\n\n// Some assert, just in case.....\nif(typeof(msg.to) !== \"string\" )\n         node.warn([\"ASSERT fail: in msg the msg.to (string) must exist.\", msg]) ;   \nif(typeof(msg.infodp) !== \"string\")\n         node.warn([\"ASSERT fail: in msg the msg.infodp (string) must exist.\" , msg]) ;   \nif(typeof(msg.topic) !== \"string\")\n         node.warn([\"ASSERT fail: in msg the msg.topic (sql string) must exist.\" , msg]) ;   \n// from 2.2.0\nif(typeof(msg.hide) !== \"string\")\n         node.warn([\"ASSERT fail: in msg the msg.hide (string) must exist.\" , msg]) ;   \n\n// ==================== KILL OR ROUTE DBASE commands: SYSTEM defined \nswitch (msg.to){                      \n    case \"_dbase\":                       \n// ==============  HERE select the ROUTE for 2 SQLdbase commands:\n// CUSTOMIZE here: new _sqlDBxxx _system properties, new outputs, new database nodes\n       if (msg.infodp === \"_sqlDBlocal\")\n                 return [null, msg];          // to local  execute output\n       if (msg.infodp === \"_sqlDBremote\") \n                 return [null, null, msg];    // to remote execute output\n       break;                 \n    case \"_system\":                       \n// KILL log record:                 \n       if (msg.infodp === \"_proxy\")     return(null);    //  internal use: REMOTE commands\n       if (msg.infodp === \"_toLogging\") return([null]);  //  internal: uses REST remote echo\n       if (msg.infodp === \"_zeroTask\")  return([null]);  //  fast benchmarks, killed\n       break;\n}\n\n// ================== KILL OR ROUTE DBASE command record:  user defined in alldevices\nif ((!!~msg.hide.indexOf(\"T\")) || (!!~msg.hide.indexOf(\"K\"))) return null;      // killed\n\n// =================== here optional routing code\n//  --- default one output for all command records, no routing\nreturn [msg];  // defaut: local, no-log",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1190,
        "y": 1420,
        "wires": [
            [
                "74205825.bd5e98"
            ],
            [
                "1a711832.f93bb8"
            ],
            [
                "46a8112c.cdbcf"
            ]
        ],
        "outputLabels": [
            " local command",
            " remote command",
            "log to local"
        ],
        "icon": "font-awesome/fa-filter",
        "info": "\nCUSTOMIZATION:\n\n1) To kill all DB record for a device or dp (better to use the \"hide\" property in global.alldevices)\n2) To route commands in more than one DB\n3) To implement new commands to use more than two DB.\n\nnote: this NOT requires _system, but it implements some features\n    required by _system, processing \"_sqlBDxxxx\" commands.\n\n- update the code for any change in  _system \"_sqlBDxxxx\" commands. "
    },
    {
        "id": "edf84736.d76338",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "to system.conn_ev_IN",
        "mode": "link",
        "links": [
            "5ff0742e.cec73c",
            "9fe80f7e.f3f7e"
        ],
        "x": 1995,
        "y": 300,
        "wires": [],
        "icon": "font-awesome/fa-expand",
        "info": "TRIGGER internal/external.\n\nFired at any change of devices connection status.\nThis event is logged and fires an update of AC/LAN/AC properties in _system"
    },
    {
        "id": "5777b120.3dc3e",
        "type": "delay",
        "z": "173260fb.d021ff",
        "name": "",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "30",
        "nbRateUnits": "10",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 660,
        "y": 320,
        "wires": [
            [
                "d4a32280.a4dc8",
                "946d7931.c2a828"
            ]
        ],
        "info": "limit throughput, but allows smooth operations and less connection problems\n\nnote: node not usable for fast rates: internal delay limit about 690/10s"
    },
    {
        "id": "d6f44262.bcd7",
        "type": "status",
        "z": "173260fb.d021ff",
        "name": "*All DB status",
        "scope": [
            "1a711832.f93bb8",
            "74205825.bd5e98",
            "46a8112c.cdbcf"
        ],
        "x": 1170,
        "y": 1580,
        "wires": [
            [
                "5251eb56272b7ed2"
            ]
        ],
        "info": "CUSTOMIZATION:\n\nAdd here all DB node used (now 3)\n"
    },
    {
        "id": "b9b5886c.153d98",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "DB check",
        "func": "// checks DB status\n// version 1.1 (use of _call_library)\n// ===================================== do not change\nPDB = \"_DBase\";\n//\nfunction _sendOUT(key, value) {\n    // builds a fake OUT message\n    var newMsg = {\n        \"payload\": {\n            \"deviceId\": \"_core\",\n            \"data\": {\n                \"dps\": {\n                    [key]: value\n                }\n            }\n        }\n    };\n    return newMsg;\n}\n\n// ---------------- main\n// catch bad\nif (msg.status === undefined) return null;\n//\nif(msg.status.text === undefined) return(null);\n//\nvar olddb =flow.get(PDB);\nvar newdb = ((msg.status.text == \"connected\") || (msg.status.text == \"OK\"));\nif  (olddb == newdb) return null;\n//\nflow.set(PDB, newdb);\n//\nif(newdb) {\n    node.status({\n        fill: \"green\",\n        shape: \"ring\",\n        text: \"DB connected\"\n    });\n    return (_sendOUT(PDB, true));\n} else {\n    node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"DB disconnected\"\n    });\n    return (_sendOUT(PDB, false));\n}\nreturn null;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "\nPDB = \"_DBase\";\n\nnode.status({\n    fill: \"yellow\",\n    shape: \"dot\",\n    text: \"start\"\n});\nflow.set(PDB, \"new\");\n",
        "finalize": "",
        "libs": [],
        "x": 1760,
        "y": 1580,
        "wires": [
            [
                "d6451e16.628bb",
                "e32fa2db.d0b7c"
            ]
        ]
    },
    {
        "id": "d6451e16.628bb",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "DB_ALARM",
        "mode": "link",
        "links": [],
        "x": 1950,
        "y": 1580,
        "wires": [],
        "l": true,
        "info": "TRIGGER for user flows (actually not used by tuyaDAEMON).\n\nFired at any DN status change. "
    },
    {
        "id": "181b544f.5bb98c",
        "type": "http in",
        "z": "173260fb.d021ff",
        "name": "REST tuyaDAEMON",
        "url": "/tuyaDAEMON",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 1440,
        "wires": [
            [
                "6fe3ccb.d4ab534"
            ]
        ]
    },
    {
        "id": "e166ce71.eb209",
        "type": "change",
        "z": "173260fb.d021ff",
        "name": "Set Headers",
        "rules": [
            {
                "t": "set",
                "p": "headers",
                "pt": "msg",
                "to": "{}",
                "tot": "json"
            },
            {
                "t": "set",
                "p": "headers.content-type",
                "pt": "msg",
                "to": "application/json",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 970,
        "y": 1520,
        "wires": [
            [
                "834eb8f4.e36dd8"
            ]
        ]
    },
    {
        "id": "834eb8f4.e36dd8",
        "type": "http response",
        "z": "173260fb.d021ff",
        "name": "HTTP response",
        "statusCode": "",
        "headers": {},
        "x": 1180,
        "y": 1520,
        "wires": []
    },
    {
        "id": "6fe3ccb.d4ab534",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "interface",
        "func": "//  for applications, fast processing, immediate answer.... \n//  Return JSON; data or status.\n//  GET, SCHEMA: solved from tuyastaus, returns data (not stored in log)\n//  SET, MULTIPLE: sended to tuyaDEAMON, returns 'status:sended' (stored in log)\n//-------------------------------- local functions:\n\nvar comm = {};\nvar tuyastatus = global.get(\"tuyastatus\");\nvar myId = global.get(\"instance_name\");\n\n\n if (msg.payload && !(msg.payload.remote_from ))\n     msg.payload.remote_from = myId;\n\n delete msg.payload.remote;\n\n\n\n// some messages are resolved here:\n// ----------- is LIST\nif (!msg.payload.device ){     // devices list immediate\n             if (tuyastatus !== undefined) \n                 msg.payload[\"list\"] = Object.keys(tuyastatus);\n             msg.payload[\"remote_from\"] = myId; \n             let jdat2 = JSON.stringify(msg.payload);\n             msg.payload = jdat2;\n             return ([msg, null]);\n       }\n\n// -----------------------  struff: msg normalization\n    var o = context.global.alldevices.getODev(msg.payload.device);\n    var p = context.global.alldevices.getODps(o, msg.payload.property);\n    msg   = context.global.alldevices.normalize(msg, o, p);\n    if (msg.error){\n        node.warn([\"[REST] \"+msg.error, msg]);\n        return([msg, null]);\n    }\n    if (msg.warning){\n        node.warn([\"[REST] \"+msg.warning, msg,o,p]);\n    }\n  \n// node.warn([\"msg normalized \",msg]) ;\n  comm.to = msg.to;\n  comm.infodp = msg.infodp;\n  comm['payload'] = msg.payload;\n  // msg.payload.value  string or JSON or null\n  try { \n      comm.payload.value = JSON.parse( msg.payload.value);\n  } catch(e) {\n      comm.payload.value = (msg.payload.value)?msg.payload.value: undefined;\n  }\n// ----------- is device SCHEMA\nif (msg.infodp === \"schema\") { // ok device field\n  //----- is SCHEMA\n         msg.payload['schema'] = tuyastatus[msg.payload.device];\n         delete(msg.payload.schema._t);\n         msg.payload[\"remote_from\"] = myId; \n// stringify         \n         let jdat2 = JSON.stringify(msg.payload);\n         msg.payload = jdat2;\n         return ([msg, null]);\n  }\n  \n //  node.warn([\"Trace general remote\",msg]);\n\n// general case:  \n// -------- is GET, read data from tuyastatus\nif (msg.payload.value === undefined) {\n  msg.payload[\"remote_from\"] = myId; \n  if (tuyastatus[msg.payload.device][msg.payload.property] !== undefined)  { \n         let connected = tuyastatus[msg.payload.device][\"_connected\"];\n         if(connected)\n             msg.payload['value'] = tuyastatus[msg.payload.device][msg.payload.property];\n          else\n             msg.payload['value'] =\"disconnected\";\n         let jdat2 = JSON.stringify(msg.payload);\n         msg.payload = jdat2;\n         return ([msg, null]);\n         } else {\n         msg.payload['value'] = \"none\";\n         let jdat2 = JSON.stringify(msg.payload);\n         msg.payload = jdat2;\n         return ([msg, null]);\n         }\n} // end GET\n\n//--------- is SET, MULTIPLE, process it\nlet pseudoDP = context.global.PSEUDODP.includes(msg.infodp.toUpperCase());\nif  (((p !== undefined) || pseudoDP) && (msg.payload.value !== undefined)) { \n     node.send([null, comm]);  // to do cmd\n     delete msg.payload.value;\n     msg.payload['status'] =  \"sent\";\n     let jdat2 = JSON.stringify(msg.payload);\n     msg.payload = jdat2;\n     return [msg, null, comm];  // to rest, to notify\n} // end SET\n\nreturn [msg, null];\n\n\n",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 1440,
        "wires": [
            [
                "e166ce71.eb209"
            ],
            [
                "58c718a1.bbd748"
            ],
            [
                "f1edf094.cfc34"
            ]
        ]
    },
    {
        "id": "58c718a1.bbd748",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "to std_cmd",
        "mode": "link",
        "links": [
            "8a1da02d.424ae"
        ],
        "x": 765,
        "y": 1520,
        "wires": [],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "b1eb4c66.e29de",
        "type": "http in",
        "z": "173260fb.d021ff",
        "name": "REST tuyaDAEMONdebug",
        "url": "/tuyaDAEMONdebug",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 230,
        "y": 1580,
        "wires": [
            [
                "65eb2aa.067dfd4"
            ]
        ]
    },
    {
        "id": "65eb2aa.067dfd4",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "rest_automata",
        "func": "\n//  for debug, all request sended to devices,\n//  asyncronous, wait device answer or timout (set here and in external trigger node)\n//  Return JSON, data or status.\nvar timeout = 4; // in sec, less than 'REST timeout'  node\nvar restautoma = flow.get('restautoma');\nswitch (restautoma) {\ncase '_wait':\n   if ((msg.req !== undefined) && (msg.payload !== undefined))  { // HTTP message\n      if (msg.payload.device === undefined){     // back devices list immediate\n              // immediate answer\n             msg.payload = [];\n             var tuyastatus = global.get(\"tuyastatus\");\n             if (tuyastatus !== undefined) \n                 msg.payload = Object.keys(tuyastatus);\n            return ([null, msg]);\n       } else {            // send request, set timeout\n        var comm = {};\n        comm['payload'] = msg.payload;\n        flow.set('restautoma', msg);\n        flow.set('restt', Math.floor(Date.now() / 1000));\n          // msg.payload.value  string or JSON or null\n        try { \n            comm.payload.value = JSON.parse( msg.payload.value);\n        } catch(e) {\n           comm.payload.value = (msg.payload.value)?msg.payload.value: undefined;\n        }\n        return ([comm, null]);\n      }\n   }\n\n   break;\ndefault:\n//  node.warn(\"in default\");\n   // uses payload.info in info messages\n   if (msg.info !== undefined)  {\n       if ((typeof restautoma === 'object') && (restautoma.req !== undefined) && (restautoma.payload.device !== undefined)){\n //        node.warn([\"from REST automa default\",restautoma, msg]);\n         if (restautoma.payload.device === msg.info.device){\n          if ((restautoma.payload.property === undefined)&& (restautoma.payload.value === undefined)) {  // is schema, ok\n         // schema processing from tuyasatus\n                  let tuystatus = global.get(\"tuyastatus\");\n                  let xschema = tuystatus[restautoma.payload.device];\n                  delete(xschema._t);\n                  restautoma.payload = JSON.stringify(xschema);\n                  flow.set('restautoma', '_wait');  // done\n                  return ([null, restautoma]);\n          }\n           if ((restautoma.payload.property == msg.info.property) || (restautoma.payload.property == msg.infodp) || (restautoma.payload.property === 'MULTIPLE')) {\n             var jdat = JSON.stringify(msg.info);\n             restautoma.payload = jdat;\n             flow.set('restautoma', '_wait');\n             return ([null, restautoma]);\n            }\n         }\n       }\n   }\n\n}\n\n// test timeout, if not wait\n\nif (restautoma !== '_wait') {\n//  node.warn(\"in timeout\");\n    var start = flow.get('restt');\n    if (((Math.floor(Date.now() / 1000)) - start) > timeout) { // OK exit for timeout\n        flow.set('restautoma', '_wait');\n        if ((typeof restautoma === 'object') && (restautoma.req !== undefined)) {  \n           restautoma.payload = { \"status\": \"request aborted for timeout\" };\n           return ([null, restautoma]);\n           }\n    }\n}\n\n//noting to do\nreturn ([null, null]);\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "// Code added here will be run once\n// whenever the node is deployed.\n flow.set ('restautoma', \"_wait\");",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 1580,
        "wires": [
            [
                "58c718a1.bbd748",
                "f6a0c8d.8dbb038"
            ],
            [
                "e166ce71.eb209"
            ]
        ]
    },
    {
        "id": "f6a0c8d.8dbb038",
        "type": "trigger",
        "z": "173260fb.d021ff",
        "name": "REST timeout 5s",
        "op1": "test",
        "op2": "test answer timeout",
        "op1type": "str",
        "op2type": "str",
        "duration": "6",
        "extend": false,
        "overrideDelay": false,
        "units": "s",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 790,
        "y": 1620,
        "wires": [
            [
                "65eb2aa.067dfd4"
            ]
        ]
    },
    {
        "id": "2e4937fc.2ef1f8",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "event OUT",
        "links": [
            "b8e273f8.d51a7"
        ],
        "x": 915,
        "y": 1240,
        "wires": [],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "60906ab.8e27094",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "REST HTTP",
        "info": "The **tuyaDAEMOM REST** is implemented using two interfaces, for different pourposes.\n\n1) **/tuyaDEAMON:** this is the production interface, always fast.\n\n2) **/tuyaDEAMONdebug:** this is the development interface, waits the device answer.\n\nsee https://github.com/msillano/tuyaDAEMON/wiki/tuyaDAEMON-REST\nFor examples: see test nodes.",
        "x": 170,
        "y": 1380,
        "wires": []
    },
    {
        "id": "d943c0e6.b7946",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "check and kill devices",
        "func": "// Test msg.\n// if 'hide' contains 'K' destroy (not on tuyastatus +)\n\n// ------------- check for ALL answers\n//input: device OUT msg (real)\n//  _msgid: \"1234f3fd.8477fc\"\n//  _event: \"node:1233963.a7d146\"\n//  payload: object\n//     deviceId: \"123455aa196ae5******\"\n//     deviceName: \"*tuya_bridge\" (tuya-node name, optional, not used)\n//     data: object\n//        t: 1609234903\n//        dps: object\n//           102: 1020\n//\n//input: device OUT msg (virtual)\n//   _msgid: \"d0b26a44.e81738\"\n//   payload: object\n//      deviceId: \"123473b1b786b59*******\"\n//      deviceName: \"Zigbee Gateway\"\n//      data: object\n//        cid: \"12358d00086a1c45\"\n//        t: 1609235292\n//        dps: object\n//           103: 19\n//\n\n\nfunction getDeviceHide( id){\n  var oDev = context.global.alldevices.getODev(id);\n  if (!(oDev)) return \"\";\n  var mask = (oDev.hide || \"\");\n  var  oDP = context.global.alldevices.getODps(oDev, msg.payload.property);\n  if (!(oDP)) return (mask);\n  mask += (oDP.hide || \"\");\n  return (mask);\n }\n\n//  detects some fatal errors in input message structure, here for convenience\nif (!(msg.payload.deviceId ))  {\n   node.warn([\"ASSERT fail: in the answer the payload.deviceId must be defined.\", msg]) ;   \n   return null;\n}\n\nif (!(msg.payload.data)) {\n    node.warn([\"ASSERT fail: in the answer the payload.data is mandatory\", msg]);\n    return null;\n}\n// Add the 'hide' string an Kills devices\nmsg.hide = getDeviceHide( msg.payload.data.cid || msg.payload.deviceId, );\nif (!!~msg.hide.indexOf(\"K\")) return null;\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "\n\n\n",
        "finalize": "\n",
        "libs": [],
        "x": 540,
        "y": 1320,
        "wires": [
            [
                "a878b58e.e4ea08",
                "bc933c53.b4bd9"
            ]
        ],
        "info": "CUSTOMIZATION:\n\nTo filter the device responses (no INFO, no record in DB, no share action)\n_________________________________\n  \nSee the example filter:\n \nTest can be done on \n       msg.payload.deviceID:   the deviceId or gatewayId\n       msg.payload.data.cid:   the virtual device cid\n \n "
    },
    {
        "id": "de4b43ad.27e31",
        "type": "catch",
        "z": "173260fb.d021ff",
        "name": "*catch device and LAN errors",
        "scope": [
            "e543af34.b2468",
            "ba1d97f9.86c698",
            "a0d5012f.b2551",
            "cb0e33e6.f0a6b"
        ],
        "uncaught": false,
        "x": 1580,
        "y": 600,
        "wires": [
            []
        ],
        "info": "CUSTOMIZATION:\n\n- Adding a new device\n    Select the new tuya-smart-device node.\n    This intercept the 'default' error processing,"
    },
    {
        "id": "e16b895d.8992a8",
        "type": "config",
        "z": "173260fb.d021ff",
        "name": "Global CORE config ",
        "properties": [
            {
                "p": "alldevices",
                "pt": "global",
                "to": "{\"real\":[{\"id\":\"example1234567\",\"name\":\"tuya_bridge\",\"device\":\"switch-1CH\",\"power\":\"UPS\",\"dps\":[{\"dp\":1,\"name\":\"relay\",\"capability\":\"WW\",\"typefield\":\"BOOLEANONOFF\"},{\"dp\":7,\"name\":\"trigger (reserved)\",\"capability\":\"TRG\",\"type\":\"int\",\"comment_01\":\"Values: 0..86500 s  (24H max.)\"},{\"dp\":14,\"name\":\"restart status\",\"capability\":\"WW\",\"type\":\"string\",\"comment_01\":\"Values: off|on|memory\"},{\"dp\":15,\"name\":\"light mode\",\"capability\":\"WW\",\"type\":\"string\",\"comment_01\":\"Values: pos|none|relay\"},{\"dp\":16,\"name\":\"backlight\",\"capability\":\"WW\",\"type\":\"boolean\",\"comment_01\":\"Values: true|false \"},{\"dp\":17,\"name\":\"circulate\",\"capability\":\"WW\",\"typefield\":\"STRUCTREPEAT\"},{\"dp\":18,\"name\":\"random\",\"capability\":\"WW\",\"typefield\":\"STRUCTRAND\"},{\"dp\":19,\"name\":\"inching\",\"capability\":\"WW\",\"typefield\":\"STRUCTINCH\"},{\"dp\":\"_tstPing\"},{\"dp\":\"_testPing24H\",\"comment\":\"NO code implementation, only 'share'\",\"capability\":\"SKIP\",\"share\":[{\"test\":[\"msg.info.value.count > 0\"],\"action\":[{\"device\":\"tuya_bridge\",\"property\":\"_tstPing\",\"value\":true},{\"device\":\"_system\",\"property\":\"_timerON\",\"value\":\"@ _xy = {timeout:600000, id:'_testPing24H', alarmPayload:{device:'tuya_bridge', property:'_testPing24H',value: {count:(msg.info.value.count -1)}}}; _xy \"}]}]}]}],\"virtual\":[],\"fake\":[{\"id\":\"_core\",\"name\":\"core\",\"device\":\"_core\",\"power\":\"AC\",\"capability\":[\"SET\",\"GET\",\"SCHEMA\"],\"dps\":[{\"dp\":\"_DBase\",\"capability\":\"RO\"},{\"dp\":\"_heartbeat\",\"capability\":\"RO\",\"typefield\":\"TSTAMP2TIME\"},{\"dp\":\"_info\",\"name\":\"version\"}]},{\"id\":\"_system\",\"name\":\"HAL@home\",\"device\":\"_system\",\"capability\":[\"SET\",\"GET\",\"SCHEMA\"],\"dps\":[{\"dp\":\"_doSCHEMA\",\"type\":\"string\"},{\"dp\":\"_doUPDATE\"},{\"dp\":\"_ACpower\",\"capability\":\"RO\",\"type\":\"boolean\"},{\"dp\":\"_ACunconnected\",\"capability\":\"RO\"},{\"dp\":\"_beep\",\"capability\":\"WO\"},{\"dp\":\"_benchmark\"},{\"dp\":\"_benchmark_end\",\"capability\":\"TRG\",\"hide\":\"K\"},{\"dp\":\"_benchmark_step\",\"capability\":\"TRG\",\"hide\":\"K\"},{\"dp\":\"_doBenchmark\"},{\"dp\":\"_doTrigger\",\"capability\":\"WO\",\"type\":\"int\"},{\"dp\":\"_LANnet\",\"capability\":\"RO\",\"type\":\"boolean\"},{\"dp\":\"_laststart\",\"capability\":\"RO\",\"type\":\"string\"},{\"dp\":\"_name\",\"capability\":\"RO\",\"type\":\"string\"},{\"dp\":\"_play\",\"capability\":\"WO\",\"type\":\"see note\"},{\"dp\":\"_proxy\",\"capability\":\"RW\"},{\"dp\":\"_exec\",\"type\":\"string\"},{\"dp\":\"_sqlDBlocal\",\"type\":\"string\"},{\"dp\":\"_sqlDBremote\",\"type\":\"string\"},{\"dp\":\"_timerList\",\"capability\":\"RO\"},{\"dp\":\"_timerOFF\",\"type\":\"string\"},{\"dp\":\"_timerON\"},{\"dp\":\"_toDebug\",\"capability\":\"WO\"},{\"dp\":\"_toFastIN\",\"capability\":\"WO\"},{\"dp\":\"_toLogging\",\"capability\":\"WO\"},{\"dp\":\"_toLowIN\",\"capability\":\"WO\"},{\"dp\":\"_toShare\",\"capability\":\"WO\"},{\"dp\":\"_toStdCmd\",\"capability\":\"WO\"},{\"dp\":\"_toWarn\",\"capability\":\"WO\",\"type\":\"string\"},{\"dp\":\"_tuyastatus\",\"capability\":\"WO\"},{\"dp\":\"_WiFinet\",\"capability\":\"RO\"},{\"dp\":\"_WiFiunconnected\",\"capability\":\"RO\"},{\"dp\":\"_beep_loop\",\"comment\":\"NO code implementation, omly 'share'\",\"capability\":\"SKIP\",\"share\":[{\"test\":[\"msg.info.value.count > 0\"],\"action\":[{\"device\":\"_system\",\"property\":\"_beep\",\"value\":1},{\"device\":\"_system\",\"property\":\"_timerON\",\"value\":\"@ _xy = {timeout:msg.info.value.timeout, alarmPayload:{device:'_system', property:'_beep_loop',value: {count:(msg.info.value.count -1), timeout: msg.info.value.timeout}}}; _xy \"}]},{\"test\":[\"msg.info.value.count == 0\"],\"action\":[{\"device\":\"_system\",\"property\":\"_toLogging\",\"value\":{\"deviceId\":\"_system\",\"data\":{\"dps\":{\"_beep_loop\":\"done\"}}}}]}]},{\"dp\":\"_beep_loop2\",\"comment\":\"alternative implementation\",\"capability\":\"SKIP\",\"share\":[{\"test\":[\"msg.info.value.count > 0\"],\"action\":[{\"device\":\"_system\",\"property\":\"_beep\",\"value\":1},{\"device\":\"_system\",\"property\":\"_timerON\",\"value\":{\"timeout\":\"@msg.info.value.timeout\",\"alarmPayload\":{\"device\":\"_system\",\"property\":\"_beep_loop2\",\"value\":{\"count\":\"@msg.info.value.count -1\",\"timeout\":\"@msg.info.value.timeout\"}}}}]}]},{\"dp\":\"_zeroLog\",\"share\":[{\"action\":[{\"device\":\"_system\",\"property\":\"_benchmark_step\",\"value\":\"any\"}]}]},{\"dp\":\"_zeroTask\",\"hide\":\"K\",\"share\":[{\"action\":[{\"device\":\"_system\",\"property\":\"_benchmark_step\",\"value\":\"any\"}]}]}]}]}",
                "tot": "json"
            },
            {
                "p": "remotemap",
                "pt": "global",
                "to": "{\"local\":{\"DEVPC\":\"http://localhost:1984\",\"TESTPC\":\"http://localhost:1985\",\"ANDROID\":\"http://localhost:1880\"},\"remote\":{\"DEVPC\":\"http://192.168.1.3:1984\",\"TESTPC\":\"http://192.168.1.3:1985\",\"ANDROID\":\"http://192.168.1.4:1880\"}}",
                "tot": "json"
            },
            {
                "p": "instance_name",
                "pt": "global",
                "to": "DEVPC",
                "tot": "str"
            },
            {
                "p": "alldevice_file_path",
                "pt": "flow",
                "to": "D:\\xampp\\htdocs\\tuyadaemontoolkit\\devicedata",
                "tot": "str"
            },
            {
                "p": "MAXREFRESH",
                "pt": "global",
                "to": "60",
                "tot": "num"
            }
        ],
        "active": true,
        "x": 240,
        "y": 160,
        "wires": [],
        "info": "## CORE Configuration\n\n_global.alldevices_\n    To add a _new device_, or for fine tune an existing one, or to add `share` actions.\n    Same in all instances.\n      - see: https://github.com/msillano/tuyaDAEMON/wiki/tuyaDAEMOM-global.alldevices\n      - see also: https://github.com/msillano/tuyaDAEMON/wiki/tuyaDAEMON-toolkit\n\n_global.remotemap_\n    Mandatory for every tuyaDAEMON instance.\n    Two URLs for every instance in LAN.\n    Same in all instances.\n     - see: https://github.com/msillano/tuyaDAEMON/wiki/ver.-2.0--milestones#net-extensions\n\n_global.instance_name_\n    The name of this instance.\n    note: used also in remotemap.\n\n_flow.alldevice_file_path_\n    The dir to save a copy of alldevices (node 'EXPORT alldevices')\n    note:\n    - See also the tuyadaemontoolkit and tuyadaemonthings applications, for the management of alldevices.\n    - If 'tuyadaemontoolkit' is installed, use:\n        ...tuyadeamontoolkit\\devicedata\n        \n### DataBase SETUP\n  _This implementeation can use 0, 1, or 2 Dbases_ :\n   CORE uses only the DB tuyathome.messages table to store log messages (see 'BD command filter' node )\n   \n  The two databases are called: 'DBlocal' and 'DBremote'.\n     - setup 'MySQL configuration' nodes for the DBlocal and/or DBremote.\n     - on DBlocal (but can be really a remote DB, changing the configuration)  CORE can store the log of all commands ('TX') and events ('RX') processed.\n     - the BDremote is used only to send user sql ( property  _systen._sqlDBremote).\n     - disable DBlocal/DBremote nodes if not used (default).\n      \n  notes\n   - The user can fine tuning the log to only interesting data, on device/property basis, in the global.alldevices structure [see the wiki](https://github.com/msillano/tuyaDAEMON/wiki/tuyaDAEMOM-global.alldevices#output-control).\n   - With 'system' the user can send custom SQL commands to both DBs: see SYSTEM test nodes for some examples..\n\n  Extensions\n   - If you must use more than two DBs, it is easy to duplicate the nodes structure, for details see 'CUSTOMIZE: DBase servers (readme)' node documentation.\n   - An WAMP/LAMP server is used by default, but you can easily change the flow to use different DBs if you wish.\n\n### new DEVICES SETUP: \n    click the comment node 'CUSTOMIZE LOW_LEVEL (real) tuya devices' for info.\n    \n  note\n    - To add new encode/decade functions to handle new formats of device data,  see the node: '*ENCODE/DECODE user library'.\n        \n        \n note: the tuyaDAEMON three step startup process:\n\n  ------------ On Start:\n  - All 'Global MODULE config' nodes updates global/flow values\n  - 'On Start' in all flow/nodes: can do init tasks, and set\n       global/flow/context values, bur CAN NOT use global/flow values\n    (note: the esecution order is undefined)\n \n  ------------ CORE setup (first)\n    note: after All 'On Start':\n  - set libraries and objects in context.global\n  - run also 'core flow setup' (can use context.global)\n\n  ----------- all other MODULES setup (delayed)\n  - run all 'module flow setup' (can use context.global)\n  - ERROR msg if CORE setup not finish (fine tune the 'start delay')\n    (note: the esecution order is undefined)\n\n"
    },
    {
        "id": "e543af34.b2468",
        "type": "tuya-smart-device",
        "z": "173260fb.d021ff",
        "d": true,
        "deviceName": "Smart IR #2",
        "disableAutoStart": false,
        "deviceId": "example123456789",
        "deviceKey": "95e44e12dec93db9",
        "deviceIp": "",
        "retryTimeout": "100057",
        "findTimeout": "100069",
        "tuyaVersion": "3.1",
        "eventMode": "event-both",
        "x": 1300,
        "y": 260,
        "wires": [
            [
                "2ec83963.a7d146"
            ],
            [
                "4854987c.2fea88"
            ]
        ],
        "info": "CUSTOMIZATION\n\n  - duplicate for any new device\n  - set proprties: deviceId (or IP), key, retry timeout (1000 ms), find timeout (5000 ms)."
    },
    {
        "id": "ba1d97f9.86c698",
        "type": "tuya-smart-device",
        "z": "173260fb.d021ff",
        "d": true,
        "deviceName": "Smart IR #3",
        "disableAutoStart": false,
        "deviceId": "example987654321",
        "deviceKey": "d7ce90c0a98707c5",
        "deviceIp": "",
        "retryTimeout": "100103",
        "findTimeout": "100109",
        "tuyaVersion": "3.1",
        "eventMode": "event-both",
        "x": 1300,
        "y": 300,
        "wires": [
            [
                "2ec83963.a7d146"
            ],
            [
                "2eabebbc.ba4784"
            ]
        ],
        "info": "CUSTOMIZATION\n\n  - duplicate for any new device\n  - set proprties: deviceId (or IP), key, retry timeout (1000 ms), find timeout (5000 ms)."
    },
    {
        "id": "1a711832.f93bb8",
        "type": "mysql",
        "z": "173260fb.d021ff",
        "mydb": "19cea4348c0edc67",
        "name": "execute on DB local",
        "x": 1480,
        "y": 1420,
        "wires": [
            [
                "9ed599c6.5dc328"
            ]
        ],
        "info": "CUSTOMIZATION:\n\nEdit for DB url and credentials. \nDisable/delete if not used."
    },
    {
        "id": "e6b9ecd2.653e4",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "share actions",
        "func": "// note: warning on 'eval()' are ok.\n\nif (msg.share === undefined){\n//   node.warn([\"ERROR in 'share' object for '\" + (msg.info?(msg.info.device + \"/\" + msg.info.property):\"standalone share\") + \"'\", msg]);\n   return(null);\n}\n \n \nfunction recursiveExecute(obj) {\n    for (const property in obj) {\n //       node.warn([\"testing: \"+property,obj[property]]);\n        if ((typeof(obj[property]) === 'string') && (obj[property].startsWith('@') )) {\n //           node.warn([\"processing: \", obj[property]]);\n            obj[property] = eval(obj[property].substring(1));\n        } else if (typeof(obj[property]) === 'object') {\n            recursiveExecute(obj[property]);\n        }\n    }\n}    \n\nfunction evalExecute(aVal){\n    // accepts: strings, JSON, object\n    // output: string or object after eval leaf like '@....'\n    if ((typeof(aVal) === 'string') && (aVal.startsWith('{') || aVal.startsWith('['))){\n        data = JSON.parse(aVal);\n        recursiveExecute(data);\n        return data;\n    } \n    if ((typeof(aVal) === 'string') && aVal.startsWith('@')){\n        return eval(aVal.substring(1));\n    }\n    if (typeof(aVal) === 'object'){\n        recursiveExecute(aVal);\n        return(aVal);\n    }\n    return(aVal);\n}\n\n \n \n \n //     node.warn([\"SHARE input\", msg])   ;\n\nif (Array.isArray(msg.share)) {\n   var arrayLength = msg.share.length;\n   var tuyastatus = global.get(\"tuyastatus\");\n   for (var i = 0; i < arrayLength; i++) {\n      let oktodo = true;\n      if (Array.isArray(msg.share[i][\"test\"])) {\n         try {\n            oktodo = msg.share[i][\"test\"].reduce((ok, cond) => ok && eval(cond), true);\n         } catch (error) {\n            node.warn([\"Error processing 'share[\" + i + \"].test' for '\" + (msg.info?(msg.info.device + \"/\" + msg.info.property):\"standalone share\") + \"': \" + error, msg.share[i]]);\n         }\n      }\n    \n      if (Array.isArray(msg.share[i][\"action\"])) {\n         if (oktodo) {\n            var actionLength = msg.share[i][\"action\"].length;\n            for (var j = 0; j < actionLength; j++) {\n                  let xshare = msg.share[i][\"action\"][j]; \n// caller values:  property: msg.infodp, value:    msg.info.value  \n                  var _cmd = {payload: {\n                            device:  msg.info?msg.info.device  :undefined,            \n                            property:msg.info?msg.info.property:undefined,\n                            value :  msg.info?msg.info.value   :undefined }};\n                            \n                   if(xshare.remote !== undefined){  // optional\n                       _cmd.payload[\"remote\"] = xshare.remote;\n                        }\n                       // compact\n                   try {\n                      if (xshare.device === null) \n                          _cmd.payload.device = undefined;\n                      else if (typeof(xshare.device) === \"string\") // only string-JSON\n                          _cmd.payload.device = evalExecute(xshare.device);\n                      if (xshare.property === null) \n                          _cmd.payload.property = undefined;\n                      else if (typeof(xshare.property) === \"string\") // only string-JSON\n                          _cmd.payload.property = evalExecute(xshare.property);\n                      if (xshare.value === null) \n                          _cmd.payload.value = undefined;\n                      else if(xshare.value !== undefined)  // string-JSON-object\n                          _cmd.payload.value = evalExecute(xshare.value);\n      //   node.warn([\"SHARE output action:\", _cmd, xshare])   \n                     node.send(_cmd);\n                   } catch (error) {\n                   let x1 =  msg.info?msg.info.device + \"/\" + msg.info.property:\"standalone share\";\n                   node.warn([\"ERROR processing 'share[\" + i + \"].action [\" + j + \"]' for '\" + x1+ \"': \" + error, msg.share[i]]);\n                   }\n                }\n            }\n\n      } else {\n         node.warn([\"ERROR in 'share[\" + i + \"]' structure for '\" +  (msg.info?(msg.info.device + \"/\" + msg.info.property):\"standalone share\") + \"' \", msg.share[i]]);\n      }\n   }\n   return (null);\n}\nnode.warn([\"ERROR in 'alldevices.share' structure for '\" + (msg.info?(msg.info.device + \"/\" + msg.info.property):\"standalone share\") + \"' \", msg.share]);\nreturn(null);\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1170,
        "y": 1180,
        "wires": [
            [
                "d4e02463.0041e8"
            ]
        ]
    },
    {
        "id": "d4e02463.0041e8",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "to fast_cmds",
        "mode": "link",
        "links": [
            "c084a743.290b28"
        ],
        "x": 1295,
        "y": 1180,
        "wires": [],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "5e8accb.6b52034",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "FastFormat",
        "func": "\n\n// true if device is a real device (virtual == cid exists)\nfunction _isVirtual(odev) {\n    return (odev.cid !== undefined);\n}\n\n// true if is a GET command  (GET == msg.payload.value not exists)\nfunction _isget(mx) {\n    return ((mx.payload.property) && (mx.payload.value === undefined));\n}\n\n// true if is a SET command  (SET == msg.value  exists)\nfunction _isset(mx) {\n    return ((mx.payload.property) && (mx.payload.value !== undefined));\n}\n\nfunction _getHome() {\n    return global.get(\"instance_name\");\n}\n\n// ============================  fast output processing\nvar req = {\n    to: null,\n    payload: {}\n}\n\n//  node.warn([\"FAST cmd input\", msg]);\n//---------------------- some assert\nif ((!msg.payload)) {\n    node.warn([\"ASSERT fail: msg.payload must exist.\", msg]);\n    return [null];\n}\nif ((msg.payload.property !== 'undefined') && (typeof(msg.payload.property) !== \"string\")) {\n    node.warn([\"ASSERT fail: msg.payload.property, if it exists, must be a string.\", msg]);\n    return [null];\n}\n\nif ((msg.payload.remote) &&  (!global.get('modules.core_system')))  {\n    node.warn([\"ASSERT fail: 'remote' requires the 'system' module installed.\", msg]);\n    return [null];\n}\n\n\nif ((!msg.payload.remote) && (!msg.payload.device)) {\n    node.warn([\"ASSERT fail: msg.payload.device must exist in local.\", msg]);\n    return [null];\n}\n\n// ------------------------ expand messages for remote\n\nif (msg.payload.remote) {\n    let dx = msg.payload;\n    msg.payload = {};\n    msg.payload.value = dx;\n    msg.payload.device = \"_system\";\n    msg.payload.property = \"_proxy\";\n}\n\n// node.warn([\"FAST command\", msg]);\n// ----------------------- stuff: device normalization\n    var devObj = msg.payload.device ? context.global.alldevices.getODev(msg.payload.device.toString().trim()): undefined;\n    var  dpObj = msg.payload.property ? context.global.alldevices.getODps(devObj, msg.payload.property.toString().trim()): undefined;\n    msg        = context.global.alldevices.normalize(msg, devObj, dpObj);\n\n//  node.warn([\"FAST - normalized\", msg]);\n    if (msg.error){\n        node.warn([\"[Fast Cmds] \"+msg.error, msg]);\n        return([null]);\n    }\n    if (msg.warning){\n        node.warn([\"[Fast Cmds] \"+msg.warning, msg]);\n    }\n\n// -------------- encoding data on place (so also fake can use encode functions) \nif(req.infodp !== \"multiple\") {   // multiple value MUST be encoded!\n    msg.payload.value =  context.global.alldevices.encodeValue( msg.payload.value, dpObj);\n    if ( msg.payload.value && msg.payload.value.error){\n        node.warn(msg.payload.value.error);\n        return[null];\n        }\n    }        \n   \n// 'pseudo' dpObject to process PSEUDODP \nif ((dpObj === undefined) && (context.global.PSEUDODP.includes(msg.infodp.toUpperCase()))){\n        dpObj = {\n                dp: msg.infodp\n                } \n        }\n\n// =============================== prima SKIP\nif ((dpObj) && (dpObj.capability !== undefined) && (dpObj.capability.toUpperCase() === \"SKIP\")) {\n    if (msg.payload.value === undefined){\n        node.warn([\"ERROR[Fast Cmds]: GET of the 'SKIP' properties is not allowed.\", msg]);\n        return [null];\n    }    \n    // produces response\n    var newMsg = {\n        \"from\": msg.toDev || msg.to,\n        \"payload\": {\n            \"deviceId\": msg.toDev || msg.to,\n            \"data\": {\n                \"t\": Math.floor(Date.now() / 1000),\n                \"dps\": {\n                    [dpObj.dp]: msg.payload.value\n                }\n            }\n        }\n    };\n    return [null, null, newMsg];\n}\n//  ============================= then fake\nif (context.global.alldevices.fake.includes(devObj)) {\n    return [null, msg];\n}\n\n// ==============================  building request \n\nreq.topic = \"Fast cmd for \" + msg.payload.device;\n\nreq.to     = msg.to;\nreq.toDev  = msg.toDev;\nreq.infodp = msg.infodp;\nreq.payload.dps = msg.infodp.toString(); // dps always string: \"101\" or \"_connected\"\n\nif (_isVirtual(devObj)) {\n    req.payload.devId = devObj.cid;\n}\n\n// =======  request data processing encoding\n    \nif(req.infodp === \"schema\") {    \n   delete req.payload.dps;\n   req.payload.operation = \"GET\";\n   req.payload.schema  = true;   \n} else \nif(req.infodp === \"multiple\") {   \n   delete req.payload.dps;\n   req.payload.data  = msg.payload.value;   \n   req.payload.multiple  = true;   \n} else \nif (_isget(msg)) {\n    req.payload.operation = \"GET\";\n    //\n    var capp = (typeof dpObj.capability !== 'undefined') ? dpObj.capability : \"RW\";\n    if ((capp === \"WW\") || (capp === \"GW\")) {\n        delete req.payload.operation;\n        req.payload.set = null;\n    }\n} else\nif (_isset(msg)) {\n    req.payload.set = msg.payload.value;\n    }\nreturn [req, null];\n",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 900,
        "wires": [
            [
                "4b771bf3.b8cef4"
            ],
            [
                "7d976f84.81d9a",
                "933b14e647ae6e8b"
            ],
            [
                "44804bb7.72ee84"
            ]
        ],
        "outputLabels": [
            "tuya",
            "fake",
            "skip"
        ],
        "info": "Fast command process\n  see 'fast_cmds' node"
    },
    {
        "id": "c084a743.290b28",
        "type": "link in",
        "z": "173260fb.d021ff",
        "name": "fast_cmds",
        "links": [
            "1af71950.31eac7",
            "2c0e5d31.d02b72",
            "2ed08207.23ffae",
            "4242c140.fdbb2",
            "5d515b706d6149ac",
            "5e693599.3f435c",
            "6db5220c.6c9b0c",
            "739fba48.a46514",
            "8834ba78.eef318",
            "a131d6fe.bff008",
            "a51db0ff.4ca74",
            "ad341350.43d4f",
            "d4e02463.0041e8",
            "e8f89f67.1aa7f",
            "eea2d98c.558178"
        ],
        "x": 180,
        "y": 900,
        "wires": [
            [
                "5e8accb.6b52034"
            ]
        ],
        "l": true,
        "info": "Fast INPUT (internal use)\n\nDifferences from standard INPUT commands:\n \n1.  No command echo on debug pad, no log on DB (like hide=\"CT\")\n\n2.  No test of the device capabilities in `alldevices`: all commands are processed. i.e. _use `fast&lowbar;cmds` with care, only with tested commands._\n3.  Only the following capabilities of a DP, defined in `alldevices`, are processed:\n - \"SKIP\" : the command is not sent to device.\n - \"WW\" or \"GW\" : any GET is replaced by SET(null).\n \n4.  _We can set `device.capabilities='NONE'` to block all commands from user, but still executing commands from 'fast&lowbar;cmds'._\n \n4.  _We can set `dp.capability='TRG'` to block all commands from user, but still executing commands from 'fast&lowbar;cmds'._\n \n5.  Internal use: share, custom devices, extensions.\n\n6.  For tuyaDEAMON user commands see 'std_cmds' node.\n"
    },
    {
        "id": "44804bb7.72ee84",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "skip: to logging",
        "mode": "link",
        "links": [
            "9fe80f7e.f3f7e"
        ],
        "x": 555,
        "y": 960,
        "wires": [],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "7d976f84.81d9a",
        "type": "debug",
        "z": "173260fb.d021ff",
        "d": true,
        "name": "*trace: msg IN for Fake devices",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1830,
        "y": 1180,
        "wires": [],
        "info": "CUSTOMIZATION\n\n- Enable to see in the debug pad all msg sended to fake devices.\n- Normal use: disabled"
    },
    {
        "id": "a0d5012f.b2551",
        "type": "tuya-smart-device",
        "z": "173260fb.d021ff",
        "d": true,
        "deviceName": "meter",
        "disableAutoStart": false,
        "deviceId": "exampl456789123",
        "deviceKey": "84bb4fb812611a2d",
        "deviceIp": "",
        "retryTimeout": "2279",
        "findTimeout": "6291",
        "tuyaVersion": "3.3",
        "eventMode": "event-both",
        "x": 1280,
        "y": 340,
        "wires": [
            [
                "2ec83963.a7d146"
            ],
            [
                "47aacea1.0d58d"
            ]
        ],
        "info": "CUSTOMIZATION\n\n  - duplicate for any new device\n  - set proprties: deviceId (or IP), key, retry timeout (1000 ms), find timeout (5000 ms).\n \n\nsee: https://github.com/msillano/tuyaDAEMON/wiki/Howto:-add-a-new-device-to-tuyaDAEMON"
    },
    {
        "id": "47aacea1.0d58d",
        "type": "subflow:ee953c15.ada29",
        "z": "173260fb.d021ff",
        "name": "",
        "env": [
            {
                "name": "deviceId",
                "value": "exampl456789123",
                "type": "str"
            },
            {
                "name": "deviceID",
                "value": "42027807d8bfc0c5831e",
                "type": "str"
            }
        ],
        "x": 1520,
        "y": 340,
        "wires": [
            [
                "81103bac.696bc8"
            ]
        ],
        "info": "CUSTOMIZATION\n\n- duplicate for any new device alltime connected\n- set properties: deviceID.\n\nfor more info: see \"*device selector\" node documentation."
    },
    {
        "id": "3d54171f.a9e138",
        "type": "link in",
        "z": "173260fb.d021ff",
        "name": "share IN",
        "links": [
            "818feefe.ab666",
            "9593347f2142b552",
            "e6e5a7b3.a53aa8"
        ],
        "x": 960,
        "y": 1180,
        "wires": [
            [
                "e6b9ecd2.653e4"
            ]
        ],
        "l": true,
        "info": "## ENTRY point to execute a 'share'\n\nUsually 'share' are defined in global.alldevices, so an Event can trigger one of more Commands.\n\nBut a 'share' can live also alone, and the user as an alternative way to fire commands in tuyaDEAMON, sending here a 'share', or using the SYSTEM property 'doSHARE'.\n\nshare object Format:\n     \"info\": {                     // auto from trigger event or user (optional)\n                  \"\"             // used as 'IN parameters' into the expressions\n             }\n     \"share\": [{\n        \"test\": [                                      // optional: default true\n           `condition-string-1`        // eval(condition-string-1) => true|false          \n            ... more test strings (AND) ... ],\n        \"action\": [{                                  // standard command fields\n            \"remote\"  : \"NAMEXX\",                                    // optional\n            \"device\"  : @expession | string | null | undefined,\n            \"property\": @expession | string | null | undefined,    \n            \"value\"   : @expession | string | object | null | undefined\n             } ... more actions (sequence)...]\n         } ... more {(test[],) action[]} (selection) ...\n      ]\n\nSpecial rules of evaluation for action.device (and property, value) to build the actual cammand:\n\n    share.action.device = @expession       => command.payload.device = eval(expession)\n    share.action.device = string (object)  => command.payload.device = string (object)\n    share.action.device = null             => command.payload.device = undefined\n    share.action.device = undefined|missed => command.payload.device = info.device || undefined.\n    \nsee [alldevices](https://github.com/msillano/tuyaDAEMON/wiki/tuyaDAEMOM-global.alldevices#share-actions)\n\nexamples: see in global.alldevices the implementation of this properties, all uses 'share':\n      - system._beep_loop  \n      - system.doBenchmark\n      - tuya_bridge._tstPing24H."
    },
    {
        "id": "678390f9.125df",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "to logging",
        "mode": "link",
        "links": [
            "9fe80f7e.f3f7e"
        ],
        "x": 1245,
        "y": 440,
        "wires": [],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "6830d12a.a0e64",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "IN COMMANDS",
        "info": "",
        "x": 180,
        "y": 700,
        "wires": []
    },
    {
        "id": "2a17d0b8.943bd",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "CUSTOMIZE (real) tuya devices (readme)",
        "info": "Add here the 'real tuya-devices' i.e. the devices handled by smart-tuya-device node, or equivalent implementations. For more detail, see 'core.devices selector' node informations.\n\nFor the the 'virtual tuya-devices' i.e. the devices handled by a gateway, add in this flow only the gateway.\n\nFor the 'mirror devices' you MUST add the core_trigger flow.\n\nSee in the wiki [how to add a new device](https://github.com/msillano/tuyaDAEMON/wiki/Howto:-add-a-new-device-to-tuyaDAEMON)",
        "x": 1300,
        "y": 200,
        "wires": []
    },
    {
        "id": "4b771bf3.b8cef4",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "pseudo DPs",
        "func": "\n//  filter device messages and process  pseudoDP \n//---------------------- some asserts for not fake devices\nif (!msg.toDev) {\n    node.warn([\"ASSERT fail: msg.toDev must exist in real|virtual devices.\", msg]);\n    return [null];\n}\n\n// special output message\nvar newMsg = {\n     toDev : msg.toDev,\n     payload:{operation: \"CONTROL\"}\n };\n\n// processes pseudoDP _standby, _findTimeout doing a format change.\n//  SET/GET case:\n// case sensitive\nswitch (msg.payload.dps){\n    case \"_standby\":\n//        node.warn(\"in STANDBY\");\n        if (msg.payload.set !== undefined){          // is SET\n //           newMsg[\"standby\"] = !!(msg.payload.set);\n            newMsg.payload[\"action\"] = !!(msg.payload.set)? \"DISCONNECT\":\"CONNECT\";\n            return newMsg;\n            }\n// GET: ignore            \n        return null;\n    case \"_findTimeout\":\n         if (msg.payload.set !== undefined){      // is SET\n  //        newMsg[\"findTimeout\"] = Number(msg.payload.set);\n            newMsg.payload[\"action\"] = \"SET_FIND_TIMEOUT\";\n            newMsg.payload[\"value\"] = Number(msg.payload.set);\n            return newMsg;\n            }\n  // GET: ignore            \n        return null;\n  case \"_retryTimeout\":\n         if (msg.payload.set !== undefined){      // is SET\n  //        newMsg[\"findTimeout\"] = Number(msg.payload.set);\n            newMsg.payload[\"action\"] = \"SET_RETRY_TIMEOUT\";\n            newMsg.payload[\"value\"] = Number(msg.payload.set);\n            return newMsg;\n            }\n// GET: ignore            \n        return null;\n// not implemented: kills        \n    case \"_T\":\n    case \"_t\":\n    case \"_connected\":\n    case \"SCHEMA\":\n    case \"schema\":\n        return null;\n// implemented:  nothing to do      \n    case \"_refreshCycle\":\n    case \"_refresh\":\n// verify if available else error\n     var o = context.global.alldevices.getODev(msg.toDev);\n     if (o.capability && o.capability.contains(\"REFRESH\"))\n          return(msg);\n     node.warn(\"[pseudo DP]ERROR: REFRESH not allowed by \"+(o.name || o.id) + \" device.\");\n          return null;\n   default:  \n// test for MULTIPLE case +  _standby | _findTimeout | _retryTimeout: \n// here is case sensitive\n        if ((msg.payload.data !== undefined) && (msg.payload.data._standby !== undefined)) {\n              let aval = msg.payload.data._standby;\n              delete msg.payload.data._standby;\n //             node.send(msg);\n //             newMsg[\"standby\"]=aval;\n              newMsg.payload[\"action\"] = !!(aval)? \"CONNECT\":\"DISCONNECT\";\n              node.send(newMsg);\n        }\n       if ((msg.payload.data !== undefined) && (msg.payload.data._findTimeout !== undefined)) {\n              let aval = msg.payload.data._findTimeout;\n              delete msg.payload.data._findTimeout;\n//              node.send(msg);\n//              newMsg[\"findTimeout\"]=aval;\n               newMsg.payload[\"action\"] = \"SET_FIND_TIMEOUT\";\n               newMsg.payload[\"value\"] = aval;\n               node.send(newMsg);\n       }\n      if ((msg.payload.data !== undefined) && (msg.payload.data._retryTimeout !== undefined)) {\n              let aval = msg.payload.data._retryTimeout;\n              delete msg.payload.data._retryTimeout;\n//              node.send(msg);\n//              newMsg[\"findTimeout\"]=aval;\n               newMsg.payload[\"action\"] = \"SET_RETRY_TIMEOUT\";\n               newMsg.payload[\"value\"] = aval;\n               node.send(newMsg);\n       }\n\n}  // case ends\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 900,
        "wires": [
            [
                "5777b120.3dc3e"
            ]
        ]
    },
    {
        "id": "fb4bfc14.6eece",
        "type": "link in",
        "z": "173260fb.d021ff",
        "name": "fake_cmds_IN",
        "links": [],
        "x": 250,
        "y": 980,
        "wires": [
            [
                "933b14e647ae6e8b"
            ]
        ],
        "l": true,
        "info": "INPUT for direct commands to _local fake devices_.\n\nCommand format for all local 'fake' and custom devices:\n   the Message is in rich `normalizated` format to speedup next elaborations:\n\nused to update `global.tuyastatus` (are standard items but redefined)\n-   `msg.payload.device   = usr-dev-name|msg.to`\n-   `msg.payload.property = undef|usr-dp-name|msg.infodp`\n-   `msg.payload.value    = undef|any`  \n\nused as keys:\n-   `msg.to     = cid|deviceId`       (mandatory)\n-   `msg.infodp = dp|pseudoDP`        (mandatory)\n-   `msg.hide   = \"\"|\"KCERT\"`         (visibility, since 2.2.0)\n\nrules:\n- Only for local devices, not handled by the 'tuya-smart-device' nodes.\n- pseudoDPs are defined in `global.alldevices.__pseuododp` array.\n     [see wiki](https://github.com/msillano/tuyaDAEMON/wiki/ver.-2.0--milestones#pseudodp)\n- The device|dp `capabilities` are not checked in global.alldevices.\n- The device _connection status is not checked.\n- SCHEMA: `infodp` = 'schema', `property`= undefined, `value`= undefined\n- GET: `value` = undefined\n- SET: `value` = defined, any value, also object.\n\nunused in _fake devices_:\n-  `msg.toDev  = gatewayId|deviceId` (real devices selector)\n-  MULTIPLE: `infodp` = 'multiple', `property` = 'multiple', `value` = coded, sent 'as is' to device.\n\n"
    },
    {
        "id": "9538139a.19ca1",
        "type": "link in",
        "z": "173260fb.d021ff",
        "name": "sql_BD",
        "links": [
            "87a7bcc7.bedfa"
        ],
        "x": 950,
        "y": 1420,
        "wires": [
            [
                "70d88fb4.7fcc2"
            ]
        ],
        "l": true,
        "info": "##  Entry point for DB (sql)\n\nFormat for tuyaDAEMON DB Logging purpose (routed to DBlocal, no log):\n\n       {\n        to|from: `deviceId`|`cid`,  // mandatory\n        infodp:  `property`,\n        hide: \"\",\n        topic:   \"INSERT ...\"     // sql\n       }\n   \nFormat to execute user sql (routed to DBlocal, DBremote..., with log)\n\n       {\n        to:     \"_dBase\",     \n        infodp: \"_sqlDBlocal\"|\"_sqlDBremote\"|...,     // default two dp.\n        hide: \"\",\n        topic:  `sql-string`\n       } \n\nFor more than 2 DB: see\nUpdate the `*DB mux-filter` node.        "
    },
    {
        "id": "9ed599c6.5dc328",
        "type": "subflow:81d3b584.14c888",
        "z": "173260fb.d021ff",
        "name": "",
        "env": [
            {
                "name": "deviceID",
                "value": "_system",
                "type": "str"
            },
            {
                "name": "propertyDP",
                "value": "_sqlDBlocal",
                "type": "str"
            },
            {
                "name": "value",
                "value": "@msg._event? msg.payload: \"none\"",
                "type": "str"
            }
        ],
        "x": 1770,
        "y": 1420,
        "wires": [
            [
                "e32fa2db.d0b7c"
            ]
        ]
    },
    {
        "id": "29e8ecd6.79a274",
        "type": "subflow:81d3b584.14c888",
        "z": "173260fb.d021ff",
        "name": "",
        "env": [
            {
                "name": "deviceID",
                "value": "_system",
                "type": "str"
            },
            {
                "name": "propertyDP",
                "value": "_sqlDBremote",
                "type": "str"
            },
            {
                "name": "value",
                "value": "@msg._event? msg.payload: \"none\"",
                "type": "str"
            }
        ],
        "x": 1770,
        "y": 1480,
        "wires": [
            [
                "e32fa2db.d0b7c"
            ]
        ]
    },
    {
        "id": "e32fa2db.d0b7c",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "to logging",
        "mode": "link",
        "links": [
            "9fe80f7e.f3f7e"
        ],
        "x": 1955,
        "y": 1480,
        "wires": [],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "74205825.bd5e98",
        "type": "mysql",
        "z": "173260fb.d021ff",
        "mydb": "19cea4348c0edc67",
        "name": "append to  DB local",
        "x": 1470,
        "y": 1360,
        "wires": [
            []
        ],
        "info": "CUSTOMIZATION:\n\nEdit for DB url and credentials. \nDisable/delete if not used."
    },
    {
        "id": "46a8112c.cdbcf",
        "type": "mysql",
        "z": "173260fb.d021ff",
        "mydb": "93f8bfd.d0c854",
        "name": "execute on DB  remote",
        "x": 1480,
        "y": 1480,
        "wires": [
            [
                "29e8ecd6.79a274"
            ]
        ],
        "info": "CUSTOMIZATION\n\nEdit for DB url and credentials. \nDisable/delete if not used."
    },
    {
        "id": "756a073a.e295b8",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "to low_level_IN",
        "mode": "link",
        "links": [
            "b25c688d.705df8"
        ],
        "x": 1725,
        "y": 440,
        "wires": [],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "2eabebbc.ba4784",
        "type": "subflow:15c9daba.b55285",
        "z": "173260fb.d021ff",
        "name": "*dynamic retry",
        "env": [
            {
                "name": "deviceId",
                "value": "example987654321",
                "type": "str"
            }
        ],
        "x": 1530,
        "y": 300,
        "wires": [
            [
                "81103bac.696bc8"
            ],
            [
                "756a073a.e295b8"
            ]
        ],
        "info": "\nUse 'dynamic retry' in place of 'static retry' if the device is often disconneted (power strip, power plug, light bulbs etc.)\n\n\nfor more info: see \"*device selector\" node documentation."
    },
    {
        "id": "2b66a27e.d6726e",
        "type": "subflow:e1c6cc8a.2f92a",
        "z": "173260fb.d021ff",
        "name": "",
        "env": [
            {
                "name": "deviceID",
                "value": "exampl456789123",
                "type": "str"
            },
            {
                "name": "name (same as device node)",
                "value": "meter",
                "type": "str"
            }
        ],
        "x": 1090,
        "y": 340,
        "wires": [
            [
                "a0d5012f.b2551"
            ],
            [
                "678390f9.125df"
            ]
        ],
        "info": "Some devices acceps as polling the command `REFRESH`.\n\nExample: power meter.\n\nThis filter subflow handles the device polling strategy, intercepting and implementing 2 pseudoDP: `_refresh` and `_refreshCycle`.\n\n"
    },
    {
        "id": "946d7931.c2a828",
        "type": "debug",
        "z": "173260fb.d021ff",
        "d": true,
        "name": "*trace: msg IN for Real devices",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1830,
        "y": 1140,
        "wires": [],
        "info": "CUSTOMIZATION\n\n- Enable to see in the debug pad all msg sended to fake devices.\n- Normal use: disabled"
    },
    {
        "id": "cb0e33e6.f0a6b",
        "type": "tuya-smart-device",
        "z": "173260fb.d021ff",
        "d": true,
        "deviceName": "WiFi plug",
        "disableAutoStart": false,
        "deviceId": "example891234567",
        "deviceKey": "ddfd532e9962d0a8",
        "deviceIp": "",
        "retryTimeout": "5000",
        "findTimeout": "3000",
        "tuyaVersion": "3.1",
        "eventMode": "event-both",
        "x": 1290,
        "y": 380,
        "wires": [
            [
                "2ec83963.a7d146"
            ],
            [
                "572ec9e9.c41048"
            ]
        ],
        "info": "CUSTOMIZATION\n\n  - duplicate for any new device\n  - set proprties: deviceId (or IP), key, retry timeout (1000 ms), find timeout (5000 ms)."
    },
    {
        "id": "3d5897cf.378f68",
        "type": "subflow:e1c6cc8a.2f92a",
        "z": "173260fb.d021ff",
        "name": "",
        "env": [
            {
                "name": "deviceID",
                "value": "example891234567",
                "type": "str"
            }
        ],
        "x": 1090,
        "y": 380,
        "wires": [
            [
                "cb0e33e6.f0a6b"
            ],
            [
                "678390f9.125df"
            ]
        ],
        "info": "me devices acceps as polling the command REFRES.\n\nExample: power meter.\n\nThis subflow handle the device polling strategy, implementing 2 pseudoDP: _refresh and refreshCycle.\n\n"
    },
    {
        "id": "572ec9e9.c41048",
        "type": "subflow:15c9daba.b55285",
        "z": "173260fb.d021ff",
        "name": "",
        "env": [
            {
                "name": "deviceId",
                "value": "example891234567",
                "type": "str"
            },
            {
                "name": "MaxTimeout",
                "value": "100000",
                "type": "num"
            }
        ],
        "x": 1530,
        "y": 380,
        "wires": [
            [
                "81103bac.696bc8"
            ],
            [
                "756a073a.e295b8"
            ]
        ],
        "info": "\nUse 'dynamic retry' in place of 'static retry' if the device is often disconneted (power strip, power plug, light bulbs etc.)\n\n\nfor more info: see \"*device selector\" node documentation."
    },
    {
        "id": "b8e273f8.d51a7",
        "type": "link in",
        "z": "173260fb.d021ff",
        "name": "event in",
        "links": [
            "2e4937fc.2ef1f8"
        ],
        "x": 345,
        "y": 1520,
        "wires": [
            [
                "65eb2aa.067dfd4",
                "f1edf094.cfc34"
            ]
        ],
        "icon": "font-awesome/fa-expand"
    },
    {
        "id": "f1edf094.cfc34",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "notification",
        "func": "const TIMEOUT = 20000;\n\ncmdlist = flow.get(\"waitcmd\");\n//  node.warn([\"inPUT SET \", msg, cmdlist]);\nif (cmdlist === undefined)\n  cmdlist = [];\n  \ncmdlist = cmdlist.filter(obj => obj._t + TIMEOUT > Date.now()); \n\n// remote SET msg: stores it to send delayed answewr  \nif(msg.payload && msg.payload.remote_from && (msg.infodp !== \"_toLogging\"))\n{\n//  node.warn([\"in SET \", msg, cmdlist])\n  msg['_t'] = Date.now();\n  cmdlist.push(msg); \n  flow.set(\"waitcmd\", cmdlist);\n  return null;\n}\n/*\n{\n    \"remote\": \"DEVPC\",\n    \"device\": \"_system\",\n    \"property\": \"_toLogging\",\n    \"value\": {\n        \"remote_from\": \"ANDROID\",\n        \"deviceId\": \"bfa355aa196ae5975cy6ii\",\n        \"data\": {\n            \"dps\": {\n                \"1\": \"OFF\"\n            }\n        }\n    }\n}\n*/\n// noting to do: no waiting response\nif (cmdlist.length < 1 ) return null;\n\n// test response\nif(msg.info && msg.info.value && (msg.infodp !== \"_toLogging\")) {\n   cmdlist.forEach(function (oldmsg, index) {\n //   node.warn([\"test GET \", msg, oldmsg]);\n           if (oldmsg.to == msg.from){\n             var cmm ={\n                    payload:{\n                      remote : oldmsg.payload.remote_from,\n                      device:\"_system\",\n                      property: \"_toLogging\",\n                      value:{\n                            remote_from : global.get(\"instance_name\"),\n                            deviceId : oldmsg.to,\n                            data:{\n                                dps: {}\n                                }\n                       }\n                     }};\n                cmm.payload.value.data.dps[msg.infodp] = msg.info.value;   \n   //    node.warn([\"out GET \", msg, cmm]);\n  //               return cmm ;\n             node.send(cmm);\n            }\n  \n   });\n}\n\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1520,
        "wires": [
            [
                "58c718a1.bbd748"
            ]
        ]
    },
    {
        "id": "8792104e.e64d4",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "Info commands filter",
        "func": "// kills unwanted tuyaDEAMON Event messages & MQTT\n\n// some formal ASSERT, just in case...\nif((typeof(msg.to) !== \"string\") && (typeof(msg.from) !== \"string\") )\n         node.warn([\"ASSERT fail: in msg the to/from (string) must exist.\", msg]) ;   \nif(typeof(msg.infodp) !== \"string\")\n         node.warn([\"ASSERT fail: in msg the msg.infodp (string) must exist.\" , msg]) ;   \n// from 2.2.0\nif(typeof(msg.hide) !== \"string\"){\n         node.warn([\"ASSERT fail: in msg the msg.hide (string) must exist.\" , msg]) ;  \n         msg.hide = \"\"; // no errors\n         }\n\n// ==================== KILL log COMMANDS: SYSTEM defined \nswitch (msg.to){                                   \n    case \"_system\":\n         if (msg.infodp === \"_zeroTask\")  return(null);   // fast benchmarks\n         if (msg.infodp === \"_toLogging\") return(null);   //  internal use: REST remote echo\n         if (msg.infodp === \"_proxy\")     return(null);   //  internal use: REMOTE commands \n        break;\n}\n\n// ==================== KILL log COMMANDS: user defined in alldevices.\nif ((!!~msg.hide.indexOf(\"C\")) || (!!~msg.hide.indexOf(\"K\")))\n            return null;      // killed\n            \nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1200,
        "y": 1240,
        "wires": [
            [
                "d62f5a18.fe10b8",
                "7316efb9.f1d1c"
            ]
        ],
        "icon": "font-awesome/fa-filter",
        "info": "CUSTOMIZATION:\n\nFilter to reduce info messages on Debug pad.\n\nFiltering action is done usually by the 'hide' device/dp property, under user control.\nSome cases are done by this code, to force default behavior.\n\n- On installation and test:\n  Best don't filter any message.\n- On production:\n  Better to filter not useful events.\n\n_________________________________\n  \nIn code, filter can be done on: \n       msg.from:            RX info, the deviceId\n       msg.to:              TX info, the deviceId\n       msg.infodp:          the dpId          \n  \n   "
    },
    {
        "id": "9fe75b23.a05408",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "events info",
        "mode": "link",
        "links": [
            "39f74e4e.a48f02"
        ],
        "x": 1450,
        "y": 1300,
        "wires": [],
        "l": true,
        "info": "Internal use, to send via new protocols (actually used by MQTT)."
    },
    {
        "id": "7316efb9.f1d1c",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "commands info",
        "mode": "link",
        "links": [],
        "x": 1460,
        "y": 1180,
        "wires": [],
        "l": true,
        "info": "internal use, to send via new protocols (actually not used)"
    },
    {
        "id": "31ee33283ccb4996",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "CUSTOMIZE: DBase servers (readme)",
        "info": "  _This implementeation can use 0, 1, or 2 Dbases_ :\n  \n  The two databases are called: 'DBlocal' and 'DBremote'.\n     - on DBlocal (but it can be really a remote DB, changing the configuration)  CORE stores the log of all commands ('TX') and events ('RX') processed.\n     - CORE uses only the 'tuyathome.messages' DB table to store log messages (see core.'BD command filter' node)\n     - With 'system' the user can send custom SQL commands to both DBs ([see wiki](https://github.com/msillano/tuyaDAEMON/wiki/custom-device-_system#db-functions), using two ad hoc properties: '_sqlDBlocal' and 'sqlDBremote'.\n     - disable DBlocal/DBremote nodes if not used (default).\n     - setup 'MySQL configuration' nodes for the DBlocal and/or DBremote.\n\n\n   **Extensions**\n   Maybe you like to do something like this:\n      - to store only some devices/properties in an open 'wehater' DB,\n      - to store other devices/properties in a 'security' DB installed in a protected server running 24/7\n      - and the others in the 'debug' DB on the development PC.\n   \n   You can: if you need to use more than two DBs with the same tuyaDAEMON instance, it is easy to duplicate the  DBremote node structure and configuration as required.\n   \n   1. In 'CORE' flow you must do:\n        - Add the required nodes.\n        - edit 'DB command filter' node adding more outputs \n        - edit 'DB log event filter' to routing messages.\n        - edit 'All DB status' node to check the new DB nodes\n        \n   2. In 'SYSTEM' flow you must add new commands (new DPs: e.g. 'sqlDBweater') to send SQLs to new DBs. You must modify:\n        -  '_system custom selector (3)'  node to implement SET and GET.\n\n   3. finally update\n        -  global.alldevices.fake._system (add to _system the new commands (DPs))\n   \n  An WAMP/LAMP server is used by default, but you can easily change the flow to use different DBs if you wish.",
        "x": 1750,
        "y": 1360,
        "wires": []
    },
    {
        "id": "dade252a6ed621f0",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "*DB events filter",
        "func": "\n// Default using 2 DB:  'local' and 'remote'.\n\n// some ASSERT, just in case...\nif(typeof(msg.from) !== \"string\") \n         node.warn([\"ASSERT fail: in msg the msg.from (string) must exist.\", msg]) ;   \nif(typeof(msg.infodp) !== \"string\")\n         node.warn([\"ASSERT fail: in msg the msg.infodp (string) must exist.\" , msg]) ;   \nif(typeof(msg.topic) !== \"string\")\n         node.warn([\"ASSERT fail: in msg the msg.topic (sql string) must exist.\" , msg]) ;   \n// from 2.2.0\nif(typeof(msg.hide) !== \"string\")\n         node.warn([\"ASSERT fail: in msg the msg.hide (string) must exist.\" , msg]) ;   \n\n// ==================== KILL DBASE EVENT records: default SYSTEM defined \nswitch (msg.from){      \n   case \"_system\":\n        if (msg.infodp === \"_exec\") \n             return([null]);   // can give problems with the output data, not logged in DB\n  //\n        if (msg.infodp === \"_toLogging\") return([null]);    // internal use REST remote echo\n        if (msg.infodp === \"_proxy\") return(null);          // internal use REMOTE commands\n        if (msg.infodp === \"_zeroTask\")  return([null]);    // fast benchmarks, no log\n        break;\n}\n\n// ==================== KILL DBASE EVENT recors: user defined in alldevices\nif ((!!~msg.hide.indexOf(\"R\")) || (!!~msg.hide.indexOf(\"K\")))\n            return null; // killed\n            \n// =================== here optional routing code\n//  --- default one output for all event records, no routing\nreturn [msg];  // defaut: local",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 1360,
        "wires": [
            [
                "74205825.bd5e98"
            ]
        ],
        "icon": "font-awesome/fa-filter",
        "info": "CUSTOMIZATION:\n\nFilter to reduce info record on Databases.\n\nFiltering action is done usually by the 'hide' device/dp property, under user control.\nSome cases are done by this code, to force default behavior.\n\n- On installation and test:\n  Best don't filter any message.\n- On production:\n  Better to filter not useful events.\n\n_________________________________\n\nRouting action to direct some records to special DBs.\n\n_________________________________\n  \nIn code, selection can be done on: \n       msg.from:            RX info, the deviceId\n       msg.to:              TX info, the deviceId\n       msg.infodp:          the dpId          \n_________________________________\n  \n"
    },
    {
        "id": "4217be7e01aff85d",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "CORE startup process (readme)",
        "info": "Message from CORE (alone) on startup (only if DB nodes are enabled):\n\n    [\"RX: 'HAL@home'/'_DBase' \",true]  \n\nor, in case of DB problems (check configuration nodes):  \n\n    msg : error\n    \"Error: connect ECONNREFUSED 192.168.1.19:3306\" (can change)\n\n    [\"RX: 'HAL@home'/'_DBase' \", false ] \n\nTipical startup sequence (core+system+trigger+MQTT) after a 'Restart Flows':\n\n           [ \"RX: core/_DBase\", true ]                       // DB very fast\n\n           [ \"RX: tuya_bridge/_connected\", false ]           // initial value\n           [ \"RX: HAL@home/_WiFinet\", false ]\n           [ \"RX: HAL@home/_WiFiunconnected\", array[1] ]\n\n           [ \"RX: tuya_bridge/_connected\", true ]            // successful attempt \n           [ \"RX: HAL@home/_LANnet\", true ]\n           [ \"RX: HAL@home/_WiFinet\", true ]\n           [ \"RX: HAL@home/_WiFiunconnected\", array[0] ]\n\n           [ \"RX: core/_heartbeat\", \"16:46:44\" ]             // 5s from start\n                                                             // then every 30s\n           \n           [\"RX: HAL@home/_laststart\",\"2022-04-08 16:46:49\"] // 10 s from start\n\n\n**heartbeat**\n\n    [\"DEVPC: RX: 'core'/'heartbeat' \",\"20:57:56\"]\n    \nThis is a PUSH event from core, default is every 30s after 5s.\n\n note:  You can:\n - change the period (editing the 'heartbeat' input node) \n - control the logging rules ('hide' in global.alldevices, default: \"R\" = do not store in DBase) \n - eliminate it (disabling the node).\n  \n  \n**version**\n  See the test node \"GET version\" readme.\n",
        "x": 190,
        "y": 1840,
        "wires": []
    },
    {
        "id": "556e669b18646abd",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "heartbeat",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "payload.data.dps._heartbeat",
                "v": "",
                "vt": "date"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "{\"deviceId\":\"_core\",\"data\":{\"dps\":{\"_heartbeat\":null}}}",
        "payloadType": "json",
        "x": 230,
        "y": 1180,
        "wires": [
            [
                "2e6c4b231f4722c2",
                "3ef151475f89529b"
            ]
        ],
        "icon": "font-awesome/fa-ban",
        "info": "\nheartbeat event creation.\n\nPUSH event usend in tests, as watchog, etc.\n\nThe payload is from \"core.heartbeat\" node, fired every 5s (default, defined in the 'heartbeat' node).\n\nTo reduce the heartbeat visibility update the 'hide' in 'global.alldevices.fake.core.dps._heartbeat' (general rule): \n\n  - Set 'hide' to \"\" | \"K\" | \"E\" | \"R\" to log: all | nothing | only DB | only debugpad + MQTT (it is an event, so do not use \"C\" and \"T\").\n\n"
    },
    {
        "id": "dd168f01bbc7eafb",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "SET info",
        "props": [
            {
                "p": "payload.device",
                "v": "_core",
                "vt": "str"
            },
            {
                "p": "payload.property",
                "v": "_info",
                "vt": "str"
            },
            {
                "p": "payload.value",
                "v": "any",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 180,
        "y": 1980,
        "wires": [
            [
                "06f244a00e127392"
            ]
        ],
        "info": "Test the SET '_info' property of core, using the msg:\n\n         payload: {\n            device: \"_core\",\n            property: \"_info\",\n            value: \"any\"\n            }\n\n- Returns the list of modules in use and the list of actually connected devices, gouped as real, virtual and fake devices.\n\nIN _global.alldevices_ the default definition is:\n\n                {\n                    \"dp\": \"_info\",\n                    \"name\": \"version\",\n                    \"capability\": \"RW\"\n                }\n\nnote: this SET acts as a trigger ( 'value' is requited, but not used) and the result is an updated data structure.\n---------------------------------------\nExpected result\n\n    TX: GET fake core/version\n    \nthen: \n\n    [\"RX: core/version object] \n  \nOpenninig the answer object we get (configuration dependent):\n\n - minimal (only core)\n````\n    array[2]\n      0: \"RX: core/version \"\n      1: object\n                      // here list of 'connected' devices\n         devices: object\n           real: array[0]\n           virtual: array[0]\n           fake: array[1]\n              0: \"core\"\n                      // here list of 'enabled' flows\n         core: \"2.2.0\"\n````\n- rich (core+trigger+mqtt+system):\n````\n    array[2]\n      0: \"RX: core/version \"\n      1: object\n         devices: object\n           real: array[1]\n             0: \"tuya_bridge\"\n          virtual: array[0]\n          fake: array[2]\n             0: \"core\"\n             1: \"HAL@home\"\n      core_system: \"2.2.0\"\n      core_trigger: \"2.2.0\"\n      core_mqtt: \"2.2.0\"\n      core: \"2.2.0\"\n````  \n\n_General rule: if you set a user friendly 'name' for a device and/or a property (in core.global.alldevices) all output messages and the global.tuyastatus will use this name (e.g. version vs. _info)._\n\n- _In the input messages you can use both, the name or the ID:_\n````\n    payload.property = \"version\"\nor    \n    payload.property = \"_info\"      \n\n````\n - Never change strings starting with '_': they are  code defined IDs and cannot be changed. \n\n"
    },
    {
        "id": "06f244a00e127392",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "send to std_cmds",
        "mode": "link",
        "links": [
            "8a1da02d.424ae"
        ],
        "x": 530,
        "y": 1980,
        "wires": [],
        "l": true
    },
    {
        "id": "7d4920121a9a25b6",
        "type": "subflow:81d3b584.14c888",
        "z": "173260fb.d021ff",
        "name": "",
        "env": [
            {
                "name": "deviceID",
                "value": "core",
                "type": "str"
            },
            {
                "name": "propertyDP",
                "value": "_heartbeat",
                "type": "str"
            },
            {
                "name": "value",
                "value": "123456789",
                "type": "num"
            },
            {
                "name": "remote = NULL",
                "value": "NULL",
                "type": "str"
            },
            {
                "name": "value = NULL",
                "value": "NULL",
                "type": "str"
            },
            {
                "name": "NULL process",
                "value": "undefined",
                "type": "str"
            }
        ],
        "x": 250,
        "y": 2360,
        "wires": [
            [
                "6742a2bc05d81f01"
            ]
        ],
        "info": "To have a more rich test experince, this subflow implementation follows the rules:\n\n1) if you set as value any string that starts with:\n    -  global.\n    -  flow.\n    -  msg.\n\nthe value is keep from the object you entered.\n[See](https://discourse.nodered.org/t/subflows-and-configuration-late-and-runtime-parameters-binding/60042)\n\nexample:\n\n   `global.tuyastatus.core._heartbeat` \n\ninstances the parameter to last heartbeat time like `\"19:06:44\"`\n\n\n2) The special value `\"NULL\"` deletes the propery.\n\nExanple:\n\n   `remote = SOME`\n   \noutput msg:  \n````\n   msg.payload: {\n              \"remote_from\" : \"SOME\",   \n              \"deviceId\" : <deviceID>\n              ..... more\n````   \nbut:\n   `remote = NULL`\n   \noutput msg:  \n````\n   msg.payload: {\n               \"deviceId\" : <deviceID>\n              ..... more\n````              \n\n\n\n"
    },
    {
        "id": "0845efa9b5dcd529",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 105,
        "y": 2360,
        "wires": [
            [
                "7d4920121a9a25b6"
            ]
        ],
        "l": false
    },
    {
        "id": "6742a2bc05d81f01",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "send to core.logging",
        "mode": "link",
        "links": [
            "9fe80f7e.f3f7e"
        ],
        "x": 480,
        "y": 2360,
        "wires": [],
        "l": true
    },
    {
        "id": "fb6c8ae4cb623e75",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "TESTING CORE Command process (readme)",
        "info": "Testig command (standard/fast) core function.\n\nThis examples build a cammand message.\n\n**tuyaDAEMON commands**\n````\n        \"payload\": {\n              \"remote\"  : undefined | <remote>,      \n              \"device\"  : undefined | <usr-devname>|<deviceID>\n              \"property\": undefined | <usr-propname>|<propertyDP>\n              \"value\"   : undefined | <as-required (decoded)>\n        }}}}\n\nrules:\nif remote =    undefined => local instance (remote requires SYSTEM module)\nif device =    undefined (remote MUST exist) => get the list of remote devices \n                 else it MUST exist in global.alldevices else ERROR\nif property =  undefined  (device MUST exist) => SCHEMA (test: allowed by device?)\n                 else (device MUST exist and) it MUST exist in global.alldevices else ERROR\nif value =     undefined  (property MUST exist)  =>   GET (test: allowed by dp?)\n                 else  (property MUST exist ) =>   SET (test: allowed by dp?) and type checked against global.alldevices or by an optional encode function: else ERROR\n````\n\nDifferences  `fast_cmds` vs. `std_cmds`:\n- fast_cmds: device capabilities are not checked.\n- fast_cmds: only \"SKIP\", \"WW\", \"GW\" DP capabilities (in global.alldevices) are tested to process commands.\n- fast_cmds: no command log (as hide=\"CT\")\n\n\n**case ok:**\n - remote:  NULL (to use this test: chhose NULL = undefined / delete)\n - deviceID: e.g. core\n - propertyPD: must exist in global.alldevices | NULL (SCHEMA)\n         e.g. NULL |  _info\n - value: NULL (GET) | as required by propertyPD (SET)\n\nExpected result (local.code._info GET) like:\n     \n      TX: GET fake core/version                         // not in case of 'fast_cmds'\n\nthen:     \n \n      [\"RX: core/version\",\"none\"]    // after startup, before any core._info.SET(any)\n\nor:      \n      [\"RX: core/version\", object]                     // after a core._info.SET(any)\n\n\n**Error messages:**\n bad remote (both Std/Fast):\n      ASSERT fail: 'remote' requires the '_system' module installed.       \n\n bad deviceID (both Std/Fast):\n      ERROR [normalize]: not found the device 'fake' in global.alldevices.\n\n bad propertyDP (both Std/Fast):\n \n      WARNING [normalize]: In alldevices missed the 'core':dps[fake] definition.\"     \n \n    then (Std Cmds):\n      ERROR: The _core device does not implement the 'fake' property\n \n  or (Fast Cmds): \n      TypeError: Cannot read properties of undefined (reading 'capability')\n\n",
        "x": 230,
        "y": 2460,
        "wires": []
    },
    {
        "id": "4367c96e2b8dc48a",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 105,
        "y": 2520,
        "wires": [
            [
                "fcff90fc4f68c8b2"
            ]
        ],
        "l": false
    },
    {
        "id": "34ce7f2ba4a63515",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "send to core.std_cmds",
        "mode": "link",
        "links": [
            "8a1da02d.424ae"
        ],
        "x": 480,
        "y": 2520,
        "wires": [],
        "l": true
    },
    {
        "id": "e72671325e6130d8",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 105,
        "y": 2580,
        "wires": [
            [
                "cb1b2d632817af03"
            ]
        ],
        "l": false
    },
    {
        "id": "5d515b706d6149ac",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "send to core.fast_cmds",
        "mode": "link",
        "links": [
            "c084a743.290b28"
        ],
        "x": 490,
        "y": 2580,
        "wires": [],
        "l": true
    },
    {
        "id": "cb1b2d632817af03",
        "type": "subflow:f30e8140.1bed9",
        "z": "173260fb.d021ff",
        "name": "",
        "env": [
            {
                "name": "remote",
                "value": "global.instance_name",
                "type": "str"
            },
            {
                "name": "device",
                "value": "NULL",
                "type": "str"
            },
            {
                "name": "property",
                "value": "NULL",
                "type": "str"
            },
            {
                "name": "NULL process",
                "value": "undefined",
                "type": "str"
            }
        ],
        "x": 250,
        "y": 2580,
        "wires": [
            [
                "5d515b706d6149ac"
            ]
        ],
        "info": "xamples\n\n1. GET core.version local:\n\n> remote:   NULL\n> device:   core\n> property: version\n> value:    NULL\n\nExpected result (configuration dependent)\n\n     [\"RX: 'core/version' object] \n\n2. GET locale device list\n\n > remote:   global.instance_name   \n > device:   NULL\n > property: NULL\n > value:    NULL\n\nExpected result (requires system, configuration dependent)\n\n      [ \"DEVPC: RX: HAL@home/list\", array[3] ]\n          (DEVPC = actual local instance name)\n\nexpanded:\n\n    array[2]\n        0: \"DEVPC: RX: HAL@home/list\"\n        1: array[3]\n            0: \"HAL@home\"\n            1: \"core\"\n            2: \"tuya_bridge\"\n"
    },
    {
        "id": "ce5305a4d043bbb4",
        "type": "config",
        "z": "173260fb.d021ff",
        "name": "core internal  structures init- do not change",
        "properties": [
            {
                "p": "tuyastatus",
                "pt": "global",
                "to": "{}",
                "tot": "json"
            },
            {
                "p": "modules",
                "pt": "global",
                "to": "{\"devices\":{}}",
                "tot": "json"
            },
            {
                "p": "coresetup",
                "pt": "global",
                "to": "false",
                "tot": "bool"
            },
            {
                "p": "datadecode",
                "pt": "global",
                "to": "{\"user defined\":\"seenode\"}",
                "tot": "json"
            },
            {
                "p": "dataencode",
                "pt": "global",
                "to": "{\"user defined\":\"seenode\"}",
                "tot": "json"
            },
            {
                "p": "PSEUDODP",
                "pt": "global",
                "to": "[\"_T\",\"_CONNECTED\",\"_REFRESHCYCLE\",\"_REFRESH\",\"_STANDBY\",\"_RETRYTIMEOUT\",\"_FINDTIMEOUT\",\"MULTIPLE\",\"SCHEMA \",\"LIST\"]",
                "tot": "json"
            }
        ],
        "active": true,
        "x": 415,
        "y": 160,
        "wires": [],
        "icon": "font-awesome/fa-ban",
        "l": false,
        "info": "## internal CORE Configuration\ndo not change.\n\n _global.json_library_\n    Jscript code: do not modify.\n    Same in all instances.\n    Since 2.2.0\n    \n _tuyastatus_        \n    The empy object '{}' forces the cleanup of tuyastatus at startup: do not modify.\n    Same in all instances.\n\n _modules_\t\n    The empy object '{}' forces the cleanup of modules\n    at startup: do not modify.\n    Same in all instances.\n\n"
    },
    {
        "id": "2e6c4b231f4722c2",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "save",
        "func": "// stores in flow last timestamp, so GET can work\nflow.set(\"lastts\", msg.payload.data.dps._heartbeat)\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 1140,
        "wires": [
            []
        ]
    },
    {
        "id": "933b14e647ae6e8b",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "core properties",
        "func": "// filer:  processes al 'core' commands, ignore others.\n// true if is a GET command  (GET == msg.payload.value not exists)\nfunction _isget(mx) {\n    return (mx.payload.value === undefined);\n}\n// true if is a SET command  (SET == msg.value  exists)\nfunction _isset(mx) {\n    return ((mx.payload.property) && (mx.payload.value !== undefined));\n}\n// used by core.info(), list of real|virtual|fake devices actually connected\nfunction getdevicelist(_dtype){\n    var list = [];\n        tstatus = global.get(\"tuyastatus\");\n        global.get(\"alldevices.\" + _dtype).forEach((dev) =>{\n           xdev = (dev.name||dev.id);\n           conn = tstatus[xdev] && (tstatus[xdev][\"_connected\"]);\n           if (conn) list.push(xdev);\n        });\n    return list;\n}\n// the 'event' base message\nvar logmsg = {\n       \"payload\" :{\n          \"deviceId\": \"_core\",\n          \"data\": {\n             \"dps\": {}\n               }\n           }\n       }\n       \n//------------------------ main\nif (msg.to != \"_core\") return [msg];      // fast exit\n// stuff to access data\nvar oDev = context.global.alldevices.getODev(\"_core\", \"fake\");\nif (oDev === undefined){\n    node.warn(\"ERROR [core]: '_core' device NOT found on global.alldevices.\");\n    return [null];\n}\nvar pmDevName = context.global.alldevices.getDevName(oDev);\n\n// === ALL CORE SETs\nif (_isset(msg)) switch(msg.infodp) {\n case \"_info\":    //SET: trigger the global.modules update, value: dummy, not used\n   logmsg.payload.data.dps._info =  global.get(\"modules\");\n// updates device lists\n   logmsg.payload.data.dps._info.devices.real    =  getdevicelist(\"real\");\n   logmsg.payload.data.dps._info.devices.virtual =  getdevicelist(\"virtual\");\n   logmsg.payload.data.dps._info.devices.fake    =  getdevicelist(\"fake\");\n   return([null, logmsg] );\ndefault:\n   if(! context.global.PSEUDODP.includes(msg.infodp.toUpperCase())) \n       node.warn([\"ERROR [core]: SET for '_core.\" + msg.payload.property + \"' is NOT implemented.\",msg]);\n   return [null];\n }\n\n// === ALL CORE GETs\nif (_isget(msg)) switch(msg.infodp) {\n case \"schema\":                    // as pseudoDP\n    // code like single dp GETs    \n    let pName = context.global.alldevices.getDpsName(oDev, \"_DBase\");  // gets user name\n    logmsg.payload.data.dps._DBase = global.get(\"tuyastatus.\"+pmDevName+\".\"+pName);\n    //\n    logmsg.payload.data.dps._heartbeat = flow.get(\"lastts\");       // get _heartbeat (undecoded)\n    //\n    pName = context.global.alldevices.getDpsName( oDev, \"_info\");      // gets versiom\n    logmsg.payload.data.dps._info = global.get(\"tuyastatus.\"+pmDevName+\".\"+pName);\n    return([null, logmsg] );\n case \"_name\":    \n    logmsg.payload.data.dps._name = global.get(\"instance_name\");\n    return([null, logmsg] );\n case \"_info\":                   \n// from tuyastatus    \n    let qName = context.global.alldevices.getDpsName( oDev, \"_info\");   // gets user name\n    logmsg.payload.data.dps._info = global.get(\"tuyastatus.\"+pmDevName+\".\"+qName);\n    return([null, logmsg] );\n case \"_heartbeat\":                  \n //  in flow.lastts is last timestamp used by heartbeat (undecoded)\n    logmsg.payload.data.dps._heartbeat = flow.get(\"lastts\");\n    return([null, logmsg] );\n case \"_DBase\":                   \n  // from tuyastatus    \n    let bName = context.global.alldevices.getDpsName(oDev, \"_DBase\");  // gets user name\n    logmsg.payload.data.dps._DBase = global.get(\"tuyastatus.\"+pmDevName+\".\"+bName);\n    return([null, logmsg] );\n default:\n    if(! context.global.PSEUDODP.includes(msg.infodp.toUpperCase()))\n       node.warn([\"ERROR [core]: GET for '_core.\" + msg.payload.property + \"' is NOT implemented.\",msg]);\n    return [null];\n}\n\nnode.warn([\"ERROR [core]: BAD 'core' \" + (_isget(msg)?\"GET\":\"SET\") + \" message - NOT processed\", msg]);\n\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "// for _heartbeat,  inizialize local with a valid timestamp\nflow.set(\"lastts\", Date.now());\n",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 1020,
        "wires": [
            [
                "4fce3fe6e29d64a2"
            ],
            [
                "3ef151475f89529b"
            ]
        ],
        "inputLabels": [
            "all fake "
        ],
        "outputLabels": [
            "to no-core ",
            "to logging"
        ],
        "info": "Catch 'core' SET / GET commands and implements it.\nThe others messages goes to output.\n\nGenaral rules about device implementation\n\n> 1) SET changes a value (or Data Point).\n>     Returns this value (or the value actually set, if different: e.g. rounded)\n>     or\n>     SET is used as a trigger to activate some internal device operations.\n>     The value (which MUST exist because it is a SET) can be discarded ('any').\n>     SET returns the result value.\n>   \n>   2) GET returns the actual value, also from tuyastatus for simplicity.\n>      Repeatable, without side effects.\n>\n>   3) SCHEMA, if implemented, MUST return the actual value for all GETtables DP of the device.\n>      The data can be an array of {dp: value} in a single message (tuyaDEAMON records this as separate msg) or the device can return a message for each DP.\n >   \n>    4) REFRESH, if implemented, MUST produce the (eventual) update of some internal Data Points and return only the modified DPs.\n"
    },
    {
        "id": "4fce3fe6e29d64a2",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "fake_cmds ",
        "mode": "link",
        "links": [
            "369ab28b.348ebe",
            "580c2cc4.3ac424",
            "b5aba5f4.6a3778",
            "bf4e83f7.f5f21"
        ],
        "x": 1170,
        "y": 1120,
        "wires": [],
        "icon": "node-red/arrow-in.svg",
        "l": true,
        "info": "OUTPUT for commands to fake devices, unprocessed by tuyaDAEMON CORE.\n\nFlows implementing \"fake\" devices receive their inputs from this node.\n\nSame message format as'fake_cmds_IN' INPUT (see).\n"
    },
    {
        "id": "138c397d6aeae18b",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "GET _DBase",
        "props": [
            {
                "p": "payload.device",
                "v": "_core",
                "vt": "str"
            },
            {
                "p": "payload.property",
                "v": "_DBase",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 190,
        "y": 2080,
        "wires": [
            [
                "06f244a00e127392"
            ]
        ],
        "info": "Test a GET _DBase property of core.\n  \n      payload: {\n           device: \"_core\",\n           property: \"_DBase\"\n           }   \n         \n- Returns the last '_DBase' status\n\nIN global.alldevices the default definition is:\n\n               {\n                  dp: \"_DBase\"\n                  capability: \"RO\"   \n                  type: \"boolean\"\n               },\n               \nThis property 'PUSH's any variation. The user can only GET \nlast PUSHed value (in globel.alldevices capability: \"RO\", i.e. 'read only')\n----------------------\nExpected result\n\n    TX: GET fake core/_DBase\n    \nthen: \n\n    [\"RX: core/_DBase none]    // all DB disabled\n    [\"RX: core/_DBase false]   // error in one (or more) DB\n    [\"RX: core/_DBase true]    // all DBs connected.\n  \n"
    },
    {
        "id": "acaeb125bab5042d",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "GET version",
        "props": [
            {
                "p": "payload.device",
                "v": "_core",
                "vt": "str"
            },
            {
                "p": "payload.property",
                "v": "version",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 190,
        "y": 2020,
        "wires": [
            [
                "06f244a00e127392"
            ]
        ],
        "info": "Test the GET '_info' property of core, using the msg:\n\n         payload: {\n            device: \"_core\",\n            property: \"version\",\n            }\n\n Returns last list of modules and devices in use or 'none'\n----------------------\nExpected result\n\n     TX: GET fake core/version\n    \nthen: \n\nBefore you use an _info(SET) command you get 'none'.\n\n     [\"RX: core/version\",\"none\"]\n\nAfter any _info(SET) command you get the last data\ni.e. same response as last SET (see 'SET info' node).\n\n"
    },
    {
        "id": "b7356538c5201e58",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "GET _heartbeat",
        "props": [
            {
                "p": "payload.device",
                "v": "_core",
                "vt": "str"
            },
            {
                "p": "payload.property",
                "v": "_heartbeat",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 200,
        "y": 2140,
        "wires": [
            [
                "06f244a00e127392"
            ]
        ],
        "info": "Test a GET _heartbeat property of core.\n  \n      payload: {\n           device: \"_core\",\n           property: \"_heartbeat\"\n           }   \n         \n- Returns the last '_heartbeat' time.\n\nIN global.alldevices the default definition is:\n\n               {\n                    \"dp\": \"_heartbeat\",\n                    \"hide\": \"R\",\n                    \"capability\": \"RO\",\n                    \"typefield\": \"TSTAMP2TIME\"\n                }\n               \nThis property 'PUSH's at regular frequence (see 'heartbeat' node). The used can only GET last PUSHed value (in global.alldevices capability: \"RO\", i.e. 'read only') .\n\nnote:\n - \"typefield\": \"TSTAMP2TIME\" defines the decoding data function.\n - \"hide\": \"R\" to not save in DB _heartbeat records.\n \n----------------------\nExpected result\n\n     \"TX: GET fake core/_heartbeat\"\nthen\n     [ \"RX: core/_heartbeat\", \"09:27:31\" ]  \n"
    },
    {
        "id": "2d477c5c9c630c63",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "start delay (core)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 155,
        "y": 220,
        "wires": [
            [
                "addaf1aa4ff75728"
            ]
        ],
        "icon": "node-red/trigger.svg",
        "l": false
    },
    {
        "id": "b5aa690714b17aae",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "core flow startup",
        "func": "// Run as soon as possible after all 'On Start' and 'Global Config'.\n// note: the run order of all 'Global config' and all 'On Start' is undefined.\n// So, if some 'On Start' function  requires 'Global Config' data, place it there.\n// note: the delay for CORE (0.1 s) is less than other modules (0.2) (o.s. dependent, maybe adjust)\n// --------------------------------------------------- standard\nconst asMODULE = \"modules.core\";\nconst VERSION  = \"2.2.0\";\nconst asDEVICE = \"_core\";         \n// --------------------- \nglobal.set(asMODULE,  VERSION);  // update modules\n// access stuff\nvar oDev = context.global.alldevices.getODev(asDEVICE, \"fake\");\nif (oDev === undefined){\n   node.warn(\"[startup] ERROR: not found the device '\"+asDEVICE+\"' in global.alldevices.\");\n   return;\n}\nvar pmDevName =context.global.alldevices.getDevName(oDev);\n\n// ---------------- inizializes global tuyastatus\nlet tstatus = \"tuyastatus['\"+pmDevName+\"']\";\n// init using only _connected (not in alldevices), so does cleanup\nglobal.set(tstatus, {_connected: true});\n// init all GETable dps with default value\noDev.dps.forEach(adp => {\n   if (['RW','WW','GW','RO','UNK','PUSH', undefined].includes(adp.capability)){\n      // this required to handle spaces un usr-names\n      let dpname = \"['\"+ (adp.name ? adp.name:adp.dp) + \"']\";\n      switch (adp.dp){     // some special init:   \n        case \"_name\":\n            global.set(tstatus+dpname, global.get(\"instance_name\"));\n            break;\n        default:\n            global.set(tstatus+dpname,\"none\");\n        }}\n    });\n// --------------------------------------------- standard processing ends\n// here more  special device fields\n//\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "// nothing to do\n",
        "finalize": "global.set(\"modules.core\", undefined);\nreturn;",
        "libs": [],
        "x": 860,
        "y": 220,
        "wires": [
            []
        ],
        "info": "## Programme's note on startup.\n\nThe flows STARTUP is a three step pocess:\n\n1. The 'On Start' execution\n   - `node-red` grants that all 'on-start' code is executed before the flow start.\n   - None is defined about the order of execution for 'On Start' code in different nodes.\n   - So any flow 'On Start' (on  \"xxxx flow startup\" node) can contain standalone global/flow initializations, but not requiring 'global' and 'global.objects'.\n2. The global.objects construction is done asap by CORE flow ('*ENCODE/DECODE user library' and 'Global Objects constructor' nodes)\n   - After that the CORE executes the \"core flow startup\" (using also global.objects).\n   - At end CORE set the global flag \"coresetup\" to `true`.\n3. Finally, all other flow, after the test of \"coresetup\", can do the required\njobs in \"xxxx flow startup\" nodes.\n\nnote:\nIf the \"coresetup\" test fails, you get the message \"STARTUP ERROR: adjust this startup delay.\"\nIn this case fine tune the start delay of  \"xxxx flow startup\" nodes (function of host performances)\nExample: core = 0.1 (minimal); other modules: on WIN11 = 0.4, on ANDROID = 1"
    },
    {
        "id": "936b5043580ffb9c",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "GET core SCHEMA",
        "props": [
            {
                "p": "payload.device",
                "v": "_core",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 210,
        "y": 2200,
        "wires": [
            [
                "06f244a00e127392"
            ]
        ],
        "info": "Test a GET SCHEMAt property of core.\n````  \n      payload: {\n           device: \"_core\",\n           }   \n````         \n- Equivalent to\n````\n    for any 'core' GETtable property:\n       do GET property\n````\n----------------------\n\nExpected result\n\n    TX: GET SCHEMA: fake core\n    \n    \nthen: \n\n    [\"RX: core/_DBase\",true]\n    [\"RX: core/_heartbeat\",\"09:10:49\"]\n    [\"RX: core/version\",\"none\"]           // can be different after a SET(_info)"
    },
    {
        "id": "5251eb56272b7ed2",
        "type": "delay",
        "z": "173260fb.d021ff",
        "name": "",
        "pauseType": "delay",
        "timeout": "150",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1450,
        "y": 1580,
        "wires": [
            [
                "b9b5886c.153d98"
            ]
        ],
        "info": "little delay to allow startup run.\n"
    },
    {
        "id": "804c4bebfb5cc4a2",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "Core properties tests",
        "info": "see documentation in all inject nodes",
        "x": 150,
        "y": 1920,
        "wires": []
    },
    {
        "id": "74e5c72708383810",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "REST:     http://localhost:1984/tuyaDAEMON?device=core&property=_info&value=ok",
        "info": "Use this URL in a browser. You must update server and port.\n\nEspected response:\n\n {\"device\":\"core\",\"property\":\"version\",\"remote_from\":\"DEVPC\",\"status\":\"sent\"} (JSON)\n \n note: it is a SET, always the immediate REST response is 'sent'.\n You can later use a GET to get the values.",
        "x": 1060,
        "y": 1980,
        "wires": []
    },
    {
        "id": "8b291c0af14ffe09",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "REST:     http://localhost:1984/tuyaDAEMON?device=core&property=_info",
        "info": "Use this URL in a browser. You must update server and port.\n\nEspected response (JSON) (after a SET):\n     { \n      \"remote_from\":\"DEVPC\",\n      \"device\":\"core\",\n      \"property\":\"version\",\n      \"value\": {\n          \"devices\":{\n              \"real\":[],\n              \"virtual\":[],\n              \"fake\":[\"core\"]\n              },\n           \"core\":\"2.2.0\"\n           }\n      }\n",
        "x": 1030,
        "y": 2020,
        "wires": []
    },
    {
        "id": "b093ccdf22269769",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "REST:     http://localhost:1984/tuyaDAEMON?device=core&property=_DBase",
        "info": "Use this URL in a browser. You must update server and port.\n\nEspected response:\n\n{\"device\":\"core\",\"property\":\"_DBase\",\"remote_from\":\"DEVPC\",\"value\":true} (JSON)\n \n",
        "x": 1040,
        "y": 2080,
        "wires": []
    },
    {
        "id": "babfbb44c02a7a3f",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "REST:     http://localhost:1984/tuyaDAEMON?device=core&property=_heartbeat",
        "info": "Use this URL in a browser. You must update server and port.\n\nEspected response:\n\n{\"device\":\"core\",\"property\":\"_heartbeat\",\"remote_from\":\"DEVPC\",\"value\":\"20:58:56\"} (JSON)\n \n",
        "x": 1050,
        "y": 2140,
        "wires": []
    },
    {
        "id": "65fb5ac42cb9c99f",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "REST:     http://localhost:1984/tuyaDAEMON?device=core",
        "info": "Use this URL in a browser. You must update server and port.\n\nEspected response (JSON):\n\n         {\n         \"remote_from\":\"DEVPC\",\n         \"device\":\"core\",\n         \"schema\":{\n             \"_connected\":true,\n             \"_DBase\":true,\n             \"_heartbeat\":\"20:59:56\",\n             \"version\":{\n                  \"devices\":{\n                     \"real\":[],\n                     \"virtual\":[],\n                     \"fake\":[\"core\"]\n                     },\n                  \"core\":\"2.2.0\"\n                  },\n             \"_t\":1648065596\n             }\n         }",
        "x": 980,
        "y": 2200,
        "wires": []
    },
    {
        "id": "f09d9a2c6fc1d0ce",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "Same tests using REST (readme)",
        "info": "All tuyaDEAMON commads and events can be handled via http REST\n\nREST URL (update the host:port to select tuyaDEAMON instance):\n````    \n  http://<localhost:1984>/tuyaDAEMON[?device=<device>[&property=<property>[&value=<JSON value>]]]\n````\n\nnote:\n1. REST commands are handled only on local instance. 'remote' not implemented.\n2. Special REST case, only   `http://<localhost:1984>/tuyaDAEMON` \n\n  Response, JSON device list (from global.tuyastatus keys):\n````\n                 {\n                 \"remote_from\":\"DEVPC\",\n                 \"list\":[\n                     \"core\"\n                     ]\n                 }\n````\n3. else as standard tuyaDEAMON SCHEMA, GET, SET commands.\n\nExamples tested using 'chrome' as browser.\n\n\n\n",
        "x": 890,
        "y": 1920,
        "wires": []
    },
    {
        "id": "13cdfb5d729a9a8a",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "TESTING CORE SHARE commands (readme)",
        "info": "Testig SHARE command (share IN) core function.\n\n\nThis example build an user 'share' message.\n\n**tuyaDEAMON user share**\n    \n```\n     \"info\": {                     \n                  \"\"        // any, used as 'IN parameters' into the expressions\n             }\n     \"share\": [{\n        \"test\": [                                      // optional: default true\n           `condition-string-1`        // eval(condition-string-1) => true|false          \n            ... more test strings (AND) ... ],\n        \"action\": [{                                  // standard command fields\n            \"remote\"  : \"NAMEXX\",                                    // optional\n            \"device\"  : @expession | string | null | undefined,\n            \"property\": @expession | string | null | undefined,    \n            \"value\"   : @expession | boolean | int | string | object | null | undefined\n             } ... more actions (sequence)...]\n         } ... more {(test[],) action[]} (selection) ...\n      ]\n    \n```\nSpecial rules of evaluation for action.device (and property, value) to build the actual cammand:\n    \n```\n    share.action.device = @expession       => command.payload.device = eval(expession)\n    share.action.device = string (object)  => command.payload.device = share.action.device\n    share.action.device = null             => command.payload.device = undefined\n    share.action.device = undefined|missed => command.payload.device = info.device || undefined.\n````\n[see](https://github.com/msillano/tuyaDAEMON/wiki/tuyaDAEMOM-global.alldevices#share-actions)\n",
        "x": 230,
        "y": 2680,
        "wires": []
    },
    {
        "id": "425cd3d667867a32",
        "type": "inject",
        "z": "173260fb.d021ff",
        "name": "user share",
        "props": [
            {
                "p": "info.start",
                "v": "\"11:00:00\"",
                "vt": "str"
            },
            {
                "p": "share",
                "v": "[{\"test\":[\"tuyastatus.core._heartbeat > msg.info.start\"],\"action\":[{\"device\":\"_core\",\"property\":\"_info\"}]},{\"test\":[\"tuyastatus.core._heartbeat < msg.info.start\"],\"action\":[{\"device\":\"_core\",\"property\":\"_DBase\"}]}]",
                "vt": "json"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 160,
        "y": 2740,
        "wires": [
            [
                "9593347f2142b552"
            ]
        ],
        "info": "Sample 'share'\n\nUsing a 'share' to build a conditional command.\n\nrule: \n\n     if (actual-time > info.start (e.g. \"11:00:00\")) do:\n            GET   core._info()\n     else do:\n            GET   core._DBase()\n\nnote: this implementation requires _heartbeat running:\n\n     \"test\": [\"tuyastatus.core._heartbeat > msg.info.start\"],\n\n\nTo use a test unrelated to _heartbeat, replace with:\n\n     \"test\": [\"var xnow = new Date();\n               (xnow.toLocaleTimeString() > msg.info.start)\"],\n"
    },
    {
        "id": "9593347f2142b552",
        "type": "link out",
        "z": "173260fb.d021ff",
        "name": "send to core.share IN",
        "mode": "link",
        "links": [
            "3d54171f.a9e138"
        ],
        "x": 480,
        "y": 2740,
        "wires": [],
        "l": true
    },
    {
        "id": "addaf1aa4ff75728",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "*ENCODE/DECODE user library",
        "func": "// constructs two global objects without data (function libraries):\n\ncontext.global.datadecode = global.get(\"datadecode\");\ncontext.global.dataencode = global.get(\"dataencode\");\n\n// -- CUSTOMIZATION: ===============================\n// Data codification is function of the device and dps. \n// New devices can require new functions.\n// You can add new decoding/encoding methods\n//   or update existing ones for localization.\n\n//============= here DECODE functions (data FROM devices) \n    // to format values from device messages to standard form\n    // add new functions to array as required\ncontext.global.datadecode.BYTESMALLFLOAT= function (value) {\n        // exanplFe: C3H = 195 => 19.5  (°C: units as from device setup)\n        // required by thermostat, meter\n        return (Number(value) / 10.0);\n    };\n    \ncontext.global.datadecode.INTE2FLOAT = function (value) {\n        // for now, only DECODE, required by  meter\n        return (Number(value) / 100.0);\n    };\n\ncontext.global.datadecode.BOOLEANONOFF = function (value) {\n        // transform (false, 0, \"\")/1 , to 'OFF'/'ON'\n        // en: can be localized for internationalization\n        return (!value ? \"OFF\" : (value == 1 ? \"ON\" : value));\n    };\n    \ncontext.global.datadecode.BOOLEANOPENCLOSE = function (value) {\n        // transform (false, 0, \"\")/1, to 'OPEN'/'CLOSE'\n        // en: can be localized for internationalization\n        return (!value ? \"CLOSE\" : (value == 1 ? \"OPEN\" : value));\n    };\n\ncontext.global.datadecode.ENUMONOFFHOLD = function (value) {\n        // transform 0/1/2 to OFF/ON/HOLD\n        // changed to use same strings as many switches\n        // en: can be localized for internationalization off|on|memory\n        return (value == 0 ? \"off\" : (value == 1 ? \"on\" : (value == 2 ? \"memory\" : value)));\n    };\n\ncontext.global.datadecode.STRUCTARGETTEMP = function (value) {\n        // transform from base64(Uint8Array[17]) to object:\n        //   {\"count\":4,\n        //    \"changes\":[{\"time\":\"00:00\",\"temp\":15.5},\n        //              {\"time\":\"07:00\",\"temp\":20},\n        //              {\"time\":\"16:30\",\"temp\":21},\n        //              {\"time\":\"21:00\",\"temp\":16.5}]}\n        // required by thermostat\n        function minTohm(min) { // local function\n            h = (~~(min / 60));\n            m = min % 60;\n            return (h > 9 ? h : '0' + h) + \":\" + (m > 9 ? m : '0' + m);\n        }\n\n        b = Buffer.from(value, \"base64\");\n        var n = b.readUInt8(0);\n        var result = {\n            count: n,\n            changes: []\n        };\n        for (var i = 0; i < n; i++) {\n            result.changes[i] = {\n                time: minTohm(b.readUInt16BE(i * 4 + 1)),\n                temp: b.readUInt16BE(i * 4 + 3) / 10\n            };\n        }\n        //     return (JSON.stringify(result));\n        return (result);\n    }; // ends function\n\ncontext.global.datadecode.ARRAY8INT = function (value) {\n        // transform  base64(Uint8Array[X]) to UInt8[]\n        // X=24 =>  [16,16,15,15,14,14,16,17,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\"\n        // required by thermostat\n        b = Buffer.from(value, \"base64\");\n        return (\"[\" + new Uint8Array(b).toString() + \"]\");\n    };\n\ncontext.global.datadecode.STRUCTTIMEHMS = function (value) {\n        // tentative, on work\n        // transform  base64(Uint16Array[3]) to \"HH:MM:SS\" ??\n        // required by thermostat ??\n        b = Buffer.from(value, \"base64\");\n        const uint16arr = new Uint16Array(\n                b.buffer,\n                b.byteOffset,\n                b.length / Uint16Array.BYTES_PER_ELEMENT);\n        return ((Uint16Array[0] > 9 ? Uint16Array[0] : \"0\" + Uint16Array[0]) + \":\" +\n            (Uint16Array[1] > 9 ? Uint16Array[1] : \"0\" + Uint16Array[1]) + \":\" +\n            (Uint16Array[2] > 9 ? Uint16Array[2] : \"0\" + Uint16Array[2]));\n    };\n    \ncontext.global.datadecode.STRUCTCOLOUR = function (value) {\n        //  Transforms  RRGGBB0000FFFF to objec\n        //      {   \"hex\":\"RRGGBBHHHHSSVV\" }\n        //  or: {   \"r\": RR,\n        //          \"g\": GG,\n        //          \"b\": BB\n        //          \"h\":HHHH,\n        //          \"s\": SS,\n        //          \"v\": VV  }\n        // 100% = 0x64\n        // required by humidifier led\n        b = Buffer.from(value, 'hex');\n        var result = {\n            hex: value,\n        };\n        result[\"r\"] = b.readUInt8(0);\n        result[\"g\"] = b.readUInt8(1);\n        result[\"b\"] = b.readUInt8(2);\n        result[\"h\"] = b.readUInt16BE(3)\n        result[\"s\"] = b.readUInt8(5);\n        result[\"v\"] = b.readUInt8(6);\n        return (result);\n    };\n    \ncontext.global.datadecode.ENUMHIGHGOODLOW = function (value) {\n        // transform 0/1/2 to LOW/GOOD/HIGH\n        // en: can be localized for internationalization\n        return (value == 0 ? \"LOW\" : (value == 1 ? \"GOOD\" : (value == 2 ? \"HIGH\" : value)));\n    };\n    \ncontext.global.datadecode.RECMODE = function (value) {\n        // transforms string '1'/'2' to  'continuous'/'events'\n        // it|en: can be localized for internationalization\n        return (value == 2 ? \"continuous\" : (value == 1 ? \"events\" : value));\n    };\n    \ncontext.global.datadecode.STRUCTINCH = function (value) {\n        // switch inching value\n        b = Buffer.from(value, \"base64\");\n        var result = {\n            inching: (b.readUInt8(0) !== 0),\n            delay: b.readUInt16BE(1)\n        };\n        return (result);\n    };\n    \ncontext.global.datadecode.STRUCTRAND = function (value) {\n         // switch random data\n       function minTohm(min) { // local function\n            h = (~~(min / 60));\n            m = min % 60;\n            return (h > 9 ? h : '0' + h) + \":\" + (m > 9 ? m : '0' + m);\n        }\n        function daystring(val) {\n            var res = \"\";\n            week = \"DLMMGVS\"; // en: SMTWTFS\n            mask = 1;\n            for (var i = 0; i < 7; i++) {\n                res += (val & mask) ? week.charAt(i) : '-';\n                mask = mask << 1;\n            }\n            return (res);\n        }\n        if (value.length < 5)\n            return (value);\n        b = Buffer.from(value, \"base64\");\n        var randdef = [];\n        for (var i = 0; i < b.length / 6; i++) {\n            var o = {\n                active: (b.readUInt8(i * 6 + 0) !== 0),\n                days: daystring(b.readUInt8(i * 6 + 1)),\n                start: minTohm(b.readUInt16BE(i * 6 + 2)),\n                end: minTohm(b.readUInt16BE(i * 6 + 4))\n            };\n            randdef[randdef.length] = o;\n        }\n        return randdef;\n    };\n    \n context.global.datadecode.STRUCTREPEAT = function (value) {\n               // switch repeat data\n        function minTohm(min) { // local function\n            h = (~~(min / 60));\n            m = min % 60;\n            return (h > 9 ? h : '0' + h) + \":\" + (m > 9 ? m : '0' + m);\n        }\n        function daystring(val) {\n            days = \"\";\n            week = \"DLMMGVS\"; // en: SMTWTFS\n            mask = 1;\n            for (var i = 0; i < 7; i++) {\n                days += (val & mask) ? week.charAt(i) : '-';\n                mask = mask << 1;\n            }\n            return (days);\n        }\n        if (value.length < 5)\n            return (value);\n        b = Buffer.from(value, \"base64\");\n        var result = [];\n        for (var i = 0; i < b.length / 10; i++) {\n            var o = {\n                active: (b.readUInt8(i * 10 + 0) !==  0),\n                days: daystring(b.readUInt8(i * 10 + 1)),\n                start: minTohm(b.readUInt16BE(i * 10 + 2)),\n                end: minTohm(b.readUInt16BE(i * 10 + 4)),\n                on: minTohm(b.readUInt16BE(i * 10 + 6)),\n                off: minTohm(b.readUInt16BE(i * 10 + 8))\n            };\n            result[result.length] = o;\n        }\n        return (result);\n    };\n\n context.global.datadecode.SDSPACES = function (value) {\n        // transform SD data <total>|<used>|<free> to object.\n        // en: can be localized for internationalization\n        var sizes = value.split(\"|\");\n        var result = {\n            total: new Intl.NumberFormat().format(Number(sizes[0])),\n            used:  new Intl.NumberFormat().format(Number(sizes[1])),\n            free:  new Intl.NumberFormat().format(Number(sizes[2])),\n        }\n        return (result);\n    };\n    \ncontext.global.datadecode.TSTAMP2TIME = function (value) {\n     // for now, only DECODE\n    // transform a timestanp to local time string.           \n           tx = new Date(value);\n           return (tx.toLocaleTimeString());\n     };\n\n// ======= here ENCODE functions (user data TO device) \n// same name as decode function\n\ncontext.global.dataencode.BYTESMALLFLOAT = function (value) {\n        // transforms temperature to byte: 19.5° => 195 => C3H\n        // required by thermostat\n        var x = value;\n        if (typeof value === 'string')\n            x = Number.parseFloat(value);\n        if (Number.isNaN(x)) {\n            throw \"'value' is not a number!\";\n        }\n        return ~~(x * 10.0);\n    };\n\n\ncontext.global.dataencode.BOOLEANONOFF = function (value) {\n        // transforms 'ON'/'OFF' to boolean  true/false (very tolerant :  see https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons)\n        // it|en: can be localized for internationalization\n        if ((value == 0) || (value == null) || (value.toUpperCase() === \"OFF\") || (value.toUpperCase() === \"FALSE\") || (value.toUpperCase() === \"NO\"))\n            return false;\n        return true;\n    };\n\ncontext.global.dataencode.BOOLEANOPENCLOSE = function (value) {\n        // transforms 'OPEN'/'CLOSE' to boolean  true/false\n        // it|en: can be localized for internationalization\n        if ((value == 0) || (value == null) || (value.toUpperCase() === \"CLOSE\") || (value.toUpperCase() === \"CHIUSA\"))\n            return false;\n        return true;\n    };\n\ncontext.global.dataencode.ENUMONOFFHOLD = function (value) {\n        // transforms 'OFF'/'ON'/'HOLD' to string '0'/'1'/'2'\n        // it|en: can be localized for internationalization\n        if ((value == 0) || (value == null) || (value.toUpperCase() === \"OFF\") || (value.toUpperCase() === \"SPENTO\") || (value.toUpperCase() === \"NO\"))\n            return \"0\";\n        if ((value == 1) || (value.toUpperCase() === \"ON\") || (value.toUpperCase() === \"ACCESO\") || (value.toUpperCase() === \"YES\"))\n            return \"1\";\n        return \"2\";\n    };\n\ncontext.global.dataencode.STRUCTARGETTEMP = function (value) {\n        // transform the JSON structure:\n        //   {\"count\":4,\n        //    \"changes\":[{\"time\":\"00:00\",\"temp\":15.5},\n        //              {\"time\":\"07:00\",\"temp\":20},\n        //              {\"time\":\"16:30\",\"temp\":21},\n        //              {\"time\":\"21:00\",\"temp\":16.5}]}\n        // to  base64(Uint8Array[17])\n        // required by thermostat\n\n        function hmTomin(hm) { // local function\n            pieces = hm.split(':');\n            return (parseInt(pieces[0]) * 60 + parseInt(pieces[1]));\n        }\n        function mult10(value) {\n            return ~~(Number.parseFloat(value) * 10.0)\n        }\n\n        var o = value;\n        if (typeof value === 'string')\n            o = JSON.parse(value);\n  //      node.warn(\"in code \" + value);\n        if (o.count !== undefined) {\n            var buf = Buffer.alloc(o.count * 4 + 1);\n\n            buf.writeInt8(o.count, 0);\n            for (var i = 0; i < o.count; i++) {\n                buf.writeInt16BE(hmTomin(o.changes[i].time), i * 4 + 1);\n                buf.writeInt16BE(mult10(o.changes[i].temp), i * 4 + 3);\n            }\n            return buf.toString('base64');\n        } else {\n            throw \"'value' is not a {time,T}[4] struct\";\n        }\n    };\n\ncontext.global.dataencode.ARRAY8INT = function (value) {\n        // Transforms a UInt8Array, e.g.[17,16,16,16,15,15,17,18,19,19,18,18,18,18,17,16,17,18,18,0,0,0,0,0]\n        // as object or JSON string\n        // to  coded64 data => ERAQEA8PERITExISEhIREBESEgAAAAAA\n        // required by thermostat\n        var o = value;\n        if (typeof value === 'string')\n            o = JSON.parse(value);\n        if (Array.isArray(o)) {\n            b = Buffer.from(o);\n            return b.toString('base64');\n        } else {\n            throw \"'value' is not a (json) array !\";\n        }\n    };\n\n context.global.dataencode.STRUCTTIMEHMS = function (value) {\n        //  Transforms a time \"HH:MM:SS\"\n        //  in coded data base64(Uint16Array[3])\n        //  tentative, on work\n        pieces = value.split(':');\n        var buf = Buffer.alloc(6);\n        buf.writeInt16LE(parseInt(pieces[0]), 0);\n        buf.writeInt16LE(parseInt(pieces[2]), 2);\n        buf.writeInt16LE(parseInt(pieces[4]), 4);\n        return buf.toString('base64');\n    };\n\ncontext.global.dataencode.STRUCTCOLOUR = function (value) {\n        // accepts: JSON or object\n        // encode:\n        //      {   \"hex\":\"RRGGBBHHHHSSVV\" }\n        //  or: {   \"r\": RR,\n        //          \"g\": GG,\n        //          \"b\": BB\n        //        ( \"h\":HHHH,\n        //          \"s\": SS,\n        //          \"v\": VV )  }\n        // 100% = 0x64\n        //  required by humidifier led\n        var o = value;\n        if (typeof value === 'string')\n            o = JSON.parse(value);\n        if ((o.hex !== undefined) && (typeof o.hex === 'string') && (o.hex.length == 14))\n            return (o.hex);\n        if ((o.r === undefined) || (o.g === undefined) || (o.b === undefined)) {\n            throw \"'value' is not valid hex|rgb object!\";\n        }\n        var buf = Buffer.alloc(7);\n        buf.writeUInt8(o.r, 0);\n        buf.writeUInt8(o.g, 1);\n        buf.writeUInt8(o.b, 2);\n        if (o.h !== undefined) {\n            buf.writeUInt16BE(o.h, 3);\n            buf.writeUInt8(o.s, 5);\n            buf.writeUInt8(o.v, 6);\n        } else {\n            buf.writeUInt16BE(0, 3);\n            buf.writeUInt8(255, 5); //fixed ?\n            buf.writeUInt8(255, 6); //fixed ?\n        }\n        return buf.toString('hex');\n    };\n    \ncontext.global.dataencode.ENUMHIGHGOODLOW = function (value) {\n        // transforms 'LOW'/'GOOD'/'HIGH' to string '0'/'1'/'2'\n        // it|en: can be localized for internationalization\n        // required by switch\n        if ((value == 0) || (value == null) || (value.toUpperCase() === \"LOW\") || (value.toUpperCase() === \"BASSA\"))\n            return \"0\";\n        if ((value.toUpperCase() === \"HIGH\") || (value == 2) || (value.toUpperCase() === \"ALTA\"))\n            return \"2\";\n        return \"1\";\n    };\n    \ncontext.global.dataencode.RECMODE = function (value) {\n        // transforms 'continuous'/'events' to string '1'/'2'\n        // it|en: can be localized for internationalization\n        // required by switch\n        if ((value == 1) || (value.toUpperCase() === \"EVENTS\") || (value.toUpperCase() === \"EVENTI\"))\n            return \"1\";\n        return \"2\";\n    };\n    \ncontext.global.dataencode.STRUCTINCH = function (value) {\n        var o = value;\n        if (typeof value === 'string')\n            o = JSON.parse(value);\n        var buf = Buffer.alloc(3);\n        buf.writeUInt8((o.inching) ? 1 : 0, 0);\n        buf.writeUInt16BE(o.delay, 1);\n        return buf.toString('base64');\n    };\n\ncontext.global.dataencode.STRUCTRAND = function (value) {\n        function hmTomin(hm) { // local function\n            pieces = hm.split(':');\n            return (parseInt(pieces[0]) * 60 + parseInt(pieces[1]));\n        }\n        function dayscode(val) {\n            result = 0;\n            mask = 1;\n            for (var i = 0; i < 7; i++) {\n                result |= (val.charAt(i) == '-') ? 0 : mask;\n                mask = mask << 1;\n            }\n            return (result);\n        }\n        var o = value;\n        if (typeof value === 'string')\n            o = JSON.parse(value);\n        var buf = Buffer.alloc(6 * o.length);\n        for (let i = 0; i < o.length; i++) {\n            buf.writeUInt8((o[i].active) ? 1 : 0, i * 6 + 0);\n            buf.writeUInt8(dayscode(o[i].days), i * 6 + 1);\n            buf.writeUInt16BE(hmTomin(o[i].start), i * 6 + 2);\n            buf.writeUInt16BE(hmTomin(o[i].end), i * 6 + 4);\n        }\n        return buf.toString('base64');\n    };\n\ncontext.global.dataencode.STRUCTREPEAT = function (value) {\n        function hmTomin(hm) { // local function\n            pieces = hm.split(':');\n            return (parseInt(pieces[0]) * 60 + parseInt(pieces[1]));\n        }\n        function dayscode(val) {\n            result = 0;\n            mask = 1;\n            for (var i = 0; i < 7; i++) {\n                result |= (val.charAt(i) == '-') ? 0 : mask;\n                mask = mask << 1;\n            }\n            return (result);\n        }\n\n        var o = value;\n        if (typeof value === 'string')\n            o = JSON.parse(value);\n        var buf = Buffer.alloc(10 * o.length);\n        for (let i = 0; i < o.length; i++) {\n            buf.writeUInt8((o[i].active) ? 1 : 0, i * 10 + 0);\n            buf.writeUInt8(dayscode(o[i].days), i * 10 + 1);\n            buf.writeUInt16BE(hmTomin(o[i].start), i * 10 + 2);\n            buf.writeUInt16BE(hmTomin(o[i].end), i * 10 + 4);\n            buf.writeUInt16BE(hmTomin(o[i].on), i * 10 + 6);\n            buf.writeUInt16BE(hmTomin(o[i].off), i * 10 + 8);\n        }\n        return buf.toString('base64');\n    };\n\ncontext.global.dataencode.SDSPACES = function (value) {\n           // for now, only DECODE\n        node.warn(\"ERROR: SDSPACES only decode()\")\n        return (value);\n    };\n    \ncontext.global.dataencode.TSTAMP2TIME = function (value) {\n           // for now, only DECODE\n        node.warn(\"ERROR: TSTAMP2TIME only decode()\")\n        return (value);\n    };\n    \n    \n//---  do not change here ------------------    \ndelete(context.global.dataencode[\"user defined\"]);\ndelete(context.global.datadecode[\"user defined\"]);\nreturn msg;\n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 220,
        "wires": [
            [
                "f1faa40f133e92fd"
            ]
        ],
        "info": "CUSTOMIZATION\nA new device data format requires two functions: `decode` (to GET data FROM device) and `encode` (to SET user data TO device):\n\n- Edit this node code to add a new custom decode/encode function\n- Use same name for both functions (e.g. CODENAME).\n\nthen: \n- add the new CODENAME in `tuyahome.lookupdecode` DB table (if you use tuyadaemontoolkit)\n- now you can use CODENAME in global.alldevices, in the 'dp.typefield'"
    },
    {
        "id": "3ef151475f89529b",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "*pass-all",
        "func": "\n// This node does nothing.\nreturn msg;\n// You can replace it with a 'delay' node to limit the rate, \n// but only for rate less than 600 message/10 s. \n// (actrual max rate 2'400 msg/ 10 s on my PC,  using _doBenchmark and _zeroTast)",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 1240,
        "wires": [
            [
                "81a9b329.092b1",
                "d943c0e6.b7946"
            ]
        ],
        "info": "Thi node do nothing.\n\nIt is possible to repalace it wit a "
    },
    {
        "id": "f1faa40f133e92fd",
        "type": "function",
        "z": "173260fb.d021ff",
        "name": "Global Objects constructor",
        "func": "\n// constructs 2 global objects (singleton):\ncontext.global.PSEUDODP   = global.get(\"PSEUDODP\");\ncontext.global.alldevices = global.get(\"alldevices\");\n\n// adding required methods to context.global.alldevices.\n\n// return the device object\n//  called with user-name|(deviceID|CID)\n//  limit: null (= all, default)|\"real\"|\"virtual\"!\"fake\"\n//  returns: object|undefined (= not found)\ncontext.global.alldevices.getODev = function(id, limit = null){\n      function _checkobj(list, dx) {\n          var  o = list.find(device => device.name === dx);\n          if (o === undefined)\n              o = list.find(device => device.id == dx);\n          if (o === undefined)\n              o = list.find(device => device.cid == dx);\n          return (o);\n          }  \n      function _okcheck(lim, branch) {\n          return ((lim === null) || (lim == branch))\n          }\n// finds ODev       \n   var odev;\n   if (id === undefined) return (odev);\n   if ((odev == undefined) && _okcheck(limit, 'real'))\n      odev = _checkobj(this.real, id);\n   if ((odev == undefined) && _okcheck(limit, 'virtual'))\n      odev = _checkobj(this.virtual, id);\n   if ((odev == undefined) && _okcheck(limit, 'fake'))\n      odev = _checkobj(this.fake, id);\n   return (odev);\n}// given device-object, returns device-name or undefinef\ncontext.global.alldevices.getDevName =  function(odev) { \n    if (odev === undefined) return undefined; \n    return (odev.name === undefined ? (odev.cid == undefined ? odev.id : odev.cid) : odev.name);\n    }        \n//   given device-object, returns connection-name (device or gateway) or undefined \ncontext.global.alldevices.getConnectName = function(odev) {\n    if (odev === undefined) return undefined;  \n    if (odev.cid === undefined) \n         return(odev.name === undefined ? odev.id : odev.name);  \n    var o_gat = this.real.find(device => device.id === odev.gateway);   \n    if (o_gat === undefined) return o_gat;   \n    return (o_gat.name === undefined ? o_gat.id : o_gat.name);\n    }\n\n// given device-object and a property (name|dp) returns dp-object\ncontext.global.alldevices.getODps = function(odev, property) { \n    if (odev === undefined) return undefined;\n    if (Array.isArray(odev.dps)) {  \n          var p = odev.dps.find(data => ((data.name === property) || (data.dp == property))); \n          return (p);\n          }    \n    return (undefined);\n    }\n \n// given device-object and a property (name|dp) returns dp-name\n context.global.alldevices.getDpsName = function(odev, property) {\n if (Array.isArray(odev.dps)) {\n     var p = odev.dps.find(data => ((data.name === property) || (data.dp == property))); \n     if(p !== undefined)\n          return (p.name === undefined ? p.dp : p.name);\n      }  \n    return (property);\n    }\n//  given a msg-std: device + (property + (value)), device-object, DP-object \n//  returns a msg normalized for internal use:\n//  redefined to use with 'tuyastatus' and info\n//  `msg.payload.device   = usr-dev-name|msg.to`\n//  `msg.payload.property = undef|usr-dp-name|msg.infodp`\n//  `msg.payload.value    = undef|any`  \n//  plus, used as keys:\n//    `msg.to     = cid|deviceId`         (mandatory)\n//    `msg.infodp = dp|pseudoDP`          (mandatory)\n//    `msg.hide   = \"\"|\"(K)(C)(E)(R)(T)\"` (visibility, since 2.2.0)\n//  plus, in case of error:\n//     msg.error  =\"ERROR message\"        (abort)\n//     msg.warning=\"WARNING message\"      (continue)\n// use:\n/*\n    var o = context.global.alldevices.getODev(msg.payload.device);\n    var p = context.global.alldevices.getODps(o, msg.payload.property);\n    msg   = context.global.alldevices.normalize( msg, o, p);\n    if (msg.error){\n        node.warn([\"[from-node] \"+ msg.error, msg]);\n        return([null]);\n    }\n    if (msg.warning){\n       node.warn(\"[from-node] \"+ msg.warning);\n    }\n*/\n context.global.alldevices.normalize = function (xmsg, Do, Po){\n    if(!Do) {\n         xmsg['error'] = \"ERROR [normalize]: not found the device '\"+xmsg.payload.device+\"' in global.alldevices.\"; \n         return (xmsg); \n         }\n    xmsg.payload.device = (Do.name) ? Do.name: (Do.cid || Do.id);\n    xmsg['to'] =  Do.cid || Do.id;\n    if(! this.fake.includes(Do)) \n        xmsg['toDev'] = Do.cid ? Do.gateway: Do.id; \n    xmsg['infodp'] = 'schema';\n    if (xmsg.payload.property) { \n        if ((Po === undefined) || (Po.dp === undefined)) { \n            xmsg.infodp  = xmsg.payload.property; \n            if (! context.global.PSEUDODP.includes(xmsg.payload.property.toUpperCase())) \n               xmsg['warning'] =\"WARNING [normalize]: In alldevices missed the '\"+xmsg.payload.device+\"':dps[\" + xmsg.payload.property + \"] definition.\"; \n        } else { \n            xmsg.infodp =  Po.dp.toString(); \n            xmsg.payload.property =  Po.name || Po.dp; \n        }\n    } \n    if (xmsg['infodp'] === 'schema')\n       delete(xmsg.payload.value);\n    xmsg.hide = ((Do && Do.hide)? Do.hide:\"\") + ((Po && Po.hide)? Po.hide:\"\");\n    return (xmsg); \n }\n\n// given a value and a DP-object\n// returns the value encoded or the good type (uses: typefield | type | default rules) )\n context.global.alldevices.encodeValue =  function(value, dpObj={}){\n      if((value===undefined)||(dpObj===undefined)) return(value);\n      // general values 'null' \n      if((value==='')||(value===null)||(value==='NULL')||(value==='null'))return(null);\n      if((!dpObj.typefield)||(dpObj.typefield==='NONE')||(dpObj.typefield==='NULL')){\n          try{\n              switch(dpObj.type){      // type forces output\n                 case'boolean':\n                     return(!((value===false)||(value==='false')||(value==='FALSE')||(value===0)));\n                 case'int':\n                 case'enum':\n                     return(Number(value));\n                 case'string':\n                     return(value.toString());\n                 default:              // also undefined: default rules\n                    if(typeof(value)==='boolean') return(value);\n                    if(value==='false') return(false);\n                    if(value==='true') return(true);\n                    return((parseInt(value) == value)? parseInt(value):value);\n                                  // \"37\" => 37, but \"4.5\" => \"4.5\"\n                  }\n          }\n          catch(error){\n              return({error:'ERROR [encodeValue]: In conversion from value('+value+') to type '+dpObj.type+': '+error});\n             }\n      }else{    // try the encode function\n         if(!context.global.dataencode[dpObj.typefield])\n              return({error:'ERROR [encodeValue]: Not found the encode.'+dpObj.typefield+' function().'});\n         let nval;\n         try{\n             nval=(context.global.dataencode[dpObj.typefield](value));\n             }\n         catch(error){\n             return({error:'ERROR [encodeValue]: In encode.'+dpObj.typefield+' function, on value ('+value+'): '+error});\n             }\n         return(nval);\n      }\n }  \n \n global.set(\"coresetup\", true);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 220,
        "wires": [
            [
                "b5aa690714b17aae"
            ]
        ]
    },
    {
        "id": "0dd0dc3ff2eb3c94",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "TESTING CORE Logging process (readme)",
        "info": "Testig event core function.\n\nThis example allow the user to build any event message.\n\n**tuyaDAEMON events** (basic, see `core.logging` node)\n````\nmsg.payload:{     \n        \"remote_from\": undefined|rem-name                  // only if from remote\n        \"deviceId\": deviceID|dev-name       \n        \"data\": {\n            \"dps\":{\n                [dp|dp-name]: value                        // encoded if required\n                ....                                           // one or more DPs\n            }}}}\n\nrules:\nremote_from =  undefined => local instance (remote requires SYSTEM module)  \n                  else (test: in `global.remotemap`?) 'rem-name' else 'UNKNOWN'.\ndeviceId  :  MUST exist in `global.alldevices` else ERROR\ndp|dp-name  :  MUST exist in `global.alldevices` else WARNING\nvalue     :  if `DP.typefield` exists the value is checked by the decode() function, else any.\n````\n\n**case ok:**\n - remote:  NULL (in node `do logging` process: NULL => undefined) or rem-name (from `global.remotemap`)\n - deviceID:    e.g. 'core' or '_core'.\n - propertyPD:  e.g.   `_DBase`, `_heartbeat`...\n - value: Examples\n       ` _DBase`: \"type\": \"boolean\". Accepted: any.\n        `_heartbeat`: \"typefield\": \"TSTAMP2TIME\". Accepted timestamp, i.e. any number > 0 (see core.*ENCODE/DECODE user library node).\n------------------\n\nExpected result (local.code._heartbeat(\"123456789\")) :\n \n      [ \"RX: core/_heartbeat\", \"11:17:36\" ]    \n\nExpected result (ANDROID.code._DBase(\"maybe\")) :\n    \n      [\"ANDROID: RX: core/_DBase\",\"maybe\"]\n \n \n**Error messages:**\n\n bad remote:\n\n      ASSERT fail: 'remote' requires the '_system' module installed.   \n  or:      \n      [\"UNKNOWN: RX: core/_heartbeat\",\"11:17:36\"]\n\n bad deviceID:\n \n      \"ERROR [OUT data]: ADD to alldevices the real/fake deviceId: corex (undefined)\"\n      \n bad propertyDP:\n \n      [\"WARNING [OUT data]: In alldevices missed the 'core':dps[fake] definition.\"]\n\n    then (the unknown DPs are always processed to capture rare events from devices):\n\n      [\"ANDROID: RX: core/fake\",\"maybe\"]\n \n bad value (variable: from decode() function):\n    \n     [\"ANDROID: RX: core/_heartbeat\", \"Invalid Date\"]   \n",
        "x": 230,
        "y": 2300,
        "wires": []
    },
    {
        "id": "fcff90fc4f68c8b2",
        "type": "subflow:f30e8140.1bed9",
        "z": "173260fb.d021ff",
        "name": "",
        "env": [
            {
                "name": "remote",
                "value": "global.instance_name",
                "type": "str"
            },
            {
                "name": "device",
                "value": "NULL",
                "type": "str"
            },
            {
                "name": "property",
                "value": "NULL",
                "type": "str"
            },
            {
                "name": "NULL",
                "value": "delete",
                "type": "str"
            }
        ],
        "x": 250,
        "y": 2520,
        "wires": [
            [
                "34ce7f2ba4a63515"
            ]
        ],
        "info": "xamples\n\n1. GET core.version local:\n\n> remote:   NULL\n> device:   core\n> property: version\n> value:    NULL\n\nExpected result (configuration dependent)\n\n    TX: GET fake 'core'/'version'\n    \nthen: \n\n    [\"RX: 'core/version' object] \n\n2. GET locale device list\n\n > remote:   global.instance_name\n > device:   NULL\n > property: NULL\n > value:    NULL\n\nExpected result (requires system, configuration dependent)\n\n      DEVPC: TX: GET device LIST\n       (DEVPC = actual local instance name)\n      \n      [ \"TX: SET fake HAL@home/_proxy\", object ]\nthen:\n\n      [ \"DEVPC: RX: HAL@home/list\", array[3] ]\n\nexpanded:\n\n    array[2]\n        0: \"DEVPC: RX: HAL@home/list\"\n        1: array[3]\n            0: \"HAL@home\"\n            1: \"core\"\n            2: \"tuya_bridge\"\n"
    },
    {
        "id": "d560677335094d3e",
        "type": "comment",
        "z": "173260fb.d021ff",
        "name": "REST:     http://localhost:1984/tuyaDAEMON",
        "info": "",
        "x": 940,
        "y": 2260,
        "wires": []
    },
    {
        "id": "19cea4348c0edc67",
        "type": "MySQLdatabase",
        "name": "local",
        "host": "127.0.0.1",
        "port": "3306",
        "db": "tuyathome",
        "tz": "",
        "charset": "UTF8"
    },
    {
        "id": "93f8bfd.d0c854",
        "type": "MySQLdatabase",
        "name": "ANDROID",
        "host": "192.168.1.4",
        "port": "3306",
        "db": "tuyathome",
        "tz": "",
        "charset": "UTF8"
    }
]